<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spinnaker_tools: include/sark.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spinnaker_tools
   &#160;<span id="projectnumber">3.4.0</span>
   </div>
   <div id="projectbrief">SpiNNaker API, sark, sc&amp;mp, bmp firmware and build tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sark.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Spinnaker Application Runtime Kernel API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="spinnaker_8h_source.html">spinnaker.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="version_8h_source.html">version.h</a>&gt;</code><br />
</div>
<p><a href="sark_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structdivmod__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structdivmod__t">divmod_t</a></td></tr>
<tr class="memdesc:structdivmod__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned (div, mod) from divmod()  <a href="sark_8h.html#structdivmod__t">More...</a><br /></td></tr>
<tr class="separator:structdivmod__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmem__link__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structmem__link__t">mem_link_t</a></td></tr>
<tr class="memdesc:structmem__link__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in the block memory allocator (4 bytes)  <a href="sark_8h.html#structmem__link__t">More...</a><br /></td></tr>
<tr class="separator:structmem__link__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmem__block__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a></td></tr>
<tr class="memdesc:structmem__block__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in the block memory allocator (8 bytes)  <a href="sark_8h.html#structmem__block__t">More...</a><br /></td></tr>
<tr class="separator:structmem__block__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsrom__data__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsrom__data__t">srom_data_t</a></td></tr>
<tr class="memdesc:structsrom__data__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of SV SROM area (32 bytes)  <a href="sark_8h.html#structsrom__data__t">More...</a><br /></td></tr>
<tr class="separator:structsrom__data__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrtr__entry__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a></td></tr>
<tr class="memdesc:structrtr__entry__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of router entry (16 bytes)  <a href="sark_8h.html#structrtr__entry__t">More...</a><br /></td></tr>
<tr class="separator:structrtr__entry__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structapp__data__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structapp__data__t">app_data_t</a></td></tr>
<tr class="memdesc:structapp__data__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores info relating to AppIDs.  <a href="sark_8h.html#structapp__data__t">More...</a><br /></td></tr>
<tr class="separator:structapp__data__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdp__msg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a></td></tr>
<tr class="memdesc:structsdp__msg__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDP message definition.  <a href="sark_8h.html#structsdp__msg__t">More...</a><br /></td></tr>
<tr class="separator:structsdp__msg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdp__hdr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsdp__hdr__t">sdp_hdr_t</a></td></tr>
<tr class="memdesc:structsdp__hdr__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDP header: legacy.  <a href="sark_8h.html#structsdp__hdr__t">More...</a><br /></td></tr>
<tr class="separator:structsdp__hdr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcmd__hdr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structcmd__hdr__t">cmd_hdr_t</a></td></tr>
<tr class="memdesc:structcmd__hdr__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command header: legacy.  <a href="sark_8h.html#structcmd__hdr__t">More...</a><br /></td></tr>
<tr class="separator:structcmd__hdr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structblock__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structblock__t">block_t</a></td></tr>
<tr class="memdesc:structblock__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap data block.  <a href="sark_8h.html#structblock__t">More...</a><br /></td></tr>
<tr class="separator:structblock__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structheap__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structheap__t">heap_t</a></td></tr>
<tr class="memdesc:structheap__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap root structure.  <a href="sark_8h.html#structheap__t">More...</a><br /></td></tr>
<tr class="separator:structheap__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structevent__vec__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structevent__vec__t">event_vec_t</a></td></tr>
<tr class="memdesc:structevent__vec__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event_vec fits into 32 bits and contains a handler address in 16 bits and a priority and slot number, each 8 bits.  <a href="sark_8h.html#structevent__vec__t">More...</a><br /></td></tr>
<tr class="separator:structevent__vec__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsark__vec__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsark__vec__t">sark_vec_t</a></td></tr>
<tr class="memdesc:structsark__vec__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct of type <a class="el" href="sark_8h.html#structsark__vec__t" title="A struct of type sark_vec_t lives at address 0x20, that is, it is built into the code section.">sark_vec_t</a> lives at address 0x20, that is, it is built into the code section.  <a href="sark_8h.html#structsark__vec__t">More...</a><br /></td></tr>
<tr class="separator:structsark__vec__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structvcpu__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structvcpu__t">vcpu_t</a></td></tr>
<tr class="memdesc:structvcpu__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing information about each virtual processor.  <a href="sark_8h.html#structvcpu__t">More...</a><br /></td></tr>
<tr class="separator:structvcpu__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structevent__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structevent__t">event_t</a></td></tr>
<tr class="memdesc:structevent__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event structure used by "event_xxx" and "timer_xxx" routines.  <a href="sark_8h.html#structevent__t">More...</a><br /></td></tr>
<tr class="separator:structevent__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structproc__queue__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structproc__queue__t">proc_queue_t</a></td></tr>
<tr class="memdesc:structproc__queue__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding head and tail of a list of "event_t".  <a href="sark_8h.html#structproc__queue__t">More...</a><br /></td></tr>
<tr class="separator:structproc__queue__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpkt__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structpkt__t">pkt_t</a></td></tr>
<tr class="memdesc:structpkt__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding a packet.  <a href="sark_8h.html#structpkt__t">More...</a><br /></td></tr>
<tr class="separator:structpkt__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structevent__data__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structevent__data__t">event_data_t</a></td></tr>
<tr class="memdesc:structevent__data__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding data for "sark_event" and "sark_timer".  <a href="sark_8h.html#structevent__data__t">More...</a><br /></td></tr>
<tr class="separator:structevent__data__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsark__data__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsark__data__t">sark_data_t</a></td></tr>
<tr class="memdesc:structsark__data__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct holding all of the variables maintained by SARK.  <a href="sark_8h.html#structsark__data__t">More...</a><br /></td></tr>
<tr class="separator:structsark__data__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsv__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#structsv__t">sv_t</a></td></tr>
<tr class="memdesc:structsv__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding the System Variables.  <a href="sark_8h.html#structsv__t">More...</a><br /></td></tr>
<tr class="separator:structsv__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad53b88aee1fc3aeea750b030563cb85e"><td class="memItemLeft" align="right" valign="top"><a id="ad53b88aee1fc3aeea750b030563cb85e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad53b88aee1fc3aeea750b030563cb85e">SARK_EVENT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ad53b88aee1fc3aeea750b030563cb85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to link to "event". <br /></td></tr>
<tr class="separator:ad53b88aee1fc3aeea750b030563cb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eff7d653ca04b3398d701c8182fb99"><td class="memItemLeft" align="right" valign="top"><a id="ad6eff7d653ca04b3398d701c8182fb99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad6eff7d653ca04b3398d701c8182fb99">NUM_SDP_MSGS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ad6eff7d653ca04b3398d701c8182fb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of SDP messages for SARK. <br /></td></tr>
<tr class="separator:ad6eff7d653ca04b3398d701c8182fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1d38814b019802b8e34aaa912e631d"><td class="memItemLeft" align="right" valign="top"><a id="aeb1d38814b019802b8e34aaa912e631d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aeb1d38814b019802b8e34aaa912e631d">SARK_SLOT</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:aeb1d38814b019802b8e34aaa912e631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">VIC slot for SARK interrupt. <br /></td></tr>
<tr class="separator:aeb1d38814b019802b8e34aaa912e631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653fe83d252a32d8d5ce65a1372841f2"><td class="memItemLeft" align="right" valign="top"><a id="a653fe83d252a32d8d5ce65a1372841f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a653fe83d252a32d8d5ce65a1372841f2">INIT_EVENTS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a653fe83d252a32d8d5ce65a1372841f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of events initially allocated. <br /></td></tr>
<tr class="separator:a653fe83d252a32d8d5ce65a1372841f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d36536f69ec829a60d5fb243dd2cfa"><td class="memItemLeft" align="right" valign="top"><a id="a34d36536f69ec829a60d5fb243dd2cfa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a34d36536f69ec829a60d5fb243dd2cfa">DEAD_WORD</a>&#160;&#160;&#160;0xdeaddead</td></tr>
<tr class="memdesc:a34d36536f69ec829a60d5fb243dd2cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack fill value. <br /></td></tr>
<tr class="separator:a34d36536f69ec829a60d5fb243dd2cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae886ad5b9af398395184d1bf093481c6"><td class="memItemLeft" align="right" valign="top"><a id="ae886ad5b9af398395184d1bf093481c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae886ad5b9af398395184d1bf093481c6">ntohs</a>(t)&#160;&#160;&#160;((((t) &amp; 0x00ff) &lt;&lt; 8) | (((t) &gt;&gt; 8) &amp; 0x00ff))</td></tr>
<tr class="memdesc:ae886ad5b9af398395184d1bf093481c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to convert shorts from network byte order. <br /></td></tr>
<tr class="separator:ae886ad5b9af398395184d1bf093481c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae73de95a4f522c1dace01eab8ae063"><td class="memItemLeft" align="right" valign="top"><a id="a9ae73de95a4f522c1dace01eab8ae063"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a9ae73de95a4f522c1dace01eab8ae063">htons</a>(t)&#160;&#160;&#160;((((t) &amp; 0x00ff) &lt;&lt; 8) | (((t) &gt;&gt; 8) &amp; 0x00ff))</td></tr>
<tr class="memdesc:a9ae73de95a4f522c1dace01eab8ae063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to convert shorts to network byte order. <br /></td></tr>
<tr class="separator:a9ae73de95a4f522c1dace01eab8ae063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b085d7fd8f90ea0ed018cc74c08f27"><td class="memItemLeft" align="right" valign="top"><a id="a20b085d7fd8f90ea0ed018cc74c08f27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a20b085d7fd8f90ea0ed018cc74c08f27">CHIP_ID</a>(x,  y)&#160;&#160;&#160;(((x) &lt;&lt; 8) + (y))</td></tr>
<tr class="memdesc:a20b085d7fd8f90ea0ed018cc74c08f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a chip ID from X and Y coordinates. <br /></td></tr>
<tr class="separator:a20b085d7fd8f90ea0ed018cc74c08f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbfa8e49ec710299267b458040f8f16"><td class="memItemLeft" align="right" valign="top"><a id="a6dbfa8e49ec710299267b458040f8f16"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6dbfa8e49ec710299267b458040f8f16">CHIP_X</a>(id)&#160;&#160;&#160;((id) &gt;&gt; 8)</td></tr>
<tr class="memdesc:a6dbfa8e49ec710299267b458040f8f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract chip X coordinate from a chip ID. <br /></td></tr>
<tr class="separator:a6dbfa8e49ec710299267b458040f8f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a20ed4ea1ef5a0c5b87777f1e8ea9"><td class="memItemLeft" align="right" valign="top"><a id="a027a20ed4ea1ef5a0c5b87777f1e8ea9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a027a20ed4ea1ef5a0c5b87777f1e8ea9">CHIP_Y</a>(id)&#160;&#160;&#160;((id) &amp; 255)</td></tr>
<tr class="memdesc:a027a20ed4ea1ef5a0c5b87777f1e8ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract chip Y coordinate from a chip ID. <br /></td></tr>
<tr class="separator:a027a20ed4ea1ef5a0c5b87777f1e8ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b562826d75a678a5f5656e3e262d776"><td class="memItemLeft" align="right" valign="top"><a id="a2b562826d75a678a5f5656e3e262d776"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2b562826d75a678a5f5656e3e262d776">APLX_ENTRY_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a2b562826d75a678a5f5656e3e262d776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes per table entry. <br /></td></tr>
<tr class="separator:a2b562826d75a678a5f5656e3e262d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c56adc87e94ffa32287d49fe5aa6d5"><td class="memItemLeft" align="right" valign="top"><a id="a10c56adc87e94ffa32287d49fe5aa6d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a10c56adc87e94ffa32287d49fe5aa6d5">APLX_BUF_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:a10c56adc87e94ffa32287d49fe5aa6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of APLX loader code. <br /></td></tr>
<tr class="separator:a10c56adc87e94ffa32287d49fe5aa6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c408316681bfd84d6ffe373585f5731"><td class="memItemLeft" align="right" valign="top"><a id="a4c408316681bfd84d6ffe373585f5731"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4c408316681bfd84d6ffe373585f5731">APLX_BUFFER</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#a7c0c967b2dbb7d7d7cc4c1c45e631816">ITCM_TOP</a> - <a class="el" href="sark_8h.html#a10c56adc87e94ffa32287d49fe5aa6d5">APLX_BUF_SIZE</a>)</td></tr>
<tr class="memdesc:a4c408316681bfd84d6ffe373585f5731"><td class="mdescLeft">&#160;</td><td class="mdescRight">The APLX buffer lives at the top of ITCM, starting at 0x7fc0. <br /></td></tr>
<tr class="separator:a4c408316681bfd84d6ffe373585f5731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc8ad847508cf752f5debd1c038206"><td class="memItemLeft" align="right" valign="top"><a id="a15fc8ad847508cf752f5debd1c038206"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a15fc8ad847508cf752f5debd1c038206">TAG_NONE</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:a15fc8ad847508cf752f5debd1c038206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid tag/transient request. <br /></td></tr>
<tr class="separator:a15fc8ad847508cf752f5debd1c038206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68660d24c801e835ec97b7e541a6722"><td class="memItemLeft" align="right" valign="top"><a id="aa68660d24c801e835ec97b7e541a6722"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa68660d24c801e835ec97b7e541a6722">TAG_HOST</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa68660d24c801e835ec97b7e541a6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved for host. <br /></td></tr>
<tr class="separator:aa68660d24c801e835ec97b7e541a6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ca58ae605de746d1b10d17fe0b03c5"><td class="memItemLeft" align="right" valign="top"><a id="a62ca58ae605de746d1b10d17fe0b03c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a62ca58ae605de746d1b10d17fe0b03c5">RTR_ALLOC_FIRST</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a62ca58ae605de746d1b10d17fe0b03c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be &gt; 0. <br /></td></tr>
<tr class="separator:a62ca58ae605de746d1b10d17fe0b03c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9104486bdb50a1bf8146a3f2e7755782"><td class="memItemLeft" align="right" valign="top"><a id="a9104486bdb50a1bf8146a3f2e7755782"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a9104486bdb50a1bf8146a3f2e7755782">RTR_ALLOC_LAST</a>&#160;&#160;&#160;<a class="el" href="spinnaker_8h.html#aa4a0b1604e13b1dc372f9c1bc8bf04a7">MC_TABLE_SIZE</a></td></tr>
<tr class="memdesc:a9104486bdb50a1bf8146a3f2e7755782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be &lt;= MC_TABLE_SIZE. <br /></td></tr>
<tr class="separator:a9104486bdb50a1bf8146a3f2e7755782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d7af265bf828a5c6fad9ceb95e8e0a"><td class="memItemLeft" align="right" valign="top"><a id="a09d7af265bf828a5c6fad9ceb95e8e0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a09d7af265bf828a5c6fad9ceb95e8e0a">RTR_ALLOC_MAX</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#a9104486bdb50a1bf8146a3f2e7755782">RTR_ALLOC_LAST</a> - <a class="el" href="sark_8h.html#a62ca58ae605de746d1b10d17fe0b03c5">RTR_ALLOC_FIRST</a>)</td></tr>
<tr class="memdesc:a09d7af265bf828a5c6fad9ceb95e8e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest allowable request (1023 entries) <br /></td></tr>
<tr class="separator:a09d7af265bf828a5c6fad9ceb95e8e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170c14469b29096618dd05f78a9414c4"><td class="memItemLeft" align="right" valign="top"><a id="a170c14469b29096618dd05f78a9414c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a170c14469b29096618dd05f78a9414c4">ALLOC_LOCK</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a170c14469b29096618dd05f78a9414c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this operation. <br /></td></tr>
<tr class="separator:a170c14469b29096618dd05f78a9414c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff0a91d1c257f90c16d72e4a48f619a"><td class="memItemLeft" align="right" valign="top"><a id="a6ff0a91d1c257f90c16d72e4a48f619a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6ff0a91d1c257f90c16d72e4a48f619a">ALLOC_ID</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6ff0a91d1c257f90c16d72e4a48f619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use supplied AppID. <br /></td></tr>
<tr class="separator:a6ff0a91d1c257f90c16d72e4a48f619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849f3988621b83a38f7ddcfd5ee72b5d"><td class="memItemLeft" align="right" valign="top"><a id="a849f3988621b83a38f7ddcfd5ee72b5d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a849f3988621b83a38f7ddcfd5ee72b5d">A_LOCK_SEMA</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a849f3988621b83a38f7ddcfd5ee72b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with enum spin_lock_e) <br /></td></tr>
<tr class="separator:a849f3988621b83a38f7ddcfd5ee72b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663ac8a882d1dc5f5835e334a8fb06f3"><td class="memItemLeft" align="right" valign="top"><a id="a663ac8a882d1dc5f5835e334a8fb06f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a663ac8a882d1dc5f5835e334a8fb06f3">A_STATE_RTE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a663ac8a882d1dc5f5835e334a8fb06f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with enum cpu_state_e) <br /></td></tr>
<tr class="separator:a663ac8a882d1dc5f5835e334a8fb06f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25425ecb642d0c2357851329b8ea1c88"><td class="memItemLeft" align="right" valign="top"><a id="a25425ecb642d0c2357851329b8ea1c88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a25425ecb642d0c2357851329b8ea1c88">EVENT_COUNT</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a25425ecb642d0c2357851329b8ea1c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with enum event_type_e) <br /></td></tr>
<tr class="separator:a25425ecb642d0c2357851329b8ea1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8988d6632fc64b0ec4a8528cebb7fd"><td class="memItemLeft" align="right" valign="top"><a id="aaa8988d6632fc64b0ec4a8528cebb7fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aaa8988d6632fc64b0ec4a8528cebb7fd">LED_ON</a>(n)&#160;&#160;&#160;(3 &lt;&lt; (2 * n))</td></tr>
<tr class="memdesc:aaa8988d6632fc64b0ec4a8528cebb7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn LED on. <br /></td></tr>
<tr class="separator:aaa8988d6632fc64b0ec4a8528cebb7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552169688fe8834a280b877a8cf5020e"><td class="memItemLeft" align="right" valign="top"><a id="a552169688fe8834a280b877a8cf5020e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a552169688fe8834a280b877a8cf5020e">LED_OFF</a>(n)&#160;&#160;&#160;(2 &lt;&lt; (2 * n))</td></tr>
<tr class="memdesc:a552169688fe8834a280b877a8cf5020e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn LED off. <br /></td></tr>
<tr class="separator:a552169688fe8834a280b877a8cf5020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac125daaf2b16529462ed1637244e2"><td class="memItemLeft" align="right" valign="top"><a id="a40ac125daaf2b16529462ed1637244e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a40ac125daaf2b16529462ed1637244e2">LED_INV</a>(n)&#160;&#160;&#160;(1 &lt;&lt; (2 * n))</td></tr>
<tr class="memdesc:a40ac125daaf2b16529462ed1637244e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip state of LED. <br /></td></tr>
<tr class="separator:a40ac125daaf2b16529462ed1637244e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0428d662807a997b839e76d2d1e6f"><td class="memItemLeft" align="right" valign="top"><a id="aebf0428d662807a997b839e76d2d1e6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aebf0428d662807a997b839e76d2d1e6f">LED_FLIP</a>(n)&#160;&#160;&#160;(1 &lt;&lt; (2 * n))</td></tr>
<tr class="memdesc:aebf0428d662807a997b839e76d2d1e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip state of LED. <br /></td></tr>
<tr class="separator:aebf0428d662807a997b839e76d2d1e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321f6e755eca39f34a67bb72223fe7d7"><td class="memItemLeft" align="right" valign="top"><a id="a321f6e755eca39f34a67bb72223fe7d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a321f6e755eca39f34a67bb72223fe7d7">NUM_SDP_PORTS</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a321f6e755eca39f34a67bb72223fe7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of SDP ports (0-7) <br /></td></tr>
<tr class="separator:a321f6e755eca39f34a67bb72223fe7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8e1ad5bc34269210d852edd533bc48"><td class="memItemLeft" align="right" valign="top"><a id="a3b8e1ad5bc34269210d852edd533bc48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3b8e1ad5bc34269210d852edd533bc48">PORT_SHIFT</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a3b8e1ad5bc34269210d852edd533bc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port is in top 3 bits. <br /></td></tr>
<tr class="separator:a3b8e1ad5bc34269210d852edd533bc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753dc0d0821793f46a32babcf2087a82"><td class="memItemLeft" align="right" valign="top"><a id="a753dc0d0821793f46a32babcf2087a82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a753dc0d0821793f46a32babcf2087a82">PORT_MASK</a>&#160;&#160;&#160;0xe0</td></tr>
<tr class="memdesc:a753dc0d0821793f46a32babcf2087a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port is in top 3 bits. <br /></td></tr>
<tr class="separator:a753dc0d0821793f46a32babcf2087a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cf6f0504db0209a04bb4a266289477"><td class="memItemLeft" align="right" valign="top"><a id="aa3cf6f0504db0209a04bb4a266289477"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa3cf6f0504db0209a04bb4a266289477">CPU_MASK</a>&#160;&#160;&#160;0x1f</td></tr>
<tr class="memdesc:aa3cf6f0504db0209a04bb4a266289477"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU is in bottom 5 bits. <br /></td></tr>
<tr class="separator:aa3cf6f0504db0209a04bb4a266289477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0393f315f127a8caa35b5d66c29853d1"><td class="memItemLeft" align="right" valign="top"><a id="a0393f315f127a8caa35b5d66c29853d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0393f315f127a8caa35b5d66c29853d1">PORT_ETH</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:a0393f315f127a8caa35b5d66c29853d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special to indicate Ethernet. <br /></td></tr>
<tr class="separator:a0393f315f127a8caa35b5d66c29853d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096e6ee6d2a16f2f252af0a8c023546"><td class="memItemLeft" align="right" valign="top"><a id="a0096e6ee6d2a16f2f252af0a8c023546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0096e6ee6d2a16f2f252af0a8c023546">SDP_BUF_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a0096e6ee6d2a16f2f252af0a8c023546"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDP data buffer capacity. <br /></td></tr>
<tr class="separator:a0096e6ee6d2a16f2f252af0a8c023546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6060b669d3bbd8528c906953d482b12e"><td class="memItemLeft" align="right" valign="top"><a id="a6060b669d3bbd8528c906953d482b12e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6060b669d3bbd8528c906953d482b12e">VCPU_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a6060b669d3bbd8528c906953d482b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of <a class="el" href="sark_8h.html#structvcpu__t" title="Struct containing information about each virtual processor.">vcpu_t</a>. <br /></td></tr>
<tr class="separator:a6060b669d3bbd8528c906953d482b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792e094cb18a9678817268cab9ec8f6e"><td class="memItemLeft" align="right" valign="top"><a id="a792e094cb18a9678817268cab9ec8f6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a792e094cb18a9678817268cab9ec8f6e">VCPU_RT_CODE</a>&#160;&#160;&#160;44</td></tr>
<tr class="memdesc:a792e094cb18a9678817268cab9ec8f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of rt_code. <br /></td></tr>
<tr class="separator:a792e094cb18a9678817268cab9ec8f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dcc8d21a6fda2015872afa0d87a40e"><td class="memItemLeft" align="right" valign="top"><a id="ab7dcc8d21a6fda2015872afa0d87a40e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab7dcc8d21a6fda2015872afa0d87a40e">VCPU_CPU_STATE</a>&#160;&#160;&#160;46</td></tr>
<tr class="memdesc:ab7dcc8d21a6fda2015872afa0d87a40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of cpu_state. <br /></td></tr>
<tr class="separator:ab7dcc8d21a6fda2015872afa0d87a40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba36169cb13c66bdfe0fbef16c40b7f"><td class="memItemLeft" align="right" valign="top"><a id="afba36169cb13c66bdfe0fbef16c40b7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afba36169cb13c66bdfe0fbef16c40b7f">VCPU_APP_ID</a>&#160;&#160;&#160;47</td></tr>
<tr class="memdesc:afba36169cb13c66bdfe0fbef16c40b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of app_id. <br /></td></tr>
<tr class="separator:afba36169cb13c66bdfe0fbef16c40b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af848793a9b2d4e9ec085572513370ec9"><td class="memItemLeft" align="right" valign="top"><a id="af848793a9b2d4e9ec085572513370ec9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af848793a9b2d4e9ec085572513370ec9">SARK_MSG_INT</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#a5b54d10e21fcb49a0672c0212179600ca0b797a8d4051fae405d5f59cc5a73c9b">INT0_INT</a>)</td></tr>
<tr class="memdesc:af848793a9b2d4e9ec085572513370ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for SARK to APP messaging. <br /></td></tr>
<tr class="separator:af848793a9b2d4e9ec085572513370ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cb7bda8b7575fcf048185ba2bed463"><td class="memItemLeft" align="right" valign="top"><a id="ad8cb7bda8b7575fcf048185ba2bed463"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad8cb7bda8b7575fcf048185ba2bed463">SARK_SIG_INT</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#a5b54d10e21fcb49a0672c0212179600ca246ae3fdd04e987d1344116549158e3e">INT1_INT</a>)</td></tr>
<tr class="memdesc:ad8cb7bda8b7575fcf048185ba2bed463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for SARK to APP signalling. <br /></td></tr>
<tr class="separator:ad8cb7bda8b7575fcf048185ba2bed463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92037fc3f1799ec52c6206f81fa8fd77"><td class="memItemLeft" align="right" valign="top"><a id="a92037fc3f1799ec52c6206f81fa8fd77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a92037fc3f1799ec52c6206f81fa8fd77">SARK_VIRT_CPU</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a92037fc3f1799ec52c6206f81fa8fd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with <a class="el" href="sark_8h.html#structsark__data__t" title="A struct holding all of the variables maintained by SARK.">sark_data_t</a>)) <br /></td></tr>
<tr class="separator:a92037fc3f1799ec52c6206f81fa8fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477f51f167f11ee8d7dee3d3606f80da"><td class="memItemLeft" align="right" valign="top"><a id="a477f51f167f11ee8d7dee3d3606f80da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a477f51f167f11ee8d7dee3d3606f80da">SARK_RANDOM</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a477f51f167f11ee8d7dee3d3606f80da"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with <a class="el" href="sark_8h.html#structsark__data__t" title="A struct holding all of the variables maintained by SARK.">sark_data_t</a>)) <br /></td></tr>
<tr class="separator:a477f51f167f11ee8d7dee3d3606f80da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15e08aee77ea798812f3a094f71931a"><td class="memItemLeft" align="right" valign="top"><a id="ac15e08aee77ea798812f3a094f71931a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ac15e08aee77ea798812f3a094f71931a">SARK_CPU_CLK</a>&#160;&#160;&#160;48</td></tr>
<tr class="memdesc:ac15e08aee77ea798812f3a094f71931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with <a class="el" href="sark_8h.html#structsark__data__t" title="A struct holding all of the variables maintained by SARK.">sark_data_t</a>)) <br /></td></tr>
<tr class="separator:ac15e08aee77ea798812f3a094f71931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a68a061183156ed09c67e2e724b0c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2">sw_error</a>(mode)&#160;&#160;&#160;<a class="el" href="sark__base_8c.html#aa82adc6677b15f452e59063cf4a8f2f0">sw_error_fl</a> (mode, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:a70a68a061183156ed09c67e2e724b0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sw_error calls <a class="el" href="sark_8h.html#aa82adc6677b15f452e59063cf4a8f2f0" title="Generates a software error, logging the filename and line number at which the error occurs.">sw_error_fl()</a>, inserting file name and line number automatically  <a href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2">More...</a><br /></td></tr>
<tr class="separator:a70a68a061183156ed09c67e2e724b0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SARK stack defaults</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The sizes below define individual sizes for three modes of four used by SARK. The sizes of individual stacks and the stack top can be modified at startup by using "sark_config". The size of the SYS mode stack is the difference between the sum of the three stack sizes given here and the overall stack length from the linker script. The default is for a stack length of 2048 and hence a SYS stack of 1152 bytes. All of these values must be a multiple of 4! </p><dl class="section note"><dt>Note</dt><dd>default stack top and length are specified in the linker script. </dd></dl>
</div></td></tr>
<tr class="memitem:a4565ab3ae591c3fffcf293acff6f8f89"><td class="memItemLeft" align="right" valign="top"><a id="a4565ab3ae591c3fffcf293acff6f8f89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4565ab3ae591c3fffcf293acff6f8f89">SVC_STACK</a>&#160;&#160;&#160;384</td></tr>
<tr class="memdesc:a4565ab3ae591c3fffcf293acff6f8f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of SVC stack. <br /></td></tr>
<tr class="separator:a4565ab3ae591c3fffcf293acff6f8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c0e292976f8a91aec9e4a3cbaa00cb"><td class="memItemLeft" align="right" valign="top"><a id="ae8c0e292976f8a91aec9e4a3cbaa00cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae8c0e292976f8a91aec9e4a3cbaa00cb">IRQ_STACK</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ae8c0e292976f8a91aec9e4a3cbaa00cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of IRQ stack. <br /></td></tr>
<tr class="separator:ae8c0e292976f8a91aec9e4a3cbaa00cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2098a7f33b4d50e1f11292ac4468a868"><td class="memItemLeft" align="right" valign="top"><a id="a2098a7f33b4d50e1f11292ac4468a868"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2098a7f33b4d50e1f11292ac4468a868">FIQ_STACK</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a2098a7f33b4d50e1f11292ac4468a868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of FIQ stack. <br /></td></tr>
<tr class="separator:a2098a7f33b4d50e1f11292ac4468a868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SARK I/O stream identifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used with <a class="el" href="sark_8h.html#a24e7b80208352d98dec4cbed92522afe" title="A simple &quot;printf&quot; routine.">io_printf()</a> and <a class="el" href="sark_8h.html#ae3d6e0b4f6796acf8fb2dc494453598f" title="Routine to put a character to an output stream.">io_put_char()</a> </p>
</div></td></tr>
<tr class="memitem:abf839f1e83698e15b6eec7ff83b6e35e"><td class="memItemLeft" align="right" valign="top"><a id="abf839f1e83698e15b6eec7ff83b6e35e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#abf839f1e83698e15b6eec7ff83b6e35e">IO_STD</a>&#160;&#160;&#160;((char *) 0)</td></tr>
<tr class="memdesc:abf839f1e83698e15b6eec7ff83b6e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct I/O via SDP. <br /></td></tr>
<tr class="separator:abf839f1e83698e15b6eec7ff83b6e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ae92a99e4f6d39dfd0d1cabce34da"><td class="memItemLeft" align="right" valign="top"><a id="ae07ae92a99e4f6d39dfd0d1cabce34da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae07ae92a99e4f6d39dfd0d1cabce34da">IO_DBG</a>&#160;&#160;&#160;((char *) 1)</td></tr>
<tr class="memdesc:ae07ae92a99e4f6d39dfd0d1cabce34da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level debug I/O. <br /></td></tr>
<tr class="separator:ae07ae92a99e4f6d39dfd0d1cabce34da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef82c62bd8ba080a719f3daeff6dcfa"><td class="memItemLeft" align="right" valign="top"><a id="a9ef82c62bd8ba080a719f3daeff6dcfa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a9ef82c62bd8ba080a719f3daeff6dcfa">IO_BUF</a>&#160;&#160;&#160;((char *) 2)</td></tr>
<tr class="memdesc:a9ef82c62bd8ba080a719f3daeff6dcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDRAM buffer (normal for running apps) <br /></td></tr>
<tr class="separator:a9ef82c62bd8ba080a719f3daeff6dcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae50cb72f8e2d59f8da0a102900ce015"><td class="memItemLeft" align="right" valign="top"><a id="aae50cb72f8e2d59f8da0a102900ce015"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aae50cb72f8e2d59f8da0a102900ce015">IO_NULL</a>&#160;&#160;&#160;((char *) 3)</td></tr>
<tr class="memdesc:aae50cb72f8e2d59f8da0a102900ce015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output &gt; <code>/dev/null</code> <br /></td></tr>
<tr class="separator:aae50cb72f8e2d59f8da0a102900ce015"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:add2659cdf5414e6ab00bc5c7471a07f8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a>) (void)</td></tr>
<tr class="memdesc:add2659cdf5414e6ab00bc5c7471a07f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basic type of an interrupt handler. Takes no arguments. Returns nothing.  <a href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">More...</a><br /></td></tr>
<tr class="separator:add2659cdf5414e6ab00bc5c7471a07f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bcbf0f89b96b8f40e0953419f0d3c8"><td class="memItemLeft" align="right" valign="top"><a id="a21bcbf0f89b96b8f40e0953419f0d3c8"></a>
typedef enum <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4">spin_lock_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a21bcbf0f89b96b8f40e0953419f0d3c8">spin_lock</a></td></tr>
<tr class="memdesc:a21bcbf0f89b96b8f40e0953419f0d3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum spin_lock_e. <br /></td></tr>
<tr class="separator:a21bcbf0f89b96b8f40e0953419f0d3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d457fd1484275d32efeba70e75a9af0"><td class="memItemLeft" align="right" valign="top"><a id="a5d457fd1484275d32efeba70e75a9af0"></a>
typedef enum <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806">rte_code_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5d457fd1484275d32efeba70e75a9af0">rte_code</a></td></tr>
<tr class="memdesc:a5d457fd1484275d32efeba70e75a9af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum rte_code_e. <br /></td></tr>
<tr class="separator:a5d457fd1484275d32efeba70e75a9af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cda0afbb13c1566fcf78c2bbd746a98"><td class="memItemLeft" align="right" valign="top"><a id="a6cda0afbb13c1566fcf78c2bbd746a98"></a>
typedef enum <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236d">cpu_state_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6cda0afbb13c1566fcf78c2bbd746a98">cpu_state</a></td></tr>
<tr class="memdesc:a6cda0afbb13c1566fcf78c2bbd746a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum cpu_state_e. <br /></td></tr>
<tr class="separator:a6cda0afbb13c1566fcf78c2bbd746a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cede94eab5ba2dbda7021d9846fdcdd"><td class="memItemLeft" align="right" valign="top"><a id="a0cede94eab5ba2dbda7021d9846fdcdd"></a>
typedef enum <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881">event_type_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a></td></tr>
<tr class="memdesc:a0cede94eab5ba2dbda7021d9846fdcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for enum event_type_e <br /></td></tr>
<tr class="separator:a0cede94eab5ba2dbda7021d9846fdcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab81ec56acf7c1537b75df21154f8d"><td class="memItemLeft" align="right" valign="top"><a id="a66ab81ec56acf7c1537b75df21154f8d"></a>
typedef enum <a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74a">event_state_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a66ab81ec56acf7c1537b75df21154f8d">event_state</a></td></tr>
<tr class="memdesc:a66ab81ec56acf7c1537b75df21154f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for enum event_state_e <br /></td></tr>
<tr class="separator:a66ab81ec56acf7c1537b75df21154f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cbeb17d515d4a60718a93633648bd4"><td class="memItemLeft" align="right" valign="top"><a id="a64cbeb17d515d4a60718a93633648bd4"></a>
typedef enum <a class="el" href="sark_8h.html#a680660a112faeb990fc97a25eef9d643">vic_slot_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a></td></tr>
<tr class="memdesc:a64cbeb17d515d4a60718a93633648bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum vic_slot_e. <br /></td></tr>
<tr class="separator:a64cbeb17d515d4a60718a93633648bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5554e4b7d32295045a3f7bbcbe1780ce"><td class="memItemLeft" align="right" valign="top"><a id="a5554e4b7d32295045a3f7bbcbe1780ce"></a>
typedef enum <a class="el" href="sark_8h.html#a1a22a8c1bf3352bc25f568010a38279b">event_priority_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a></td></tr>
<tr class="memdesc:a5554e4b7d32295045a3f7bbcbe1780ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum event_priority_e. <br /></td></tr>
<tr class="separator:a5554e4b7d32295045a3f7bbcbe1780ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9a700a97ff6b66bbc29d74a8ca5898"><td class="memItemLeft" align="right" valign="top"><a id="a2e9a700a97ff6b66bbc29d74a8ca5898"></a>
typedef enum <a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbe">sw_err_mode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2e9a700a97ff6b66bbc29d74a8ca5898">sw_err_mode</a></td></tr>
<tr class="memdesc:a2e9a700a97ff6b66bbc29d74a8ca5898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum sw_err_mode_e. <br /></td></tr>
<tr class="separator:a2e9a700a97ff6b66bbc29d74a8ca5898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324329d30936f98474493194a7e07847"><td class="memItemLeft" align="right" valign="top"><a id="a324329d30936f98474493194a7e07847"></a>
typedef enum <a class="el" href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446">sync_bool_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a324329d30936f98474493194a7e07847">sync_bool</a></td></tr>
<tr class="memdesc:a324329d30936f98474493194a7e07847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum sync_bool_e. <br /></td></tr>
<tr class="separator:a324329d30936f98474493194a7e07847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2da1959fb0fd7f5520919e558fbadfc"><td class="memItemLeft" align="right" valign="top"><a id="ab2da1959fb0fd7f5520919e558fbadfc"></a>
typedef enum <a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2">shm_cmd_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab2da1959fb0fd7f5520919e558fbadfc">shm_cmd</a></td></tr>
<tr class="memdesc:ab2da1959fb0fd7f5520919e558fbadfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum shm_cmd_e. <br /></td></tr>
<tr class="separator:ab2da1959fb0fd7f5520919e558fbadfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e8f0529265435d3864e2d7533b7f8a"><td class="memItemLeft" align="right" valign="top"><a id="a90e8f0529265435d3864e2d7533b7f8a"></a>
typedef enum <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015">signal_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a90e8f0529265435d3864e2d7533b7f8a">signal</a></td></tr>
<tr class="memdesc:a90e8f0529265435d3864e2d7533b7f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for enum signal_e. <br /></td></tr>
<tr class="separator:a90e8f0529265435d3864e2d7533b7f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe7f6e37874a6a9bd576fc6afd6b3a"><td class="memItemLeft" align="right" valign="top"><a id="a14fe7f6e37874a6a9bd576fc6afd6b3a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>) (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>)</td></tr>
<tr class="memdesc:a14fe7f6e37874a6a9bd576fc6afd6b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic (void) function taking two "uint" args. <br /></td></tr>
<tr class="separator:a14fe7f6e37874a6a9bd576fc6afd6b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a707dc476cdca6c9a8cd1695f25fe555a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555a">sark_aplx_command</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555aa87f9b6a1505b09b1d62a427cb02e68a4">APLX_ACOPY</a> = 1
, <a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555aa14a3db1b3e820917f084acee5b0cbcbf">APLX_RCOPY</a> = 2
, <a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555aadde259e49b3d9ddc8173d3627a1b5554">APLX_FILL</a> = 3
, <a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555aaf36a74033d29f7566f01738b80845e69">APLX_EXEC</a> = 4
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555aa15d4e155cc151a4f70298600b052ed48">APLX_END</a> = 0xff
<br />
 }</td></tr>
<tr class="memdesc:a707dc476cdca6c9a8cd1695f25fe555a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commands used in the APLX loader.  <a href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555a">More...</a><br /></td></tr>
<tr class="separator:a707dc476cdca6c9a8cd1695f25fe555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee57b7a2c3c335a5155b8fad8958d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4">spin_lock_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4a2bd89e77b8ad338358834341c7dce43d">LOCK_MSG</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4ac7cd8fa7e071fac1859700e3388bd964">LOCK_MBOX</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4afaa69bad332ec2fd0216ea262ee668ee">LOCK_ETHER</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4ad4155cd6adef65f957edaca879bc0c6e">LOCK_GPIO</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4a26842e7a97cc425a110d27d69a65e651">LOCK_API_ROOT</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4a251c7766d9bb74e4ce9c8aa5dd4e9b7f">LOCK_SEMA</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4a89d69bef15e6dd767c4d851969568b49">LOCK_HEAP</a>
, <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4a2403509583bec93127bb5a807ee64a90">LOCK_RTR</a>
<br />
 }</td></tr>
<tr class="separator:a5cee57b7a2c3c335a5155b8fad8958d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada83d5de50faddcc7a1a3a3354b3ec49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ada83d5de50faddcc7a1a3a3354b3ec49">app_flags_e</a> { <a class="el" href="sark_8h.html#ada83d5de50faddcc7a1a3a3354b3ec49a4e78619422e7eaaea3803e2bf1e5b55e">APP_FLAG_WAIT</a>
 }</td></tr>
<tr class="memdesc:ada83d5de50faddcc7a1a3a3354b3ec49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags in app_flags field.  <a href="sark_8h.html#ada83d5de50faddcc7a1a3a3354b3ec49">More...</a><br /></td></tr>
<tr class="separator:ada83d5de50faddcc7a1a3a3354b3ec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9347d757f8d978aa2d35927e21806"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806">rte_code_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806af19712c673bff49b738641905254d963">RTE_NONE</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a1dca7761a7d789527304b6bf9a9952aa">RTE_RESET</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806abfe89d504e69c2b906412d62d0ea5ea9">RTE_UNDEF</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a5f6cbc846580ec613b6856d4c763edfd">RTE_SVC</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a74283c5c33207d02e53ef2315c84a20d">RTE_PABT</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806af3e999535726c0d7294855bf261abcc7">RTE_DABT</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806ab0e4d003206cf229551f8dd414434114">RTE_IRQ</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806af32ac3e03175989ee4c9ba3a55f5ac52">RTE_FIQ</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a9e8efcaeece564e534416a5f54ad5d5d">RTE_VIC</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a228d90e8251d61de8cf4fe5026008998">RTE_ABORT</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806acd9e88eb8d10980ccdd8c1b2bb3ec035">RTE_MALLOC</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a7b6e67cfddc6236ae6c74f2e22f220e1">RTE_DIV0</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806ac566062eb6d8f30fb7ffbb6a7963044d">RTE_EVENT</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a66bc0d0be1de9f6afc1787e49ffae339">RTE_SWERR</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a80dda6ab0b06dcd07e8870765c9d2615">RTE_IOBUF</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a40f3f82c8cdd80ccbd9457be160d5b98">RTE_ENABLE</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806aadaf315a9f0d71ecb74bc0d2aa420996">RTE_NULL</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a00a3039990f8f9e2d2236286d0d9e786">RTE_PKT</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806a1d402645d5abfe4e00a6130ff0c66dfa">RTE_TIMER</a>
, <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806ad86ab887d63c00784b2efa65fa1cbb87">RTE_API</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806ad19840e59921fc9dd40af8f932a282a4">RTE_VER</a>
<br />
 }</td></tr>
<tr class="memdesc:a3cf9347d757f8d978aa2d35927e21806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time error codes, passed as first arg to <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a>  <a href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806">More...</a><br /></td></tr>
<tr class="separator:a3cf9347d757f8d978aa2d35927e21806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba531b9d7bd6ab156cf29a04a66216fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fb">sark_alib_rte_codes</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fba3d06b52632231b657557e80993907f6d">A_RTE_RESET</a> = 1
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fbaff8fe5f17e0c79da8b730074ec4e1869">A_RTE_UNDEF</a> = 2
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fbad0c8329749e6d90e83f091c131138b2a">A_RTE_SVC</a> = 3
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fbad79d30396f3ed5e46770ed59d70ddbed">A_RTE_PABT</a> = 4
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fba58976896638075c1f09e985fc288bc2e">A_RTE_DABT</a> = 5
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fba85ba342ddd7755f309884b75ac7b79ec">A_RTE_IRQ</a> = 6
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fba4e2805a1e9e04a279c566eb9060d46cd">A_RTE_FIQ</a> = 7
, <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fbacb62844ebe76904b9da8331ee1de8e47">A_RTE_VIC</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:aba531b9d7bd6ab156cf29a04a66216fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For "sark_alib.s" (maintain sync with enum rte_code_e)  <a href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fb">More...</a><br /></td></tr>
<tr class="separator:aba531b9d7bd6ab156cf29a04a66216fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37318835424d76f3f5b321058887236d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236d">cpu_state_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da5fdc95ad5a4ddcf32e79798c8b2c53b2">CPU_STATE_DEAD</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236dab6112bf8f882083d1481cdc949b86b54">CPU_STATE_PWRDN</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236daea3adbea49fd3cf9d2bffa4698ebe03d">CPU_STATE_RTE</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da081b5c672eb66e504283de013ffaeeb9">CPU_STATE_WDOG</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da7bebf57001a32d7dd3203e3ef346f37a">CPU_STATE_INIT</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236dad92a650aabe37b8b491eaff36fe15318">CPU_STATE_WAIT</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236dab06591102cb34c05e61dc151bb812d59">CPU_STATE_SARK</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da504ca9cb33bebc4ff8b20b3eb97facbd">CPU_STATE_RUN</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da6fa07205ec7c136824a44685895becf7">CPU_STATE_SYNC0</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da55fddfc9f3fe2b6429523deb00c458b9">CPU_STATE_SYNC1</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236dadcefe4af17b67dc5de698473127ea564">CPU_STATE_PAUSE</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236dae259fb0c2645704951236737a63322ee">CPU_STATE_EXIT</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da00c5193a3d21fe121673fd5e7b23f0f5">CPU_STATE_12</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da40e94686da942cc278f596f06a68ba39">CPU_STATE_13</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da23871c9467df994d98fd777deec61d99">CPU_STATE_14</a>
, <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236da20cbc4e49e69ce2f28bd2589defaf502">CPU_STATE_IDLE</a>
<br />
 }</td></tr>
<tr class="memdesc:a37318835424d76f3f5b321058887236d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of a core (limited to 16)  <a href="sark_8h.html#a37318835424d76f3f5b321058887236d">More...</a><br /></td></tr>
<tr class="separator:a37318835424d76f3f5b321058887236d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a826a649bbc6b8084e7c7d6bc23881"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881">event_type_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881a811c2a26881d48cc1a77300cd79a918e">EVENT_TIMER</a>
, <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881aec3d6aec2dfd7c4de1c10ca9a2372795">EVENT_RXPKT</a>
, <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881abf41b11fa8ff57c33f446088c38712bd">EVENT_SDP</a>
, <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881a822ec7de5e51e61b1e86620be23fe0bd">EVENT_USER</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881a0faa65d8fd5b5a4659b6473af6f941fb">EVENT_SIG</a>
, <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881a21b293748ec91ca885a07f6c9b218ea5">EVENT_DMA</a>
, <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881af66ca241c2a2e3ef806d69cb9fd7c339">EVENT_MAX</a> =EVENT_DMA
<br />
 }</td></tr>
<tr class="memdesc:ab9a826a649bbc6b8084e7c7d6bc23881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of event.  <a href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881">More...</a><br /></td></tr>
<tr class="separator:ab9a826a649bbc6b8084e7c7d6bc23881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb52540a2684e30650a8a4ac892f74a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74a">event_state_e</a> { <a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74aa589a97f39a2de0129bf372b1fd4216fd">EVENT_RUN</a>
, <a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74aa4a95b1a327b7f948875054edc5c2f76b">EVENT_PAUSE</a>
, <a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74aac9bede468864b3ea2574a7b355cf6590">EVENT_STOP</a>
 }</td></tr>
<tr class="memdesc:acdb52540a2684e30650a8a4ac892f74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of event execution.  <a href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74a">More...</a><br /></td></tr>
<tr class="separator:acdb52540a2684e30650a8a4ac892f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680660a112faeb990fc97a25eef9d643"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a680660a112faeb990fc97a25eef9d643">vic_slot_e</a> { <br />
&#160;&#160;<b>SLOT_0</b>
, <b>SLOT_1</b>
, <b>SLOT_2</b>
, <b>SLOT_3</b>
, <br />
&#160;&#160;<b>SLOT_4</b>
, <b>SLOT_5</b>
, <b>SLOT_6</b>
, <b>SLOT_7</b>
, <br />
&#160;&#160;<b>SLOT_8</b>
, <b>SLOT_9</b>
, <b>SLOT_10</b>
, <b>SLOT_11</b>
, <br />
&#160;&#160;<b>SLOT_12</b>
, <b>SLOT_13</b>
, <b>SLOT_14</b>
, <b>SLOT_15</b>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a680660a112faeb990fc97a25eef9d643a2cf274b6e5590191aacba5d191d5162c">SLOT_FIQ</a>
, <a class="el" href="sark_8h.html#a680660a112faeb990fc97a25eef9d643aa1cadb71ce46d1447d36d3c7ec5cb53c">SLOT_MAX</a> = SLOT_15
<br />
 }</td></tr>
<tr class="memdesc:a680660a112faeb990fc97a25eef9d643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slots in the VIC interrupt controller.  <a href="sark_8h.html#a680660a112faeb990fc97a25eef9d643">More...</a><br /></td></tr>
<tr class="separator:a680660a112faeb990fc97a25eef9d643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a22a8c1bf3352bc25f568010a38279b"><td class="memItemLeft" align="right" valign="top"><a id="a1a22a8c1bf3352bc25f568010a38279b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a1a22a8c1bf3352bc25f568010a38279b">event_priority_e</a> { <br />
&#160;&#160;<b>PRIO_0</b>
, <b>PRIO_1</b>
, <b>PRIO_2</b>
, <b>PRIO_3</b>
, <br />
&#160;&#160;<b>PRIO_MAX</b> = PRIO_3
<br />
 }</td></tr>
<tr class="memdesc:a1a22a8c1bf3352bc25f568010a38279b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event queue priorities. <br /></td></tr>
<tr class="separator:a1a22a8c1bf3352bc25f568010a38279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29002882868350d94a53ef964eddcdbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbe">sw_err_mode_e</a> { <a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbea708f4708e456e4554f57a99e34e5d22f">SW_OPT</a>
, <a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbea370be05a6e6dc866854719387984ab6f">SW_NEVER</a>
, <a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbeaeb6866cff0b528dbc9f449804f20cdc6">SW_RTE</a>
 }</td></tr>
<tr class="memdesc:a29002882868350d94a53ef964eddcdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode for <a class="el" href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2" title="sw_error calls sw_error_fl(), inserting file name and line number automatically">sw_error()</a> calls to decide if <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> is to be called.  <a href="sark_8h.html#a29002882868350d94a53ef964eddcdbe">More...</a><br /></td></tr>
<tr class="separator:a29002882868350d94a53ef964eddcdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5f3be8c06b875eff1b6e7501ca8446"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446">sync_bool_e</a> { <a class="el" href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446a22d97c7711134391b3bc55ddf432e25b">SYNC_NOWAIT</a>
, <a class="el" href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446a18a6fa8889d7501469a972a54da8943c">SYNC_WAIT</a>
 }</td></tr>
<tr class="memdesc:a7f5f3be8c06b875eff1b6e7501ca8446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup synchronisation bool.  <a href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446">More...</a><br /></td></tr>
<tr class="separator:a7f5f3be8c06b875eff1b6e7501ca8446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c27ffba6e45118ef6605f899911cf2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2">shm_cmd_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2a365e33483054f2d08201b35faf6ced36">SHM_IDLE</a>
, <a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2ac6e915c4e758a768bba1d80c69ec1d75">SHM_MSG</a>
, <a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2aecb3639fc13f200ea2bd988a07cd754a">SHM_NOP</a>
, <a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2a1dbdb8b836e3800024971f46dc61205b">SHM_SIGNAL</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2aedc5209f9eafcb96717369f76a07f81f">SHM_CMD</a>
<br />
 }</td></tr>
<tr class="memdesc:ab6c27ffba6e45118ef6605f899911cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mailbox commands passed to APs.  <a href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2">More...</a><br /></td></tr>
<tr class="separator:ab6c27ffba6e45118ef6605f899911cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4e9fc0acec47f32a5cc3737c894015"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015">signal_e</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015ae06d9cbab66716ec34598717c5d973a4">SIG_INIT</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a59d8d559f6300c81ed69a371bd131766">SIG_PWRDN</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a5fb8c6a63805565f9e699c631ac15dfe">SIG_STOP</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015aa4538103ce6a6d0e3c5f51b0b9333d51">SIG_START</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a4ea0ddcd6167372159567acc48950b9a">SIG_SYNC0</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a2a90faf7dd00f16614bc2c3bd1d957db">SIG_SYNC1</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a4033030dfc14b878cc7767ad7a53a7f0">SIG_PAUSE</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a29026413e1d3f85a38f640074e5a0db7">SIG_CONT</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015ae4eb5890f0cf58b082dd48469a74bd6e">SIG_EXIT</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015af24bd1d3addc94ce1c7ec81f8da905c9">SIG_TIMER</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a53cc3858df9643ebc82c0b04cc0538ea">SIG_USR0</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a71f5cfd2f4c4b67e88e559b6eb1004d3">SIG_USR1</a>
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a49a650cf8f35bf794982ca44e1af030e">SIG_USR2</a>
, <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015a6730124eaaa60ae2ff8858b1036ccf9e">SIG_USR3</a>
<br />
 }</td></tr>
<tr class="memdesc:a2e4e9fc0acec47f32a5cc3737c894015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals passed to applications.  <a href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015">More...</a><br /></td></tr>
<tr class="separator:a2e4e9fc0acec47f32a5cc3737c894015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add51abc04ff5e1d219053f53ce83fa05"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05">sark_scp_command_codes</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a576fb2eb53263319ee51fd4152ff8fcc">CMD_VER</a> = 0
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a51c06d6ddc76ff994a5aa1d25b71e57f">CMD_RUN</a> = 1
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a43d7f3a35093d4198124c87b43afdefb">CMD_READ</a> = 2
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a612986a7ae236cab656844222f00ba82">CMD_WRITE</a> = 3
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a3de37de83aeb28145a73805b4f4f5422">CMD_APLX</a> = 4
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ac04c56b963737bed98a9765d300e60aa">CMD_FILL</a> = 5
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a1f6052e4d5cda4eeba5759bec798cd3e">CMD_REMAP</a> = 16
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ac7dc40ac7d7b36b33599a9647741ec3a">CMD_LINK_READ</a> = 17
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ae1b0881e5b6d1168e83be5ca76b40249">CMD_LINK_WRITE</a> = 18
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ac200c7f643146c6174a04d70dd7c6765">CMD_AR</a> = 19
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a9768ff77bcde46195196e6466bc0ab5e">CMD_NNP</a> = 20
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a027c8932fc4f1f58d96be1c9d3573348">CMD_SIG</a> = 22
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ad11c5b33509ea0f84a1b50666bc0a4ca">CMD_FFD</a> = 23
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05aab54e60c11c527ae91bb806c0806a7f6">CMD_AS</a> = 24
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a41754a0808533384d7667e0c7c70bb28">CMD_LED</a> = 25
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05ae15692462fd93686a1e4c99d2eaea246">CMD_IPTAG</a> = 26
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a2cbdb534568d4ce50ae876dd98165dfb">CMD_SROM</a> = 27
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05aa1aeafde66020145ebd8c2cb24b522b8">CMD_ALLOC</a> = 28
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05adee488b16055c349f995c986587bbe26">CMD_RTR</a> = 29
, <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05a6b1ac29fd084fc49f7c5c5e80130614b">CMD_INFO</a> = 31
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05afa121c234cf98fbef4bcf6da8a690c78">CMD_TUBE</a> = 64
<br />
 }</td></tr>
<tr class="memdesc:add51abc04ff5e1d219053f53ce83fa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP command codes.  <a href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05">More...</a><br /></td></tr>
<tr class="separator:add51abc04ff5e1d219053f53ce83fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd23bc996e5f56e5f45964dc4e3fff0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0">sark_scp_return_codes</a> { <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ab834a5bb2ce6d97c2831fe3d71103c14">RC_OK</a> = 0x80
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ad6508f5b7837bba3ce27c3543b33a704">RC_LEN</a> = 0x81
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a83a9fda8ab6c52397676f85531a86348">RC_SUM</a> = 0x82
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a0f674dd3b0ad65f7afedd83a5b9c7416">RC_CMD</a> = 0x83
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a71a503467fc752c1a4e5e85917c840df">RC_ARG</a> = 0x84
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ace382a22765636da1bf2fc60fc541da5">RC_PORT</a> = 0x85
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a6aa8355501388bd7a58471d19e70cfb6">RC_TIMEOUT</a> = 0x86
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a7d7f9289cf848b83eec0d37b7d0fbeb5">RC_ROUTE</a> = 0x87
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ab135f1136713a6f55b3dd46f44b992bc">RC_CPU</a> = 0x88
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a7f57ddeaf846172d6ec6d1399e5417e7">RC_DEAD</a> = 0x89
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a8ca11e666cfc90593029e15c0b2e1748">RC_BUF</a> = 0x8a
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a0ddc10648826626c3262a569627d0596">RC_P2P_NOREPLY</a> = 0x8b
, <br />
&#160;&#160;<a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ace376f8bd2c08995e08dccabbe83c883">RC_P2P_REJECT</a> = 0x8c
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0ab97e74175c024de2876bcd9ac41d4c0a">RC_P2P_BUSY</a> = 0x8d
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0aa7dc80dad0b678969118ec0410c475d9">RC_P2P_TIMEOUT</a> = 0x8e
, <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0a93c187db9e33ca37865ba1e5cfbaff3a">RC_PKT_TX</a> = 0x8f
<br />
 }</td></tr>
<tr class="memdesc:a5dd23bc996e5f56e5f45964dc4e3fff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP return codes.  <a href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0">More...</a><br /></td></tr>
<tr class="separator:a5dd23bc996e5f56e5f45964dc4e3fff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3deefebff466d46ecda52171bd47d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a61d3deefebff466d46ecda52171bd47d">sark_scp_memory_size_types</a> { <a class="el" href="sark_8h.html#a61d3deefebff466d46ecda52171bd47da66aba953e1da3345bc207065c05c28d8">TYPE_BYTE</a> = 0
, <a class="el" href="sark_8h.html#a61d3deefebff466d46ecda52171bd47da793a9db18e0c2fd7a6b519c6453026d4">TYPE_HALF</a> = 1
, <a class="el" href="sark_8h.html#a61d3deefebff466d46ecda52171bd47dadcd42ea06b0d39bc3f09e2a6abf0b5f1">TYPE_WORD</a> = 2
 }</td></tr>
<tr class="memdesc:a61d3deefebff466d46ecda52171bd47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory size types.  <a href="sark_8h.html#a61d3deefebff466d46ecda52171bd47d">More...</a><br /></td></tr>
<tr class="separator:a61d3deefebff466d46ecda52171bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a082cf1e7488833e20c56430f4dc6667c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a082cf1e7488833e20c56430f4dc6667c">cpu_irq_enable</a> (void)</td></tr>
<tr class="memdesc:a082cf1e7488833e20c56430f4dc6667c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the IRQ interrupt in the core by clearing the appropriate bit in the CPSR.  <a href="sark_8h.html#a082cf1e7488833e20c56430f4dc6667c">More...</a><br /></td></tr>
<tr class="separator:a082cf1e7488833e20c56430f4dc6667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab088513d34540c8ad53a67deb34e6f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab088513d34540c8ad53a67deb34e6f7a">cpu_irq_disable</a> (void)</td></tr>
<tr class="memdesc:ab088513d34540c8ad53a67deb34e6f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the IRQ interrupt in the core by setting the appropriate bit in the CPSR.  <a href="sark_8h.html#ab088513d34540c8ad53a67deb34e6f7a">More...</a><br /></td></tr>
<tr class="separator:ab088513d34540c8ad53a67deb34e6f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65dc08d0addbd5e56abc418252de701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad65dc08d0addbd5e56abc418252de701">cpu_fiq_enable</a> (void)</td></tr>
<tr class="memdesc:ad65dc08d0addbd5e56abc418252de701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the FIQ interrupt in the core by clearing the appropriate bit in the CPSR.  <a href="sark_8h.html#ad65dc08d0addbd5e56abc418252de701">More...</a><br /></td></tr>
<tr class="separator:ad65dc08d0addbd5e56abc418252de701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3c1edeca108523719403b2f9b0772e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7d3c1edeca108523719403b2f9b0772e">cpu_fiq_disable</a> (void)</td></tr>
<tr class="memdesc:a7d3c1edeca108523719403b2f9b0772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the FIQ interrupt in the core by setting the appropriate bit in the CPSR.  <a href="sark_8h.html#a7d3c1edeca108523719403b2f9b0772e">More...</a><br /></td></tr>
<tr class="separator:a7d3c1edeca108523719403b2f9b0772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066ce48b9e8823e9535c533ce68a5147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a066ce48b9e8823e9535c533ce68a5147">cpu_int_enable</a> (void)</td></tr>
<tr class="memdesc:a066ce48b9e8823e9535c533ce68a5147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the FIQ and IRQ interrupts in the core by clearing the appropriate bits in the CPSR.  <a href="sark_8h.html#a066ce48b9e8823e9535c533ce68a5147">More...</a><br /></td></tr>
<tr class="separator:a066ce48b9e8823e9535c533ce68a5147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef80db94e3bc22ed0c13951c5b777f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a14ef80db94e3bc22ed0c13951c5b777f">cpu_int_disable</a> (void)</td></tr>
<tr class="memdesc:a14ef80db94e3bc22ed0c13951c5b777f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the FIQ and IRQ interrupts in the core by setting the appropriate bits in the CPSR.  <a href="sark_8h.html#a14ef80db94e3bc22ed0c13951c5b777f">More...</a><br /></td></tr>
<tr class="separator:a14ef80db94e3bc22ed0c13951c5b777f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475a13902c8055eb6aea178f8be3c6bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a475a13902c8055eb6aea178f8be3c6bb">cpu_int_restore</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpsr)</td></tr>
<tr class="memdesc:a475a13902c8055eb6aea178f8be3c6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the CPSR to the state provided in the argument.  <a href="sark_8h.html#a475a13902c8055eb6aea178f8be3c6bb">More...</a><br /></td></tr>
<tr class="separator:a475a13902c8055eb6aea178f8be3c6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e95f32619aef5e01d518e529b70ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a22e95f32619aef5e01d518e529b70ce9">cpu_get_sp</a> (void)</td></tr>
<tr class="memdesc:a22e95f32619aef5e01d518e529b70ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the core's stack pointer.  <a href="sark_8h.html#a22e95f32619aef5e01d518e529b70ce9">More...</a><br /></td></tr>
<tr class="separator:a22e95f32619aef5e01d518e529b70ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd4568f06db076d687fa3f4435becc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2dd4568f06db076d687fa3f4435becc4">cpu_get_cpsr</a> (void)</td></tr>
<tr class="memdesc:a2dd4568f06db076d687fa3f4435becc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the core's CPSR.  <a href="sark_8h.html#a2dd4568f06db076d687fa3f4435becc4">More...</a><br /></td></tr>
<tr class="separator:a2dd4568f06db076d687fa3f4435becc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856899694c28cdf55a40931ef6bbdb12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a856899694c28cdf55a40931ef6bbdb12">cpu_set_cpsr</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpsr)</td></tr>
<tr class="memdesc:a856899694c28cdf55a40931ef6bbdb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the core's CPSR to the supplied value.  <a href="sark_8h.html#a856899694c28cdf55a40931ef6bbdb12">More...</a><br /></td></tr>
<tr class="separator:a856899694c28cdf55a40931ef6bbdb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c64301dd0a88a9c2c6fd2c28234be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a74c64301dd0a88a9c2c6fd2c28234be2">cpu_get_cp15_cr</a> (void)</td></tr>
<tr class="memdesc:a74c64301dd0a88a9c2c6fd2c28234be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the core's CP15 Control register.  <a href="sark_8h.html#a74c64301dd0a88a9c2c6fd2c28234be2">More...</a><br /></td></tr>
<tr class="separator:a74c64301dd0a88a9c2c6fd2c28234be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1c1643cd51f2e97e26d582e53cc159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aed1c1643cd51f2e97e26d582e53cc159">cpu_set_cp15_cr</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> value)</td></tr>
<tr class="memdesc:aed1c1643cd51f2e97e26d582e53cc159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the core's CP15 Control Register to the supplied value.  <a href="sark_8h.html#aed1c1643cd51f2e97e26d582e53cc159">More...</a><br /></td></tr>
<tr class="separator:aed1c1643cd51f2e97e26d582e53cc159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96973cac0a4eb45f83b30785b8fc77ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a96973cac0a4eb45f83b30785b8fc77ca">cpu_wfi</a> (void)</td></tr>
<tr class="memdesc:a96973cac0a4eb45f83b30785b8fc77ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the core into sleep mode until an interrupt occurs at which point the function will return.  <a href="sark_8h.html#a96973cac0a4eb45f83b30785b8fc77ca">More...</a><br /></td></tr>
<tr class="separator:a96973cac0a4eb45f83b30785b8fc77ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0756562c562df4adb431af181f867711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0756562c562df4adb431af181f867711">cpu_sleep</a> (void)</td></tr>
<tr class="memdesc:a0756562c562df4adb431af181f867711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the core into sleep mode until an interrupt occurs at which point the interrupt will be serviced and the core will go back to sleep.  <a href="sark_8h.html#a0756562c562df4adb431af181f867711">More...</a><br /></td></tr>
<tr class="separator:a0756562c562df4adb431af181f867711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a88149045cde1e775328022b35d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4e5a88149045cde1e775328022b35d9d">cpu_shutdown</a> (void)</td></tr>
<tr class="memdesc:a4e5a88149045cde1e775328022b35d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the core into sleep mode and disable all interrupts in the VIC.  <a href="sark_8h.html#a4e5a88149045cde1e775328022b35d9d">More...</a><br /></td></tr>
<tr class="separator:a4e5a88149045cde1e775328022b35d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2018e60bb35fb629cdbb057368a2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4">rt_error</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> code,...)</td></tr>
<tr class="memdesc:abe2018e60bb35fb629cdbb057368a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to signal a fatal error.  <a href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4">More...</a><br /></td></tr>
<tr class="separator:abe2018e60bb35fb629cdbb057368a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbb47391ebe5563f3d43a343cb03f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6cbb47391ebe5563f3d43a343cb03f51">sark_mem_cpy</a> (void *dest, const void *src, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n)</td></tr>
<tr class="memdesc:a6cbb47391ebe5563f3d43a343cb03f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <code>n</code> bytes of memory from <code>src</code> to <code>dest</code>.  <a href="sark_8h.html#a6cbb47391ebe5563f3d43a343cb03f51">More...</a><br /></td></tr>
<tr class="separator:a6cbb47391ebe5563f3d43a343cb03f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58e22edc7b04c1a8ed25d7ada9f46f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad58e22edc7b04c1a8ed25d7ada9f46f5">sark_str_cpy</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:ad58e22edc7b04c1a8ed25d7ada9f46f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a NULL terminated string from <code>src</code> to <code>dest</code>.  <a href="sark_8h.html#ad58e22edc7b04c1a8ed25d7ada9f46f5">More...</a><br /></td></tr>
<tr class="separator:ad58e22edc7b04c1a8ed25d7ada9f46f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef96491568c6a6468cb4d35d1d18d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aeef96491568c6a6468cb4d35d1d18d07">sark_str_len</a> (char *string)</td></tr>
<tr class="memdesc:aeef96491568c6a6468cb4d35d1d18d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters in a zero terminated string.  <a href="sark_8h.html#aeef96491568c6a6468cb4d35d1d18d07">More...</a><br /></td></tr>
<tr class="separator:aeef96491568c6a6468cb4d35d1d18d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3cb686bab55b58b206f7f13b7ecafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8c3cb686bab55b58b206f7f13b7ecafa">sark_cpu_state</a> (<a class="el" href="sark_8h.html#a6cda0afbb13c1566fcf78c2bbd746a98">cpu_state</a> state)</td></tr>
<tr class="memdesc:a8c3cb686bab55b58b206f7f13b7ecafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CPU state field in the VCPU block for this core.  <a href="sark_8h.html#a8c3cb686bab55b58b206f7f13b7ecafa">More...</a><br /></td></tr>
<tr class="separator:a8c3cb686bab55b58b206f7f13b7ecafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420f512079b7df88c0da0aae266cd5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ac420f512079b7df88c0da0aae266cd5b">sark_msg_cpy</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *to, <a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *from)</td></tr>
<tr class="memdesc:ac420f512079b7df88c0da0aae266cd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an SDP message from one buffer to another.  <a href="sark_8h.html#ac420f512079b7df88c0da0aae266cd5b">More...</a><br /></td></tr>
<tr class="separator:ac420f512079b7df88c0da0aae266cd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9510d06461b092e5e2d4538147ed010e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a9510d06461b092e5e2d4538147ed010e">sark_word_cpy</a> (void *dest, const void *src, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n)</td></tr>
<tr class="memdesc:a9510d06461b092e5e2d4538147ed010e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast copy for memory buffers.  <a href="sark_8h.html#a9510d06461b092e5e2d4538147ed010e">More...</a><br /></td></tr>
<tr class="separator:a9510d06461b092e5e2d4538147ed010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f9c1bfb731a51ab1f969e3a45a8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aea3f9c1bfb731a51ab1f969e3a45a8b9">sark_word_set</a> (void *dest, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> data, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n)</td></tr>
<tr class="memdesc:aea3f9c1bfb731a51ab1f969e3a45a8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast memory setter for a block of memory.  <a href="sark_8h.html#aea3f9c1bfb731a51ab1f969e3a45a8b9">More...</a><br /></td></tr>
<tr class="separator:aea3f9c1bfb731a51ab1f969e3a45a8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7203fdd0bd3f58c51b7f63eb0ebfb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7e7203fdd0bd3f58c51b7f63eb0ebfb9">sark_lock_get</a> (<a class="el" href="sark_8h.html#a21bcbf0f89b96b8f40e0953419f0d3c8">spin_lock</a> lock)</td></tr>
<tr class="memdesc:a7e7203fdd0bd3f58c51b7f63eb0ebfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires one of the 32 built-in hardware locks provided by the chip.  <a href="sark_8h.html#a7e7203fdd0bd3f58c51b7f63eb0ebfb9">More...</a><br /></td></tr>
<tr class="separator:a7e7203fdd0bd3f58c51b7f63eb0ebfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10119efa59b363c6a6a9ac6703220096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a10119efa59b363c6a6a9ac6703220096">sark_lock_free</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpsr, <a class="el" href="sark_8h.html#a21bcbf0f89b96b8f40e0953419f0d3c8">spin_lock</a> lock)</td></tr>
<tr class="memdesc:a10119efa59b363c6a6a9ac6703220096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously acquired hardware lock.  <a href="sark_8h.html#a10119efa59b363c6a6a9ac6703220096">More...</a><br /></td></tr>
<tr class="separator:a10119efa59b363c6a6a9ac6703220096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7535e9fe6473c492496134dcb378a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#add7535e9fe6473c492496134dcb378a7">sark_sema_raise</a> (<a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *sema)</td></tr>
<tr class="memdesc:add7535e9fe6473c492496134dcb378a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise (increment) an 8-bit semaphore variable which is accessed via a pointer.  <a href="sark_8h.html#add7535e9fe6473c492496134dcb378a7">More...</a><br /></td></tr>
<tr class="separator:add7535e9fe6473c492496134dcb378a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fbeff6ae25da166f9895891da4d585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a34fbeff6ae25da166f9895891da4d585">sark_sema_lower</a> (<a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *sema)</td></tr>
<tr class="memdesc:a34fbeff6ae25da166f9895891da4d585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower (decrement) an 8-bit semaphore variable which is accessed via a pointer.  <a href="sark_8h.html#a34fbeff6ae25da166f9895891da4d585">More...</a><br /></td></tr>
<tr class="separator:a34fbeff6ae25da166f9895891da4d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d3315f83d10fc3071fc74ddc239248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad8d3315f83d10fc3071fc74ddc239248">sark_app_raise</a> (void)</td></tr>
<tr class="memdesc:ad8d3315f83d10fc3071fc74ddc239248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a semaphore associated with the AppID running on this core.  <a href="sark_8h.html#ad8d3315f83d10fc3071fc74ddc239248">More...</a><br /></td></tr>
<tr class="separator:ad8d3315f83d10fc3071fc74ddc239248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0488210f65d863dd3a609c71ae34a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad0488210f65d863dd3a609c71ae34a1b">sark_app_lower</a> (void)</td></tr>
<tr class="memdesc:ad0488210f65d863dd3a609c71ae34a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers a semaphore associated with the AppID running on this core.  <a href="sark_8h.html#ad0488210f65d863dd3a609c71ae34a1b">More...</a><br /></td></tr>
<tr class="separator:ad0488210f65d863dd3a609c71ae34a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae711485b0ed4f29a98a08f4476e6c1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae711485b0ed4f29a98a08f4476e6c1ed">sark_app_sema</a> (void)</td></tr>
<tr class="memdesc:ae711485b0ed4f29a98a08f4476e6c1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to get the value of the semaphore associated with the AppID running on this core.  <a href="sark_8h.html#ae711485b0ed4f29a98a08f4476e6c1ed">More...</a><br /></td></tr>
<tr class="separator:ae711485b0ed4f29a98a08f4476e6c1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b765a16adc6f4a88ac9017b9202ba83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7b765a16adc6f4a88ac9017b9202ba83">sark_app_cores</a> (void)</td></tr>
<tr class="memdesc:a7b765a16adc6f4a88ac9017b9202ba83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to get the number of cores on this chip which are running the current application.  <a href="sark_8h.html#a7b765a16adc6f4a88ac9017b9202ba83">More...</a><br /></td></tr>
<tr class="separator:a7b765a16adc6f4a88ac9017b9202ba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdba350f69ec3d46d9d559571feb0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#affdba350f69ec3d46d9d559571feb0f6">sark_app_lead</a> (void)</td></tr>
<tr class="memdesc:affdba350f69ec3d46d9d559571feb0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the core ID of the lowest numbered core on this chip which is running the current application.  <a href="sark_8h.html#affdba350f69ec3d46d9d559571feb0f6">More...</a><br /></td></tr>
<tr class="separator:affdba350f69ec3d46d9d559571feb0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4b606aff6663055d67d9bae754180d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a1e4b606aff6663055d67d9bae754180d">sark_srand</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> seed)</td></tr>
<tr class="memdesc:a1e4b606aff6663055d67d9bae754180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the random number generator with the supplied value.  <a href="sark_8h.html#a1e4b606aff6663055d67d9bae754180d">More...</a><br /></td></tr>
<tr class="separator:a1e4b606aff6663055d67d9bae754180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2f834ac2db53f8e42a422916ced870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3d2f834ac2db53f8e42a422916ced870">sark_rand</a> (void)</td></tr>
<tr class="memdesc:a3d2f834ac2db53f8e42a422916ced870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next 32-bit pseudo-random number in the sequence.  <a href="sark_8h.html#a3d2f834ac2db53f8e42a422916ced870">More...</a><br /></td></tr>
<tr class="separator:a3d2f834ac2db53f8e42a422916ced870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ad9bc03c755cf19b0bd1177d704d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structdivmod__t">divmod_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a527ad9bc03c755cf19b0bd1177d704d3">sark_div10</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n)</td></tr>
<tr class="memdesc:a527ad9bc03c755cf19b0bd1177d704d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the argument by 10 and return dividend and modulus in a struct of type <a class="el" href="sark_8h.html#structdivmod__t" title="Returned (div, mod) from divmod()">divmod_t</a> which has fields "div" and "mod".  <a href="sark_8h.html#a527ad9bc03c755cf19b0bd1177d704d3">More...</a><br /></td></tr>
<tr class="separator:a527ad9bc03c755cf19b0bd1177d704d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899892c855c4e5260c0b59086ad3866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2899892c855c4e5260c0b59086ad3866">sark_count_bits</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> word)</td></tr>
<tr class="memdesc:a2899892c855c4e5260c0b59086ad3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of bits set in a word.  <a href="sark_8h.html#a2899892c855c4e5260c0b59086ad3866">More...</a><br /></td></tr>
<tr class="separator:a2899892c855c4e5260c0b59086ad3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e93143297356f647563cd10400a2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a33e93143297356f647563cd10400a2a0">sark_bx</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> addr)</td></tr>
<tr class="memdesc:a33e93143297356f647563cd10400a2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an ARM BX instruction to the address in <code>addr</code>.  <a href="sark_8h.html#a33e93143297356f647563cd10400a2a0">More...</a><br /></td></tr>
<tr class="separator:a33e93143297356f647563cd10400a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeae6d5b8f962fb2c1dfb1ac1c39f0c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afeae6d5b8f962fb2c1dfb1ac1c39f0c1">sark_aplx</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *table, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:afeae6d5b8f962fb2c1dfb1ac1c39f0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to unpack an APLX table whose address is provided.  <a href="sark_8h.html#afeae6d5b8f962fb2c1dfb1ac1c39f0c1">More...</a><br /></td></tr>
<tr class="separator:afeae6d5b8f962fb2c1dfb1ac1c39f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d9f9030e4539662cad6650b6694fb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a01d9f9030e4539662cad6650b6694fb7">cpu_init_mode</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *stack, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:a01d9f9030e4539662cad6650b6694fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up stack for a given CPU mode.  <a href="sark_8h.html#a01d9f9030e4539662cad6650b6694fb7">More...</a><br /></td></tr>
<tr class="separator:a01d9f9030e4539662cad6650b6694fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db093995345a88674c13e7906d4ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a13db093995345a88674c13e7906d4ca3">chksum_64</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> a, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> b)</td></tr>
<tr class="separator:a13db093995345a88674c13e7906d4ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6249db4a87d742ba896db808317dea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae6249db4a87d742ba896db808317dea2">chksum_32</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> a)</td></tr>
<tr class="memdesc:ae6249db4a87d742ba896db808317dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 4-bit ones-complement checksum of a 32-bit quantity.  <a href="sark_8h.html#ae6249db4a87d742ba896db808317dea2">More...</a><br /></td></tr>
<tr class="separator:ae6249db4a87d742ba896db808317dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10c5c53ee9f467e3aad6e1a054cc466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa10c5c53ee9f467e3aad6e1a054cc466">sark_chip_id</a> (void)</td></tr>
<tr class="memdesc:aa10c5c53ee9f467e3aad6e1a054cc466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this chip as a 16-bit number.  <a href="sark_8h.html#aa10c5c53ee9f467e3aad6e1a054cc466">More...</a><br /></td></tr>
<tr class="separator:aa10c5c53ee9f467e3aad6e1a054cc466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fab81f030fe93ea4f247f2d27f1e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a57fab81f030fe93ea4f247f2d27f1e53">sark_core_id</a> (void)</td></tr>
<tr class="memdesc:a57fab81f030fe93ea4f247f2d27f1e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the virtual core number of this core.  <a href="sark_8h.html#a57fab81f030fe93ea4f247f2d27f1e53">More...</a><br /></td></tr>
<tr class="separator:a57fab81f030fe93ea4f247f2d27f1e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a95df8505e42ee47d56f3bb752a8ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5a95df8505e42ee47d56f3bb752a8ddc">sark_app_id</a> (void)</td></tr>
<tr class="memdesc:a5a95df8505e42ee47d56f3bb752a8ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of the application running on this core.  <a href="sark_8h.html#a5a95df8505e42ee47d56f3bb752a8ddc">More...</a><br /></td></tr>
<tr class="separator:a5a95df8505e42ee47d56f3bb752a8ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bef6fbe3bbf6c0b489a2435768d6703"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4bef6fbe3bbf6c0b489a2435768d6703">sark_app_name</a> (void)</td></tr>
<tr class="memdesc:a4bef6fbe3bbf6c0b489a2435768d6703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the name of the application running on this core.  <a href="sark_8h.html#a4bef6fbe3bbf6c0b489a2435768d6703">More...</a><br /></td></tr>
<tr class="separator:a4bef6fbe3bbf6c0b489a2435768d6703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ab790eb60f2c24aa9b20fff884e64b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab3ab790eb60f2c24aa9b20fff884e64b">sark_msg_get</a> (void)</td></tr>
<tr class="memdesc:ab3ab790eb60f2c24aa9b20fff884e64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an SDP message buffer from the pool maintained by SARK.  <a href="sark_8h.html#ab3ab790eb60f2c24aa9b20fff884e64b">More...</a><br /></td></tr>
<tr class="separator:ab3ab790eb60f2c24aa9b20fff884e64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6bbbfa956f793ea41c8702879cffbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8b6bbbfa956f793ea41c8702879cffbd">sark_msg_free</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a8b6bbbfa956f793ea41c8702879cffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an SDP message buffer which was acquired by <a class="el" href="sark_8h.html#ab3ab790eb60f2c24aa9b20fff884e64b" title="Get an SDP message buffer from the pool maintained by SARK.">sark_msg_get()</a> to the free buffer pool.  <a href="sark_8h.html#a8b6bbbfa956f793ea41c8702879cffbd">More...</a><br /></td></tr>
<tr class="separator:a8b6bbbfa956f793ea41c8702879cffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4e20f66a6e7058940cdbfdd077fbcdc4">sark_msg_send</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> timeout)</td></tr>
<tr class="memdesc:a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an SDP message.  <a href="sark_8h.html#a4e20f66a6e7058940cdbfdd077fbcdc4">More...</a><br /></td></tr>
<tr class="separator:a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a54c093dfe7ad72239509b663fdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a163a54c093dfe7ad72239509b663fdcb">sark_delay_us</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> delay)</td></tr>
<tr class="memdesc:a163a54c093dfe7ad72239509b663fdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a busy-wait for the given number of microseconds.  <a href="sark_8h.html#a163a54c093dfe7ad72239509b663fdcb">More...</a><br /></td></tr>
<tr class="separator:a163a54c093dfe7ad72239509b663fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82adc6677b15f452e59063cf4a8f2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa82adc6677b15f452e59063cf4a8f2f0">sw_error_fl</a> (<a class="el" href="sark_8h.html#a2e9a700a97ff6b66bbc29d74a8ca5898">sw_err_mode</a> mode, char *file, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> line)</td></tr>
<tr class="memdesc:aa82adc6677b15f452e59063cf4a8f2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a software error, logging the filename and line number at which the error occurs.  <a href="sark_8h.html#aa82adc6677b15f452e59063cf4a8f2f0">More...</a><br /></td></tr>
<tr class="separator:aa82adc6677b15f452e59063cf4a8f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6d37b96c4cd0339de66851e9852e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a10a6d37b96c4cd0339de66851e9852e1">sark_cmd_ver</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a10a6d37b96c4cd0339de66851e9852e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Version command.  <a href="sark_8h.html#a10a6d37b96c4cd0339de66851e9852e1">More...</a><br /></td></tr>
<tr class="separator:a10a6d37b96c4cd0339de66851e9852e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05105db095cf54052c1e00cb2d03424b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a05105db095cf54052c1e00cb2d03424b">sark_cmd_read</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a05105db095cf54052c1e00cb2d03424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Read command which reads memory and returns the data read to the host.  <a href="sark_8h.html#a05105db095cf54052c1e00cb2d03424b">More...</a><br /></td></tr>
<tr class="separator:a05105db095cf54052c1e00cb2d03424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214cec2f71f5dc818d88c0abc398fe29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a214cec2f71f5dc818d88c0abc398fe29">sark_cmd_write</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a214cec2f71f5dc818d88c0abc398fe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Write command which writes memory with data supplied by the host.  <a href="sark_8h.html#a214cec2f71f5dc818d88c0abc398fe29">More...</a><br /></td></tr>
<tr class="separator:a214cec2f71f5dc818d88c0abc398fe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d477747aa6b62a2448590a7f4ed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af67d477747aa6b62a2448590a7f4ed2d">sark_cmd_fill</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:af67d477747aa6b62a2448590a7f4ed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Fill command which fills memory with a data word.  <a href="sark_8h.html#af67d477747aa6b62a2448590a7f4ed2d">More...</a><br /></td></tr>
<tr class="separator:af67d477747aa6b62a2448590a7f4ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a451a1b870252451ae5661990db041"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a05a451a1b870252451ae5661990db041">sark_block_init</a> (void *buf, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count)</td></tr>
<tr class="memdesc:a05a451a1b870252451ae5661990db041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a memory buffer into a linked list of "count" blocks of "size" bytes.  <a href="sark_8h.html#a05a451a1b870252451ae5661990db041">More...</a><br /></td></tr>
<tr class="separator:a05a451a1b870252451ae5661990db041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d1de5c5e2f2a1607c05eb6f024a183"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a93d1de5c5e2f2a1607c05eb6f024a183">sark_block_get</a> (<a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *root)</td></tr>
<tr class="memdesc:a93d1de5c5e2f2a1607c05eb6f024a183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic call to get a buffer from a pool whose "root" is supplied.  <a href="sark_8h.html#a93d1de5c5e2f2a1607c05eb6f024a183">More...</a><br /></td></tr>
<tr class="separator:a93d1de5c5e2f2a1607c05eb6f024a183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d40f5611a6a76a083d0751d2ffcebc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3d40f5611a6a76a083d0751d2ffcebc3">sark_block_free</a> (<a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *root, void *blk)</td></tr>
<tr class="memdesc:a3d40f5611a6a76a083d0751d2ffcebc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic call to free a buffer into a pool whose "root" is supplied.  <a href="sark_8h.html#a3d40f5611a6a76a083d0751d2ffcebc3">More...</a><br /></td></tr>
<tr class="separator:a3d40f5611a6a76a083d0751d2ffcebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdfaf0e7bfe553bcafc6d04bf321bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a1bdfaf0e7bfe553bcafc6d04bf321bf1">sark_shmsg_get</a> (void)</td></tr>
<tr class="memdesc:a1bdfaf0e7bfe553bcafc6d04bf321bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a free SDP message from the shared SysRAM pool.  <a href="sark_8h.html#a1bdfaf0e7bfe553bcafc6d04bf321bf1">More...</a><br /></td></tr>
<tr class="separator:a1bdfaf0e7bfe553bcafc6d04bf321bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3c808f1b7045354a386c2bd2872df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a69f3c808f1b7045354a386c2bd2872df">sark_shmsg_free</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a69f3c808f1b7045354a386c2bd2872df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a shared memory SDP message to the shared SysRAM pool.  <a href="sark_8h.html#a69f3c808f1b7045354a386c2bd2872df">More...</a><br /></td></tr>
<tr class="separator:a69f3c808f1b7045354a386c2bd2872df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2885d11fa603c565e9084ffffc3fe557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2885d11fa603c565e9084ffffc3fe557">sark_call_cpp_constructors</a> (void)</td></tr>
<tr class="memdesc:a2885d11fa603c565e9084ffffc3fe557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the constructors for any C++ objects created at global scope.  <a href="sark_8h.html#a2885d11fa603c565e9084ffffc3fe557">More...</a><br /></td></tr>
<tr class="separator:a2885d11fa603c565e9084ffffc3fe557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e7b80208352d98dec4cbed92522afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a24e7b80208352d98dec4cbed92522afe">io_printf</a> (char *stream, char *format,...)</td></tr>
<tr class="memdesc:a24e7b80208352d98dec4cbed92522afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple "printf" routine.  <a href="sark_8h.html#a24e7b80208352d98dec4cbed92522afe">More...</a><br /></td></tr>
<tr class="separator:a24e7b80208352d98dec4cbed92522afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d6e0b4f6796acf8fb2dc494453598f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae3d6e0b4f6796acf8fb2dc494453598f">io_put_char</a> (char *stream, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> c)</td></tr>
<tr class="memdesc:ae3d6e0b4f6796acf8fb2dc494453598f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to put a character to an output stream.  <a href="sark_8h.html#ae3d6e0b4f6796acf8fb2dc494453598f">More...</a><br /></td></tr>
<tr class="separator:ae3d6e0b4f6796acf8fb2dc494453598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe00ab22d6ec00b7fc698270e7be8c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afe00ab22d6ec00b7fc698270e7be8c28">sark_io_buf_reset</a> (void)</td></tr>
<tr class="memdesc:afe00ab22d6ec00b7fc698270e7be8c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to reset the IOBUF for the core.  <a href="sark_8h.html#afe00ab22d6ec00b7fc698270e7be8c28">More...</a><br /></td></tr>
<tr class="separator:afe00ab22d6ec00b7fc698270e7be8c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d1e6e1b258fa76d6412827a1aa4f15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15">sark_alloc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:a30d1e6e1b258fa76d6412827a1aa4f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory of <code>count</code> &times; <code>size</code> bytes from the DTCM heap. Returns either a pointer to the block on success, or NULL on failure.  <a href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15">More...</a><br /></td></tr>
<tr class="separator:a30d1e6e1b258fa76d6412827a1aa4f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce895f48f22b29d2aefc923b38b280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a40ce895f48f22b29d2aefc923b38b280">sark_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a40ce895f48f22b29d2aefc923b38b280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a block of memory which was previously allocated by <a class="el" href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a> (i.e., from the DTCM heap).  <a href="sark_8h.html#a40ce895f48f22b29d2aefc923b38b280">More...</a><br /></td></tr>
<tr class="separator:a40ce895f48f22b29d2aefc923b38b280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f83786e86e8943b1e1a2d8fa68b85"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8d1f83786e86e8943b1e1a2d8fa68b85">sark_xalloc</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tag, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:a8d1f83786e86e8943b1e1a2d8fa68b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from the specified heap.  <a href="sark_8h.html#a8d1f83786e86e8943b1e1a2d8fa68b85">More...</a><br /></td></tr>
<tr class="separator:a8d1f83786e86e8943b1e1a2d8fa68b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4289de17bb19977ccbc8b1f680b4a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae4289de17bb19977ccbc8b1f680b4a6a">sark_xfree</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, void *ptr, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:ae4289de17bb19977ccbc8b1f680b4a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory block in the specified heap.  <a href="sark_8h.html#ae4289de17bb19977ccbc8b1f680b4a6a">More...</a><br /></td></tr>
<tr class="separator:ae4289de17bb19977ccbc8b1f680b4a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5197d7e0234aae820a2ddc722aeecbd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5197d7e0234aae820a2ddc722aeecbd4">sark_xfree_id</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:a5197d7e0234aae820a2ddc722aeecbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all allocated blocks in the specified heap which are tagged with the given "app_id".  <a href="sark_8h.html#a5197d7e0234aae820a2ddc722aeecbd4">More...</a><br /></td></tr>
<tr class="separator:a5197d7e0234aae820a2ddc722aeecbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89c52519c74f83f002becac03d9ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8e89c52519c74f83f002becac03d9ff3">sark_heap_max</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:a8e89c52519c74f83f002becac03d9ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the supplied heap and return the size of the largest free block (in bytes).  <a href="sark_8h.html#a8e89c52519c74f83f002becac03d9ff3">More...</a><br /></td></tr>
<tr class="separator:a8e89c52519c74f83f002becac03d9ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76688949797930a80f58584467243c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab76688949797930a80f58584467243c2">sark_heap_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *base, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *top)</td></tr>
<tr class="memdesc:ab76688949797930a80f58584467243c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an area of memory as a heap.  <a href="sark_8h.html#ab76688949797930a80f58584467243c2">More...</a><br /></td></tr>
<tr class="separator:ab76688949797930a80f58584467243c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d9cc3e46a707969eb592b258744e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#abb9d9cc3e46a707969eb592b258744e5">rtr_alloc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:abb9d9cc3e46a707969eb592b258744e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of entries in the router multicast table (and associate the caller's app_id with this block).  <a href="sark_8h.html#abb9d9cc3e46a707969eb592b258744e5">More...</a><br /></td></tr>
<tr class="separator:abb9d9cc3e46a707969eb592b258744e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2d7bb03f41c2c68ad7fdb944bb23af64">rtr_alloc_id</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of entries in the router multicast table (and associate the supplied app_id with this block).  <a href="sark_8h.html#a2d7bb03f41c2c68ad7fdb944bb23af64">More...</a><br /></td></tr>
<tr class="separator:a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5cb6e9bbf8425f6fe224833f6239c4ba">rtr_free</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> clear)</td></tr>
<tr class="memdesc:a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block of MC table entries which starts with the supplied entry. The relevant router registers can be optionally re-initialised.  <a href="sark_8h.html#a5cb6e9bbf8425f6fe224833f6239c4ba">More...</a><br /></td></tr>
<tr class="separator:a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e038cf666dba5f8be35bb8cb8eead45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7e038cf666dba5f8be35bb8cb8eead45">rtr_free_id</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> clear)</td></tr>
<tr class="memdesc:a7e038cf666dba5f8be35bb8cb8eead45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all allocated blocks in the router which are tagged with the given "app_id".  <a href="sark_8h.html#a7e038cf666dba5f8be35bb8cb8eead45">More...</a><br /></td></tr>
<tr class="separator:a7e038cf666dba5f8be35bb8cb8eead45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89de816e4c181b8f24ba21873b24a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af89de816e4c181b8f24ba21873b24a27">rtr_alloc_max</a> (void)</td></tr>
<tr class="memdesc:af89de816e4c181b8f24ba21873b24a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the largest free block in the router multicast table (or zero if table is full).  <a href="sark_8h.html#af89de816e4c181b8f24ba21873b24a27">More...</a><br /></td></tr>
<tr class="separator:af89de816e4c181b8f24ba21873b24a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f6ac4ac38c44dce34a617ed1f1aa6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a226f6ac4ac38c44dce34a617ed1f1aa6">sark_tag_ptr</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tag, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:a226f6ac4ac38c44dce34a617ed1f1aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a tagged allocation.  <a href="sark_8h.html#a226f6ac4ac38c44dce34a617ed1f1aa6">More...</a><br /></td></tr>
<tr class="separator:a226f6ac4ac38c44dce34a617ed1f1aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed572d885f25c88acdc5a11c26e51b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aed572d885f25c88acdc5a11c26e51b2c">sark_vic_init</a> (void)</td></tr>
<tr class="memdesc:aed572d885f25c88acdc5a11c26e51b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a full software initialisation of the VIC.  <a href="sark_8h.html#aed572d885f25c88acdc5a11c26e51b2c">More...</a><br /></td></tr>
<tr class="separator:aed572d885f25c88acdc5a11c26e51b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5523f51f1df77463689f9567c87884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8e5523f51f1df77463689f9567c87884">sark_vic_set</a> (<a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a> slot, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> interrupt, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> enable, <a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a> handler)</td></tr>
<tr class="memdesc:a8e5523f51f1df77463689f9567c87884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises one of the VIC slots to set up an interrupt handler.  <a href="sark_8h.html#a8e5523f51f1df77463689f9567c87884">More...</a><br /></td></tr>
<tr class="separator:a8e5523f51f1df77463689f9567c87884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7338a87d005d821ee1ef167eda592ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7338a87d005d821ee1ef167eda592ecb">sark_led_init</a> (void)</td></tr>
<tr class="memdesc:a7338a87d005d821ee1ef167eda592ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the hardware (GPIO port) which drives the LEDs attached to the SpiNNaker chip.  <a href="sark_8h.html#a7338a87d005d821ee1ef167eda592ecb">More...</a><br /></td></tr>
<tr class="separator:a7338a87d005d821ee1ef167eda592ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3a76206602b65fc8f482d0c9cce5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a74a3a76206602b65fc8f482d0c9cce5d">sark_led_set</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> leds)</td></tr>
<tr class="memdesc:a74a3a76206602b65fc8f482d0c9cce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls one or more of the LEDs attached to the SpiNNaker chip.  <a href="sark_8h.html#a74a3a76206602b65fc8f482d0c9cce5d">More...</a><br /></td></tr>
<tr class="separator:a74a3a76206602b65fc8f482d0c9cce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc00e275bcd21290b0ade7caffb3f690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afc00e275bcd21290b0ade7caffb3f690">rtr_mc_clear</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="spin1__api_8c.html#a3c1686c281a6d3ab409c4684891399cd">start</a>, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count)</td></tr>
<tr class="memdesc:afc00e275bcd21290b0ade7caffb3f690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a set of the router's multicast (MC) table registers so that routing is disabled.  <a href="sark_8h.html#afc00e275bcd21290b0ade7caffb3f690">More...</a><br /></td></tr>
<tr class="separator:afc00e275bcd21290b0ade7caffb3f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151645129faec74d427f2961d4ab9449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a151645129faec74d427f2961d4ab9449">rtr_mc_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="spin1__api_8c.html#a3c1686c281a6d3ab409c4684891399cd">start</a>)</td></tr>
<tr class="memdesc:a151645129faec74d427f2961d4ab9449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the router's multicast (MC) tables and sets up the data structures for allocating router entries.  <a href="sark_8h.html#a151645129faec74d427f2961d4ab9449">More...</a><br /></td></tr>
<tr class="separator:a151645129faec74d427f2961d4ab9449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba7cd3d8b44e6225eec84c46d20a441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3ba7cd3d8b44e6225eec84c46d20a441">rtr_mc_load</a> (<a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a> *e, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> offset, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:a3ba7cd3d8b44e6225eec84c46d20a441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load router MC table from a table in memory.  <a href="sark_8h.html#a3ba7cd3d8b44e6225eec84c46d20a441">More...</a><br /></td></tr>
<tr class="separator:a3ba7cd3d8b44e6225eec84c46d20a441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ca61e30076d1724a68027b63f6e970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a81ca61e30076d1724a68027b63f6e970">rtr_mc_set</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mask, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> route)</td></tr>
<tr class="memdesc:a81ca61e30076d1724a68027b63f6e970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a given entry in the router MC table.  <a href="sark_8h.html#a81ca61e30076d1724a68027b63f6e970">More...</a><br /></td></tr>
<tr class="separator:a81ca61e30076d1724a68027b63f6e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe404b27b699071843bb9fbe10a5325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#acfe404b27b699071843bb9fbe10a5325">rtr_mc_get</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry, <a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a> *r)</td></tr>
<tr class="memdesc:acfe404b27b699071843bb9fbe10a5325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a given entry in the router MC table.  <a href="sark_8h.html#acfe404b27b699071843bb9fbe10a5325">More...</a><br /></td></tr>
<tr class="separator:acfe404b27b699071843bb9fbe10a5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b1b5e0a5526750b671ebe436da92f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a71b1b5e0a5526750b671ebe436da92f3">rtr_fr_set</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> route)</td></tr>
<tr class="memdesc:a71b1b5e0a5526750b671ebe436da92f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fixed-route register in the router.  <a href="sark_8h.html#a71b1b5e0a5526750b671ebe436da92f3">More...</a><br /></td></tr>
<tr class="separator:a71b1b5e0a5526750b671ebe436da92f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c4fc234cb78333321bc0acf3b7b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ab87c4fc234cb78333321bc0acf3b7b75">rtr_fr_get</a> (void)</td></tr>
<tr class="memdesc:ab87c4fc234cb78333321bc0acf3b7b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fixed-route register from the router and masks off the top 8 bits.  <a href="sark_8h.html#ab87c4fc234cb78333321bc0acf3b7b75">More...</a><br /></td></tr>
<tr class="separator:ab87c4fc234cb78333321bc0acf3b7b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab37d7c02d8246d2b0fdc7670ce5fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a74ab37d7c02d8246d2b0fdc7670ce5fa">rtr_p2p_init</a> (void)</td></tr>
<tr class="memdesc:a74ab37d7c02d8246d2b0fdc7670ce5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the router point-to-point (P2P) table.  <a href="sark_8h.html#a74ab37d7c02d8246d2b0fdc7670ce5fa">More...</a><br /></td></tr>
<tr class="separator:a74ab37d7c02d8246d2b0fdc7670ce5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ab52595bb1286fe7428cad3f2670d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a42ab52595bb1286fe7428cad3f2670d9">rtr_p2p_set</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> value)</td></tr>
<tr class="memdesc:a42ab52595bb1286fe7428cad3f2670d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a P2P table entry.  <a href="sark_8h.html#a42ab52595bb1286fe7428cad3f2670d9">More...</a><br /></td></tr>
<tr class="separator:a42ab52595bb1286fe7428cad3f2670d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c60a896bbc207a45724881f051e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae43c60a896bbc207a45724881f051e6a">rtr_p2p_get</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry)</td></tr>
<tr class="memdesc:ae43c60a896bbc207a45724881f051e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a P2P table entry.  <a href="sark_8h.html#ae43c60a896bbc207a45724881f051e6a">More...</a><br /></td></tr>
<tr class="separator:ae43c60a896bbc207a45724881f051e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a25c25939b98a0966b1248a52f06f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4a25c25939b98a0966b1248a52f06f27">rtr_diag_init</a> (const <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *table)</td></tr>
<tr class="memdesc:a4a25c25939b98a0966b1248a52f06f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the 16 diagnostic registers in the router using the supplied table (which should have 16 entries).  <a href="sark_8h.html#a4a25c25939b98a0966b1248a52f06f27">More...</a><br /></td></tr>
<tr class="separator:a4a25c25939b98a0966b1248a52f06f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2550bb97884d308a9cccd5f4791e6de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a2550bb97884d308a9cccd5f4791e6de8">rtr_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> monitor)</td></tr>
<tr class="memdesc:a2550bb97884d308a9cccd5f4791e6de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a full initialisation of the router.  <a href="sark_8h.html#a2550bb97884d308a9cccd5f4791e6de8">More...</a><br /></td></tr>
<tr class="separator:a2550bb97884d308a9cccd5f4791e6de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c92abd55df0daf0b4b05284277c8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a28c92abd55df0daf0b4b05284277c8b8">v2p_mask</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> virt_mask)</td></tr>
<tr class="memdesc:a28c92abd55df0daf0b4b05284277c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bit mask of virtual core IDs, returns a mask of the corresponding physical core IDs.  <a href="sark_8h.html#a28c92abd55df0daf0b4b05284277c8b8">More...</a><br /></td></tr>
<tr class="separator:a28c92abd55df0daf0b4b05284277c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfda3e690ab2344e88f6e8934e2edd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5bfda3e690ab2344e88f6e8934e2edd4">pl340_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mem_clk)</td></tr>
<tr class="memdesc:a5bfda3e690ab2344e88f6e8934e2edd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the PL340 memory controller.  <a href="sark_8h.html#a5bfda3e690ab2344e88f6e8934e2edd4">More...</a><br /></td></tr>
<tr class="separator:a5bfda3e690ab2344e88f6e8934e2edd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ace566279f8f98e6bf001dee74eeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a06ace566279f8f98e6bf001dee74eeab">event_alloc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> events)</td></tr>
<tr class="memdesc:a06ace566279f8f98e6bf001dee74eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create additional free events by calling <a class="el" href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a>.  <a href="sark_8h.html#a06ace566279f8f98e6bf001dee74eeab">More...</a><br /></td></tr>
<tr class="separator:a06ace566279f8f98e6bf001dee74eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a1933cd3173bcfe01e10150532b933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a05a1933cd3173bcfe01e10150532b933">event_free</a> (<a class="el" href="sark_8h.html#structevent__t">event_t</a> *e)</td></tr>
<tr class="memdesc:a05a1933cd3173bcfe01e10150532b933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously allocated event.  <a href="sark_8h.html#a05a1933cd3173bcfe01e10150532b933">More...</a><br /></td></tr>
<tr class="separator:a05a1933cd3173bcfe01e10150532b933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc841f217092d14cd043929c4ef5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ac3dc841f217092d14cd043929c4ef5a0">event_new</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg1, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2)</td></tr>
<tr class="memdesc:ac3dc841f217092d14cd043929c4ef5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new event from the free queue and intialise "proc", "arg1" and "arg2" fields.  <a href="sark_8h.html#ac3dc841f217092d14cd043929c4ef5a0">More...</a><br /></td></tr>
<tr class="separator:ac3dc841f217092d14cd043929c4ef5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d6272010636e23c96102c17baa13b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a28d6272010636e23c96102c17baa13b6">event_config</a> (<a class="el" href="sark_8h.html#structevent__t">event_t</a> *<a class="el" href="sark__event_8c.html#ae7a7108766201ba6bd821b143da63f09">event</a>, <a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg1, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2)</td></tr>
<tr class="memdesc:a28d6272010636e23c96102c17baa13b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a (reusable) event that has already been allocated.  <a href="sark_8h.html#a28d6272010636e23c96102c17baa13b6">More...</a><br /></td></tr>
<tr class="separator:a28d6272010636e23c96102c17baa13b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5950f6444f3c7afd3e6cdefec311a19d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5950f6444f3c7afd3e6cdefec311a19d">pkt_tx_k</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key)</td></tr>
<tr class="memdesc:a5950f6444f3c7afd3e6cdefec311a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a packet which contains only a key.  <a href="sark_8h.html#a5950f6444f3c7afd3e6cdefec311a19d">More...</a><br /></td></tr>
<tr class="separator:a5950f6444f3c7afd3e6cdefec311a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c544176d5d81edfa1485b5ae2e0d20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a5c544176d5d81edfa1485b5ae2e0d20f">pkt_tx_kd</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> data)</td></tr>
<tr class="memdesc:a5c544176d5d81edfa1485b5ae2e0d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a packet which contains key and data fields.  <a href="sark_8h.html#a5c544176d5d81edfa1485b5ae2e0d20f">More...</a><br /></td></tr>
<tr class="separator:a5c544176d5d81edfa1485b5ae2e0d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bace2238c993312c518553cdb237743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0bace2238c993312c518553cdb237743">pkt_tx_kc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ctrl)</td></tr>
<tr class="memdesc:a0bace2238c993312c518553cdb237743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a packet which contains key and control byte (cb) fields.  <a href="sark_8h.html#a0bace2238c993312c518553cdb237743">More...</a><br /></td></tr>
<tr class="separator:a0bace2238c993312c518553cdb237743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5737fbb29e2f0f47e0375e4cba4162d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa5737fbb29e2f0f47e0375e4cba4162d">pkt_tx_kdc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> data, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ctrl)</td></tr>
<tr class="memdesc:aa5737fbb29e2f0f47e0375e4cba4162d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a packet which contains key, data and control byte (cb) fields.  <a href="sark_8h.html#aa5737fbb29e2f0f47e0375e4cba4162d">More...</a><br /></td></tr>
<tr class="separator:aa5737fbb29e2f0f47e0375e4cba4162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa72805def2820951b0e8f1967d518fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afa72805def2820951b0e8f1967d518fd">event_start</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> period, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> events, <a class="el" href="sark_8h.html#a324329d30936f98474493194a7e07847">sync_bool</a> wait)</td></tr>
<tr class="memdesc:afa72805def2820951b0e8f1967d518fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start event processing.  <a href="sark_8h.html#afa72805def2820951b0e8f1967d518fd">More...</a><br /></td></tr>
<tr class="separator:afa72805def2820951b0e8f1967d518fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e02c560e39a7afafbb5da4255906f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a65e02c560e39a7afafbb5da4255906f4">event_pause</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pause)</td></tr>
<tr class="memdesc:a65e02c560e39a7afafbb5da4255906f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to stop (pause) event processing or resume it again.  <a href="sark_8h.html#a65e02c560e39a7afafbb5da4255906f4">More...</a><br /></td></tr>
<tr class="separator:a65e02c560e39a7afafbb5da4255906f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b364e4b7263b9e979f4f5d02369fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a05b364e4b7263b9e979f4f5d02369fa3">event_stop</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rc)</td></tr>
<tr class="memdesc:a05b364e4b7263b9e979f4f5d02369fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to stop event processing.  <a href="sark_8h.html#a05b364e4b7263b9e979f4f5d02369fa3">More...</a><br /></td></tr>
<tr class="separator:a05b364e4b7263b9e979f4f5d02369fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d885d4db63c2de6f5982e74e86cb84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8d885d4db63c2de6f5982e74e86cb84f">event_wait</a> (void)</td></tr>
<tr class="memdesc:a8d885d4db63c2de6f5982e74e86cb84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a signal from the monitor processor (i.e., host) before proceeding. Can be used to implement barrier waits.  <a href="sark_8h.html#a8d885d4db63c2de6f5982e74e86cb84f">More...</a><br /></td></tr>
<tr class="separator:a8d885d4db63c2de6f5982e74e86cb84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607f8bbe9eb8a7d99a4a335be0673b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a607f8bbe9eb8a7d99a4a335be0673b09">event_queue</a> (<a class="el" href="sark_8h.html#structevent__t">event_t</a> *e, <a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a> priority)</td></tr>
<tr class="memdesc:a607f8bbe9eb8a7d99a4a335be0673b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an event on an event queue for execution at a later time.  <a href="sark_8h.html#a607f8bbe9eb8a7d99a4a335be0673b09">More...</a><br /></td></tr>
<tr class="separator:a607f8bbe9eb8a7d99a4a335be0673b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99da351948b0933e1a8f46db6d9b5f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a99da351948b0933e1a8f46db6d9b5f7d">event_queue_proc</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg1, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2, <a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a> priority)</td></tr>
<tr class="memdesc:a99da351948b0933e1a8f46db6d9b5f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new event and places it on an event queue for execution at a later time.  <a href="sark_8h.html#a99da351948b0933e1a8f46db6d9b5f7d">More...</a><br /></td></tr>
<tr class="separator:a99da351948b0933e1a8f46db6d9b5f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c997d47394c965abda9a03d8db70ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6c997d47394c965abda9a03d8db70ae6">event_run</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> restart)</td></tr>
<tr class="memdesc:a6c997d47394c965abda9a03d8db70ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the event queue until it is empty.  <a href="sark_8h.html#a6c997d47394c965abda9a03d8db70ae6">More...</a><br /></td></tr>
<tr class="separator:a6c997d47394c965abda9a03d8db70ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a64a46470fbaa6bf1a129eae284a25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a59a64a46470fbaa6bf1a129eae284a25">event_register_int</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a> <a class="el" href="sark__event_8c.html#ae7a7108766201ba6bd821b143da63f09">event</a>, <a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a> slot)</td></tr>
<tr class="memdesc:a59a64a46470fbaa6bf1a129eae284a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event_proc to be called when a particular event occurs and associate that with an IRQ or FIQ interrupt.  <a href="sark_8h.html#a59a64a46470fbaa6bf1a129eae284a25">More...</a><br /></td></tr>
<tr class="separator:a59a64a46470fbaa6bf1a129eae284a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdc191f66af37a6b0972dca4b80159f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#abcdc191f66af37a6b0972dca4b80159f">event_register_queue</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a> <a class="el" href="sark__event_8c.html#ae7a7108766201ba6bd821b143da63f09">event</a>, <a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a> slot, <a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a> priority)</td></tr>
<tr class="memdesc:abcdc191f66af37a6b0972dca4b80159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event_proc to be placed on an event queue when a particular event occurs and associate that with an IRQ interrupt.  <a href="sark_8h.html#abcdc191f66af37a6b0972dca4b80159f">More...</a><br /></td></tr>
<tr class="separator:abcdc191f66af37a6b0972dca4b80159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35de6a8f9072dc49db8984bd7ce135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a6c35de6a8f9072dc49db8984bd7ce135">event_register_pause</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2)</td></tr>
<tr class="memdesc:a6c35de6a8f9072dc49db8984bd7ce135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event_proc to be called when event processing is paused.  <a href="sark_8h.html#a6c35de6a8f9072dc49db8984bd7ce135">More...</a><br /></td></tr>
<tr class="separator:a6c35de6a8f9072dc49db8984bd7ce135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc420e5045a73751d480bf2edfb15e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#afc420e5045a73751d480bf2edfb15e72">event_enable</a> (<a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a> event_num, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> enable)</td></tr>
<tr class="memdesc:afc420e5045a73751d480bf2edfb15e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable an event.  <a href="sark_8h.html#afc420e5045a73751d480bf2edfb15e72">More...</a><br /></td></tr>
<tr class="separator:afc420e5045a73751d480bf2edfb15e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24995141a580df346fce85a38cbec1b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a24995141a580df346fce85a38cbec1b8">event_register_timer</a> (<a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a> slot)</td></tr>
<tr class="memdesc:a24995141a580df346fce85a38cbec1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the use of the second timer on the core so that it can be used to provide delayed events via <a class="el" href="sark_8h.html#a472cfc21a621f8e5153f1191342c5bc1" title="Schedule an event to occur at some time in the future.">timer_schedule()</a>.  <a href="sark_8h.html#a24995141a580df346fce85a38cbec1b8">More...</a><br /></td></tr>
<tr class="separator:a24995141a580df346fce85a38cbec1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4175f7e6597dd3d01fff5b4afa13ea58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4175f7e6597dd3d01fff5b4afa13ea58">event_register_pkt</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> queue_size, <a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a> slot)</td></tr>
<tr class="memdesc:a4175f7e6597dd3d01fff5b4afa13ea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the use of "pkt" routines.  <a href="sark_8h.html#a4175f7e6597dd3d01fff5b4afa13ea58">More...</a><br /></td></tr>
<tr class="separator:a4175f7e6597dd3d01fff5b4afa13ea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0354578d007f0031b66bb376939aee54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0354578d007f0031b66bb376939aee54">event_user</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg1, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2)</td></tr>
<tr class="memdesc:a0354578d007f0031b66bb376939aee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to trigger a user event if one has been registered.  <a href="sark_8h.html#a0354578d007f0031b66bb376939aee54">More...</a><br /></td></tr>
<tr class="separator:a0354578d007f0031b66bb376939aee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472cfc21a621f8e5153f1191342c5bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a472cfc21a621f8e5153f1191342c5bc1">timer_schedule</a> (<a class="el" href="sark_8h.html#structevent__t">event_t</a> *e, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> time)</td></tr>
<tr class="memdesc:a472cfc21a621f8e5153f1191342c5bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an event to occur at some time in the future.  <a href="sark_8h.html#a472cfc21a621f8e5153f1191342c5bc1">More...</a><br /></td></tr>
<tr class="separator:a472cfc21a621f8e5153f1191342c5bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4e6e587060d426aa55638664f1e3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aab4e6e587060d426aa55638664f1e3b6">timer_schedule_proc</a> (<a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a> proc, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg1, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> arg2, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> time)</td></tr>
<tr class="memdesc:aab4e6e587060d426aa55638664f1e3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an event, initialises it with the supplied parameters and schedules it to occur at some time in the future.  <a href="sark_8h.html#aab4e6e587060d426aa55638664f1e3b6">More...</a><br /></td></tr>
<tr class="separator:aab4e6e587060d426aa55638664f1e3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd1585a3489d9ee70bf5805214fe7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aacd1585a3489d9ee70bf5805214fe7f2">timer_cancel</a> (<a class="el" href="sark_8h.html#structevent__t">event_t</a> *e, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ID)</td></tr>
<tr class="memdesc:aacd1585a3489d9ee70bf5805214fe7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a timer event that was previously scheduled.  <a href="sark_8h.html#aacd1585a3489d9ee70bf5805214fe7f2">More...</a><br /></td></tr>
<tr class="separator:aacd1585a3489d9ee70bf5805214fe7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494d1ae311642ab308b728ecfe310342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a494d1ae311642ab308b728ecfe310342">timer_cancel_init</a> (void)</td></tr>
<tr class="memdesc:a494d1ae311642ab308b728ecfe310342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a statically allocated event to be used in place of an event that is cancelled at the head of the timer queue.  <a href="sark_8h.html#a494d1ae311642ab308b728ecfe310342">More...</a><br /></td></tr>
<tr class="separator:a494d1ae311642ab308b728ecfe310342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1b3637d14687e77df4a7146100b306b0"><td class="memItemLeft" align="right" valign="top"><a id="a1b3637d14687e77df4a7146100b306b0"></a>
static <a class="el" href="sark_8h.html#structsark__vec__t">sark_vec_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a1b3637d14687e77df4a7146100b306b0">sark_vec</a> = (<a class="el" href="sark_8h.html#structsark__vec__t">sark_vec_t</a> *) 0x20</td></tr>
<tr class="memdesc:a1b3637d14687e77df4a7146100b306b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to sark_vec at 0x20. <br /></td></tr>
<tr class="separator:a1b3637d14687e77df4a7146100b306b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aedee21d244fb4bf7613609168c7b4"><td class="memItemLeft" align="right" valign="top"><a id="a89aedee21d244fb4bf7613609168c7b4"></a>
<a class="el" href="sark_8h.html#structsark__data__t">sark_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a89aedee21d244fb4bf7613609168c7b4">sark</a></td></tr>
<tr class="memdesc:a89aedee21d244fb4bf7613609168c7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main SARK variables. <br /></td></tr>
<tr class="separator:a89aedee21d244fb4bf7613609168c7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a7108766201ba6bd821b143da63f09"><td class="memItemLeft" align="right" valign="top"><a id="ae7a7108766201ba6bd821b143da63f09"></a>
<a class="el" href="sark_8h.html#structevent__data__t">event_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae7a7108766201ba6bd821b143da63f09">event</a></td></tr>
<tr class="memdesc:ae7a7108766201ba6bd821b143da63f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">SARK event variables. <br /></td></tr>
<tr class="separator:ae7a7108766201ba6bd821b143da63f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f996c4cec2bbd8ef1c1bc86abdd2c35"><td class="memItemLeft" align="right" valign="top"><a id="a4f996c4cec2bbd8ef1c1bc86abdd2c35"></a>
<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4f996c4cec2bbd8ef1c1bc86abdd2c35">build_date</a></td></tr>
<tr class="memdesc:a4f996c4cec2bbd8ef1c1bc86abdd2c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date of build. <br /></td></tr>
<tr class="separator:a4f996c4cec2bbd8ef1c1bc86abdd2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b98e25983f8eb56e33e563b250b6c"><td class="memItemLeft" align="right" valign="top"><a id="a691b98e25983f8eb56e33e563b250b6c"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a691b98e25983f8eb56e33e563b250b6c">build_name</a> []</td></tr>
<tr class="memdesc:a691b98e25983f8eb56e33e563b250b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of build. <br /></td></tr>
<tr class="separator:a691b98e25983f8eb56e33e563b250b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">System RAM definitions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2b160b6326eadad1e023b494882ffb76"></a></p><div class="fragment"><div class="line"><a class="code" href="spinnaker_8h.html#ae91b1725f67078b99e68cc3508d7f2e6">SYSRAM_TOP</a>  +-------------------------------+   f5008000</div>
<div class="line">            | 256 bytes                     |</div>
<div class="line"><a class="code" href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026">SV_SV</a>       +-------------------------------+   f5007f00</div>
<div class="line">            | 32 bytes                      |</div>
<div class="line"><a class="code" href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a>  +-------------------------------+   f5007ee0</div>
<div class="line">            | 64 bytes                      |</div>
<div class="line"><a class="code" href="sark_8h.html#a4ea54a1b50b0f5d74df91b604006bca9">SV_RANDOM</a>   +-------------------------------+   f5007ea0</div>
<div class="line">            | 1440 bytes                    |</div>
<div class="line"><a class="code" href="sark_8h.html#a41cd20bd99299a9ba4fbcc09768fb83e">SV_SPARE</a>    +-------------------------------+   f5007900</div>
<div class="line">            | <a class="code" href="spinnaker_8h.html#aa061b51fb2d77d7721a3882edf5cd84a">NUM_CPUS</a> * <a class="code" href="sark_8h.html#a6060b669d3bbd8528c906953d482b12e">VCPU_SIZE</a>          |</div>
<div class="line"><a class="code" href="sark_8h.html#a06e96a522d4adf97fbb2549806f73cfb">SV_VCPU</a>     +-------------------------------+   f5007000 <a class="code" href="sark_8h.html#a74ab0d3b2aa00fa87c323a46349fe3b9">sv</a>-&gt;sysram_top</div>
<div class="line">            |                               |</div>
<div class="line">            ~ <span class="stringliteral">&quot;User&quot;</span> SysRAM                 ~</div>
<div class="line">            |                               |</div>
<div class="line">            +-------------------------------+   f5000100 <a class="code" href="sark_8h.html#a74ab0d3b2aa00fa87c323a46349fe3b9">sv</a>-&gt;<a class="code" href="sark_8h.html#af6843a2eb98fe1699ffd4845a24ff359">sysram_base</a></div>
<div class="line">            | 256 bytes                     |</div>
<div class="line"><a class="code" href="spinnaker_8h.html#a2292f2ea539bb564b691a1a708447edf">SYSRAM_BASE</a> +-------------------------------+   f5000000</div>
<div class="ttc" id="asark_8h_html_a06e96a522d4adf97fbb2549806f73cfb"><div class="ttname"><a href="sark_8h.html#a06e96a522d4adf97fbb2549806f73cfb">SV_VCPU</a></div><div class="ttdeci">#define SV_VCPU</div><div class="ttdoc">e5007000</div><div class="ttdef"><b>Definition:</b> sark.h:939</div></div>
<div class="ttc" id="asark_8h_html_a41cd20bd99299a9ba4fbcc09768fb83e"><div class="ttname"><a href="sark_8h.html#a41cd20bd99299a9ba4fbcc09768fb83e">SV_SPARE</a></div><div class="ttdeci">#define SV_SPARE</div><div class="ttdoc">e5007900</div><div class="ttdef"><b>Definition:</b> sark.h:940</div></div>
<div class="ttc" id="asark_8h_html_a4ea54a1b50b0f5d74df91b604006bca9"><div class="ttname"><a href="sark_8h.html#a4ea54a1b50b0f5d74df91b604006bca9">SV_RANDOM</a></div><div class="ttdeci">#define SV_RANDOM</div><div class="ttdoc">e5007ea0</div><div class="ttdef"><b>Definition:</b> sark.h:937</div></div>
<div class="ttc" id="asark_8h_html_a6060b669d3bbd8528c906953d482b12e"><div class="ttname"><a href="sark_8h.html#a6060b669d3bbd8528c906953d482b12e">VCPU_SIZE</a></div><div class="ttdeci">#define VCPU_SIZE</div><div class="ttdoc">Size of vcpu_t.</div><div class="ttdef"><b>Definition:</b> sark.h:750</div></div>
<div class="ttc" id="asark_8h_html_a74ab0d3b2aa00fa87c323a46349fe3b9"><div class="ttname"><a href="sark_8h.html#a74ab0d3b2aa00fa87c323a46349fe3b9">sv</a></div><div class="ttdeci">static sv_t *const sv</div><div class="ttdef"><b>Definition:</b> sark.h:1070</div></div>
<div class="ttc" id="asark_8h_html_a993ec852f04f051ca86338808f053b93"><div class="ttname"><a href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a></div><div class="ttdeci">#define SV_VECTORS</div><div class="ttdoc">e5007ee0</div><div class="ttdef"><b>Definition:</b> sark.h:936</div></div>
<div class="ttc" id="asark_8h_html_ae64acf62910ab7afdbbe57fbd92e3026"><div class="ttname"><a href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026">SV_SV</a></div><div class="ttdeci">#define SV_SV</div><div class="ttdoc">e5007f00</div><div class="ttdef"><b>Definition:</b> sark.h:930</div></div>
<div class="ttc" id="asark_8h_html_af6843a2eb98fe1699ffd4845a24ff359"><div class="ttname"><a href="sark_8h.html#af6843a2eb98fe1699ffd4845a24ff359">sv_t::sysram_base</a></div><div class="ttdeci">uint * sysram_base</div><div class="ttdoc">c4 Base of user SysRAM</div><div class="ttdef"><b>Definition:</b> sark.h:1043</div></div>
<div class="ttc" id="aspinnaker_8h_html_a2292f2ea539bb564b691a1a708447edf"><div class="ttname"><a href="spinnaker_8h.html#a2292f2ea539bb564b691a1a708447edf">SYSRAM_BASE</a></div><div class="ttdeci">#define SYSRAM_BASE</div><div class="ttdoc">Base address of System RAM.</div><div class="ttdef"><b>Definition:</b> spinnaker.h:113</div></div>
<div class="ttc" id="aspinnaker_8h_html_aa061b51fb2d77d7721a3882edf5cd84a"><div class="ttname"><a href="spinnaker_8h.html#aa061b51fb2d77d7721a3882edf5cd84a">NUM_CPUS</a></div><div class="ttdeci">#define NUM_CPUS</div><div class="ttdoc">Number of CPU cores per chip.</div><div class="ttdef"><b>Definition:</b> spinnaker.h:65</div></div>
<div class="ttc" id="aspinnaker_8h_html_ae91b1725f67078b99e68cc3508d7f2e6"><div class="ttname"><a href="spinnaker_8h.html#ae91b1725f67078b99e68cc3508d7f2e6">SYSRAM_TOP</a></div><div class="ttdeci">#define SYSRAM_TOP</div><div class="ttdoc">Top address of System RAM.</div><div class="ttdef"><b>Definition:</b> spinnaker.h:121</div></div>
</div><!-- fragment --> </td></tr>
<tr class="memitem:adfd6c958be86add71bdb7f3e52a4f385"><td class="memItemLeft" align="right" valign="top"><a id="adfd6c958be86add71bdb7f3e52a4f385"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#adfd6c958be86add71bdb7f3e52a4f385">SV_SSIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:adfd6c958be86add71bdb7f3e52a4f385"><td class="mdescLeft">&#160;</td><td class="mdescRight">SROM data size. <br /></td></tr>
<tr class="separator:adfd6c958be86add71bdb7f3e52a4f385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa947c493823d4dfffbfcde71ef599ee7"><td class="memItemLeft" align="right" valign="top"><a id="aa947c493823d4dfffbfcde71ef599ee7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa947c493823d4dfffbfcde71ef599ee7">SV_USIZE</a>&#160;&#160;&#160;96</td></tr>
<tr class="memdesc:aa947c493823d4dfffbfcde71ef599ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialised size. <br /></td></tr>
<tr class="separator:aa947c493823d4dfffbfcde71ef599ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9f7f4562d47d4e3976c53557d28cbf"><td class="memItemLeft" align="right" valign="top"><a id="a3a9f7f4562d47d4e3976c53557d28cbf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3a9f7f4562d47d4e3976c53557d28cbf">SV_ISIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a3a9f7f4562d47d4e3976c53557d28cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised to 0. <br /></td></tr>
<tr class="separator:a3a9f7f4562d47d4e3976c53557d28cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81947df8a77e0baa70a86fe19757d40"><td class="memItemLeft" align="right" valign="top"><a id="af81947df8a77e0baa70a86fe19757d40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af81947df8a77e0baa70a86fe19757d40">SV_VSIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:af81947df8a77e0baa70a86fe19757d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset vectors. <br /></td></tr>
<tr class="separator:af81947df8a77e0baa70a86fe19757d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88d62a610a50e46910769547b25fa37"><td class="memItemLeft" align="right" valign="top"><a id="aa88d62a610a50e46910769547b25fa37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aa88d62a610a50e46910769547b25fa37">SV_RSIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:aa88d62a610a50e46910769547b25fa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random in SysRAM. <br /></td></tr>
<tr class="separator:aa88d62a610a50e46910769547b25fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940f17eb2b3513af4d939c84ece4701"><td class="memItemLeft" align="right" valign="top"><a id="a4940f17eb2b3513af4d939c84ece4701"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4940f17eb2b3513af4d939c84ece4701">SV_SIZE</a>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:a4940f17eb2b3513af4d939c84ece4701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Everything fits in this! <br /></td></tr>
<tr class="separator:a4940f17eb2b3513af4d939c84ece4701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad628bb4c6156bcfeb5b4237811808672"><td class="memItemLeft" align="right" valign="top"><a id="ad628bb4c6156bcfeb5b4237811808672"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad628bb4c6156bcfeb5b4237811808672">SV_SROM</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#ae91b1725f67078b99e68cc3508d7f2e6">SYSRAM_TOP</a> - <a class="el" href="sark_8h.html#adfd6c958be86add71bdb7f3e52a4f385">SV_SSIZE</a>)</td></tr>
<tr class="memdesc:ad628bb4c6156bcfeb5b4237811808672"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007fe0 <br /></td></tr>
<tr class="separator:ad628bb4c6156bcfeb5b4237811808672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0519e7df1550cf253b850bc32830527"><td class="memItemLeft" align="right" valign="top"><a id="af0519e7df1550cf253b850bc32830527"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af0519e7df1550cf253b850bc32830527">SV_UBASE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#ad628bb4c6156bcfeb5b4237811808672">SV_SROM</a> - <a class="el" href="sark_8h.html#aa947c493823d4dfffbfcde71ef599ee7">SV_USIZE</a>)</td></tr>
<tr class="memdesc:af0519e7df1550cf253b850bc32830527"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007f80 <br /></td></tr>
<tr class="separator:af0519e7df1550cf253b850bc32830527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea922b58cbe7b48956fb9de1a903fa1"><td class="memItemLeft" align="right" valign="top"><a id="acea922b58cbe7b48956fb9de1a903fa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#acea922b58cbe7b48956fb9de1a903fa1">SV_IBASE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#af0519e7df1550cf253b850bc32830527">SV_UBASE</a> - <a class="el" href="sark_8h.html#a3a9f7f4562d47d4e3976c53557d28cbf">SV_ISIZE</a>)</td></tr>
<tr class="memdesc:acea922b58cbe7b48956fb9de1a903fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007f00 <br /></td></tr>
<tr class="separator:acea922b58cbe7b48956fb9de1a903fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64acf62910ab7afdbbe57fbd92e3026"><td class="memItemLeft" align="right" valign="top"><a id="ae64acf62910ab7afdbbe57fbd92e3026"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026">SV_SV</a>&#160;&#160;&#160;<a class="el" href="sark_8h.html#acea922b58cbe7b48956fb9de1a903fa1">SV_IBASE</a></td></tr>
<tr class="memdesc:ae64acf62910ab7afdbbe57fbd92e3026"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007f00 <br /></td></tr>
<tr class="separator:ae64acf62910ab7afdbbe57fbd92e3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3aec779e29c69df8ce62a2630709316"><td class="memItemLeft" align="right" valign="top"><a id="ae3aec779e29c69df8ce62a2630709316"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ae3aec779e29c69df8ce62a2630709316">SYS_BOOT</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ae3aec779e29c69df8ce62a2630709316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot space size. <br /></td></tr>
<tr class="separator:ae3aec779e29c69df8ce62a2630709316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fc081289f30cbfe7ced12a71d13aea"><td class="memItemLeft" align="right" valign="top"><a id="ad9fc081289f30cbfe7ced12a71d13aea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad9fc081289f30cbfe7ced12a71d13aea">SYS_USER_TOP</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#ae91b1725f67078b99e68cc3508d7f2e6">SYSRAM_TOP</a> - <a class="el" href="sark_8h.html#a4940f17eb2b3513af4d939c84ece4701">SV_SIZE</a>)</td></tr>
<tr class="memdesc:ad9fc081289f30cbfe7ced12a71d13aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007000 (sysram_top) <br /></td></tr>
<tr class="separator:ad9fc081289f30cbfe7ced12a71d13aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ffbe52e900e6efd670af0e0351979"><td class="memItemLeft" align="right" valign="top"><a id="ada0ffbe52e900e6efd670af0e0351979"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ada0ffbe52e900e6efd670af0e0351979">SYS_USER_BASE</a>&#160;&#160;&#160;(<a class="el" href="spinnaker_8h.html#a2292f2ea539bb564b691a1a708447edf">SYSRAM_BASE</a> + <a class="el" href="sark_8h.html#ae3aec779e29c69df8ce62a2630709316">SYS_BOOT</a>)</td></tr>
<tr class="memdesc:ada0ffbe52e900e6efd670af0e0351979"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5000100 (sysram_base) <br /></td></tr>
<tr class="separator:ada0ffbe52e900e6efd670af0e0351979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993ec852f04f051ca86338808f053b93"><td class="memItemLeft" align="right" valign="top"><a id="a993ec852f04f051ca86338808f053b93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#acea922b58cbe7b48956fb9de1a903fa1">SV_IBASE</a> - <a class="el" href="sark_8h.html#af81947df8a77e0baa70a86fe19757d40">SV_VSIZE</a>)</td></tr>
<tr class="memdesc:a993ec852f04f051ca86338808f053b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007ee0 <br /></td></tr>
<tr class="separator:a993ec852f04f051ca86338808f053b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea54a1b50b0f5d74df91b604006bca9"><td class="memItemLeft" align="right" valign="top"><a id="a4ea54a1b50b0f5d74df91b604006bca9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4ea54a1b50b0f5d74df91b604006bca9">SV_RANDOM</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a> - <a class="el" href="sark_8h.html#aa88d62a610a50e46910769547b25fa37">SV_RSIZE</a>)</td></tr>
<tr class="memdesc:a4ea54a1b50b0f5d74df91b604006bca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007ea0 <br /></td></tr>
<tr class="separator:a4ea54a1b50b0f5d74df91b604006bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e96a522d4adf97fbb2549806f73cfb"><td class="memItemLeft" align="right" valign="top"><a id="a06e96a522d4adf97fbb2549806f73cfb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a06e96a522d4adf97fbb2549806f73cfb">SV_VCPU</a>&#160;&#160;&#160;<a class="el" href="sark_8h.html#ad9fc081289f30cbfe7ced12a71d13aea">SYS_USER_TOP</a></td></tr>
<tr class="memdesc:a06e96a522d4adf97fbb2549806f73cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007000 <br /></td></tr>
<tr class="separator:a06e96a522d4adf97fbb2549806f73cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd20bd99299a9ba4fbcc09768fb83e"><td class="memItemLeft" align="right" valign="top"><a id="a41cd20bd99299a9ba4fbcc09768fb83e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a41cd20bd99299a9ba4fbcc09768fb83e">SV_SPARE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#a06e96a522d4adf97fbb2549806f73cfb">SV_VCPU</a> + <a class="el" href="spinnaker_8h.html#aa061b51fb2d77d7721a3882edf5cd84a">NUM_CPUS</a> * <a class="el" href="sark_8h.html#a6060b669d3bbd8528c906953d482b12e">VCPU_SIZE</a>)</td></tr>
<tr class="memdesc:a41cd20bd99299a9ba4fbcc09768fb83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007900 <br /></td></tr>
<tr class="separator:a41cd20bd99299a9ba4fbcc09768fb83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0140dd12f36d8942f005aab7c7f73f38"><td class="memItemLeft" align="right" valign="top"><a id="a0140dd12f36d8942f005aab7c7f73f38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0140dd12f36d8942f005aab7c7f73f38">SPARE_SIZE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#a4ea54a1b50b0f5d74df91b604006bca9">SV_RANDOM</a> - <a class="el" href="sark_8h.html#a41cd20bd99299a9ba4fbcc09768fb83e">SV_SPARE</a>)</td></tr>
<tr class="memdesc:a0140dd12f36d8942f005aab7c7f73f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">spare space size <br /></td></tr>
<tr class="separator:a0140dd12f36d8942f005aab7c7f73f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12328d30c230f38906d77eb722495965"><td class="memItemLeft" align="right" valign="top"><a id="a12328d30c230f38906d77eb722495965"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a12328d30c230f38906d77eb722495965">SROM_FLAG_BASE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#ad628bb4c6156bcfeb5b4237811808672">SV_SROM</a>)</td></tr>
<tr class="memdesc:a12328d30c230f38906d77eb722495965"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007fe0 <br /></td></tr>
<tr class="separator:a12328d30c230f38906d77eb722495965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12358086249cb7c260cc4e88159f04d"><td class="memItemLeft" align="right" valign="top"><a id="ad12358086249cb7c260cc4e88159f04d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ad12358086249cb7c260cc4e88159f04d">STATUS_MAP_BASE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#af0519e7df1550cf253b850bc32830527">SV_UBASE</a>)</td></tr>
<tr class="memdesc:ad12358086249cb7c260cc4e88159f04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">e5007f80 <br /></td></tr>
<tr class="separator:ad12358086249cb7c260cc4e88159f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b3fcdb179c600393eb4eeef133d0d"><td class="memItemLeft" align="right" valign="top"><a id="abe8b3fcdb179c600393eb4eeef133d0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#abe8b3fcdb179c600393eb4eeef133d0d">RST_BLOCK_BASE</a>&#160;&#160;&#160;(<a class="el" href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a>)</td></tr>
<tr class="memdesc:abe8b3fcdb179c600393eb4eeef133d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">f5007ee0 <br /></td></tr>
<tr class="separator:abe8b3fcdb179c600393eb4eeef133d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d35944bd3dd07fdd09a06b6bf4207ef"><td class="memItemLeft" align="right" valign="top"><a id="a0d35944bd3dd07fdd09a06b6bf4207ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a0d35944bd3dd07fdd09a06b6bf4207ef">SRF_PRESENT</a>&#160;&#160;&#160;0x8000</td></tr>
<tr class="memdesc:a0d35944bd3dd07fdd09a06b6bf4207ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">SROM present. <br /></td></tr>
<tr class="separator:a0d35944bd3dd07fdd09a06b6bf4207ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8713198899fda6df6178804b9f620f47"><td class="memItemLeft" align="right" valign="top"><a id="a8713198899fda6df6178804b9f620f47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a8713198899fda6df6178804b9f620f47">SRF_HW_VER</a>&#160;&#160;&#160;0x00f0</td></tr>
<tr class="memdesc:a8713198899fda6df6178804b9f620f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware version. <br /></td></tr>
<tr class="separator:a8713198899fda6df6178804b9f620f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579398e90b577981f0e6a7f36947332a"><td class="memItemLeft" align="right" valign="top"><a id="a579398e90b577981f0e6a7f36947332a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a579398e90b577981f0e6a7f36947332a">SRF_PHY_INIT</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a579398e90b577981f0e6a7f36947332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init PHY on startup. <br /></td></tr>
<tr class="separator:a579398e90b577981f0e6a7f36947332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1343248569d9c13924ab90a2e253c51"><td class="memItemLeft" align="right" valign="top"><a id="af1343248569d9c13924ab90a2e253c51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#af1343248569d9c13924ab90a2e253c51">SRF_PHY_RST</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:af1343248569d9c13924ab90a2e253c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset PHY on startup. <br /></td></tr>
<tr class="separator:af1343248569d9c13924ab90a2e253c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116430639c64d108e5a37172317be9b"><td class="memItemLeft" align="right" valign="top"><a id="a3116430639c64d108e5a37172317be9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a3116430639c64d108e5a37172317be9b">SRF_PHY_WAIT</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a3116430639c64d108e5a37172317be9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for PHY up on startup. <br /></td></tr>
<tr class="separator:a3116430639c64d108e5a37172317be9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4817bfd950164146c30dc577eb339bbe"><td class="memItemLeft" align="right" valign="top"><a id="a4817bfd950164146c30dc577eb339bbe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a4817bfd950164146c30dc577eb339bbe">SRF_ETH</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a4817bfd950164146c30dc577eb339bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ethernet present. <br /></td></tr>
<tr class="separator:a4817bfd950164146c30dc577eb339bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6962f26c59c9720644ba44488b8c1b"><td class="memItemLeft" align="right" valign="top"><a id="a9e6962f26c59c9720644ba44488b8c1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a9e6962f26c59c9720644ba44488b8c1b">SRF_NONE</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:a9e6962f26c59c9720644ba44488b8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">None of the above. <br /></td></tr>
<tr class="separator:a9e6962f26c59c9720644ba44488b8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab0d3b2aa00fa87c323a46349fe3b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sark_8h.html#structsv__t">sv_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a74ab0d3b2aa00fa87c323a46349fe3b9">sv</a> = (<a class="el" href="sark_8h.html#structsv__t">sv_t</a> *) <a class="el" href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026">SV_SV</a></td></tr>
<tr class="separator:a74ab0d3b2aa00fa87c323a46349fe3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08702c96eb539a7fbcebbc114424703"><td class="memItemLeft" align="right" valign="top"><a id="ac08702c96eb539a7fbcebbc114424703"></a>
static <a class="el" href="sark_8h.html#structvcpu__t">vcpu_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#ac08702c96eb539a7fbcebbc114424703">sv_vcpu</a> = (<a class="el" href="sark_8h.html#structvcpu__t">vcpu_t</a> *) <a class="el" href="sark_8h.html#a06e96a522d4adf97fbb2549806f73cfb">SV_VCPU</a></td></tr>
<tr class="memdesc:ac08702c96eb539a7fbcebbc114424703"><td class="mdescLeft">&#160;</td><td class="mdescRight">"sv_vcpu" points to base of array of "vcpu_t" <br /></td></tr>
<tr class="separator:ac08702c96eb539a7fbcebbc114424703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ac0115eb99b77dc347bd62b6bf30a"><td class="memItemLeft" align="right" valign="top"><a id="a7e9ac0115eb99b77dc347bd62b6bf30a"></a>
static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a7e9ac0115eb99b77dc347bd62b6bf30a">sv_srom</a> = (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *) <a class="el" href="sark_8h.html#ad628bb4c6156bcfeb5b4237811808672">SV_SROM</a></td></tr>
<tr class="memdesc:a7e9ac0115eb99b77dc347bd62b6bf30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SROM. <br /></td></tr>
<tr class="separator:a7e9ac0115eb99b77dc347bd62b6bf30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaac45f0245c38d11322539dc35e58a"><td class="memItemLeft" align="right" valign="top"><a id="acbaac45f0245c38d11322539dc35e58a"></a>
static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#acbaac45f0245c38d11322539dc35e58a">sv_random</a> = (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *) <a class="el" href="sark_8h.html#a4ea54a1b50b0f5d74df91b604006bca9">SV_RANDOM</a></td></tr>
<tr class="memdesc:acbaac45f0245c38d11322539dc35e58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">RANDOM. <br /></td></tr>
<tr class="separator:acbaac45f0245c38d11322539dc35e58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca065bfe68bde3e3f92fb30ffc9a9db4"><td class="memItemLeft" align="right" valign="top"><a id="aca065bfe68bde3e3f92fb30ffc9a9db4"></a>
static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#aca065bfe68bde3e3f92fb30ffc9a9db4">sv_vectors</a> = (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *) <a class="el" href="sark_8h.html#a993ec852f04f051ca86338808f053b93">SV_VECTORS</a></td></tr>
<tr class="memdesc:aca065bfe68bde3e3f92fb30ffc9a9db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VECTORS. <br /></td></tr>
<tr class="separator:aca065bfe68bde3e3f92fb30ffc9a9db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8ecddf793203645bc5cf0d671e40d"><td class="memItemLeft" align="right" valign="top"><a id="a88b8ecddf793203645bc5cf0d671e40d"></a>
static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark_8h.html#a88b8ecddf793203645bc5cf0d671e40d">sv_board_info</a> = (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *) <a class="el" href="sark_8h.html#a41cd20bd99299a9ba4fbcc09768fb83e">SV_SPARE</a></td></tr>
<tr class="memdesc:a88b8ecddf793203645bc5cf0d671e40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Board information. <br /></td></tr>
<tr class="separator:a88b8ecddf793203645bc5cf0d671e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Spinnaker Application Runtime Kernel API. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>&copy; The University of Manchester - 2009-2019</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Steve Temple, APT Group, School of Computer Science </dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structdivmod__t" id="structdivmod__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdivmod__t">&#9670;&nbsp;</a></span>divmod_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct divmod_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Returned (div, mod) from divmod() </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a241b7e0c8e18005706ecb40d410f05cb"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
div</td>
<td class="fielddoc">
Dividend. </td></tr>
<tr><td class="fieldtype">
<a id="ad7831d8b79f0ff56246c54533ad5e959"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
mod</td>
<td class="fielddoc">
Modulus. </td></tr>
</table>

</div>
</div>
<a name="structmem__link__t" id="structmem__link__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmem__link__t">&#9670;&nbsp;</a></span>mem_link_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mem_link_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Used in the block memory allocator (4 bytes) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9282f580a7b41353c063329f12ec6bef"></a>struct mem_link *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Pointer to next free block. </td></tr>
</table>

</div>
</div>
<a name="structmem__block__t" id="structmem__block__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmem__block__t">&#9670;&nbsp;</a></span>mem_block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mem_block_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Used in the block memory allocator (8 bytes) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a835e7479e1ce4260d9ca63867c3a4811"></a><a class="el" href="sark_8h.html#structmem__link__t">mem_link_t</a> *</td>
<td class="fieldname">
free</td>
<td class="fielddoc">
Pointer to first free block. </td></tr>
<tr><td class="fieldtype">
<a id="a7bf30af24fdcb752e26616d5bc3f37b7"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
count</td>
<td class="fielddoc">
Count of blocks in use. </td></tr>
<tr><td class="fieldtype">
<a id="a228a8c62f082390087cb7e5f5546cefc"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
max</td>
<td class="fielddoc">
Maximum blocks used. </td></tr>
</table>

</div>
</div>
<a name="structsrom__data__t" id="structsrom__data__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsrom__data__t">&#9670;&nbsp;</a></span>srom_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct srom_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Contents of SV SROM area (32 bytes) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a44d14476f70d3935c406f2a52cbdafe9"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
16 bit flags </td></tr>
<tr><td class="fieldtype">
<a id="a8c5781c98f7fd310009a4432fde1a0c3"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
mac_addr[6]</td>
<td class="fielddoc">
MAC address. </td></tr>
<tr><td class="fieldtype">
<a id="abb8fa771e15c90eaf184ac402b1a77f7"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
ip_addr[4]</td>
<td class="fielddoc">
IP address. </td></tr>
<tr><td class="fieldtype">
<a id="a54eb515cd59f33b53eb523d3197cf46c"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
gw_addr[4]</td>
<td class="fielddoc">
Gateway address. </td></tr>
<tr><td class="fieldtype">
<a id="a951d08455c888d902dab39f71eaf6294"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
net_mask[4]</td>
<td class="fielddoc">
Net mask. </td></tr>
<tr><td class="fieldtype">
<a id="a6cfdab04242e51f2035e35c9e06e0058"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
udp_port</td>
<td class="fielddoc">
UDP port for SDP messages. </td></tr>
<tr><td class="fieldtype">
<a id="a703df99ccb5177d23b8d50a616763ccb"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
__PAD1</td>
<td class="fielddoc">
Spare... </td></tr>
<tr><td class="fieldtype">
<a id="ae4ecfdda7e4925cfebad76e4cbabd7d9"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
__PAD2</td>
<td class="fielddoc">
Spare... </td></tr>
<tr><td class="fieldtype">
<a id="ac1217793647eaeef7a99f78dcbe85ab8"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
__PAD3</td>
<td class="fielddoc">
Spare... </td></tr>
</table>

</div>
</div>
<a name="structrtr__entry__t" id="structrtr__entry__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrtr__entry__t">&#9670;&nbsp;</a></span>rtr_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rtr_entry_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Copy of router entry (16 bytes) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a466b60ccdad44a62bf4d53d6ae42f86b"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Index of next block. </td></tr>
<tr><td class="fieldtype">
<a id="a063e2c8c0fc8dba0bbf22418217534aa"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
free</td>
<td class="fielddoc">
Index of next free block (or app_id) </td></tr>
<tr><td class="fieldtype">
<a id="a65aaf1346fb346a823998d1656f3409c"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
route</td>
<td class="fielddoc">
Route word. </td></tr>
<tr><td class="fieldtype">
<a id="acaed239b4dd74890ef51713227322278"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
key</td>
<td class="fielddoc">
Key word. </td></tr>
<tr><td class="fieldtype">
<a id="a5a88c2676178963e8278d982c596e58a"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
mask</td>
<td class="fielddoc">
Mask word. </td></tr>
</table>

</div>
</div>
<a name="structapp__data__t" id="structapp__data__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structapp__data__t">&#9670;&nbsp;</a></span>app_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct app_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Stores info relating to AppIDs. </p>
<p>The "cores" field is zero if the ID is not in use. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2422f82aa7c208dfa699466d92fe46df"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
cores</td>
<td class="fielddoc">
Number of cores using this ID. </td></tr>
<tr><td class="fieldtype">
<a id="a6c06f530697cbbec5376e3c8686c190f"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
clean</td>
<td class="fielddoc">
Set if this ID has been cleaned. </td></tr>
<tr><td class="fieldtype">
<a id="acbb178ed80de918e633fd1e957e197f7"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
sema</td>
<td class="fielddoc">
Semaphore. </td></tr>
<tr><td class="fieldtype">
<a id="a46dc77ad5c3450ef6e255dcd6ea0ff02"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
lead</td>
<td class="fielddoc">
Lead core number. </td></tr>
<tr><td class="fieldtype">
<a id="a3777df706a1c18ea3edbf248309afe7b"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
mask</td>
<td class="fielddoc">
Mask of cores using this ID. </td></tr>
</table>

</div>
</div>
<a name="structsdp__msg__t" id="structsdp__msg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdp__msg__t">&#9670;&nbsp;</a></span>sdp_msg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdp_msg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SDP message definition. </p>
<dl class="section note"><dt>Note</dt><dd>the length field is the number of bytes <em>following the checksum.</em> It will be a minimum of 8 as the SDP header should always be present.</dd>
<dd>
make sure to comply with <a class="el" href="sark_8h.html#a05a451a1b870252451ae5661990db041" title="Initialise a memory buffer into a linked list of &quot;count&quot; blocks of &quot;size&quot; bytes.">sark_block_init()</a> requirements:<ol type="1">
<li>size must be a non-zero multiple of 4 bytes.</li>
<li>first field must be a pointer to same struct type. </li>
</ol>
</dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ada6b8682b4353b619c34fb400d059051"></a>struct sdp_msg *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Next in free list. </td></tr>
<tr><td class="fieldtype">
<a id="aa1c885664fdc26ca85a2484e5d6eee4e"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
length</td>
<td class="fielddoc">
length </td></tr>
<tr><td class="fieldtype">
<a id="a46614be2a4af03231b1dc8b904318180"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
checksum</td>
<td class="fielddoc">
checksum (if used) </td></tr>
<tr><td class="fieldtype">
<a id="ad5b3289338fcb1167bd7d8d39f8e04cd"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
Flag byte. </td></tr>
<tr><td class="fieldtype">
<a id="a4d1ea5d7489da3b047e5130e62d7a902"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
tag</td>
<td class="fielddoc">
IP tag. </td></tr>
<tr><td class="fieldtype">
<a id="a1a9906056d66c6ebf36db11ea75511f1"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
dest_port</td>
<td class="fielddoc">
Destination port/CPU. </td></tr>
<tr><td class="fieldtype">
<a id="a34f1d80fdee9359a5bfac320b67ed2a2"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
srce_port</td>
<td class="fielddoc">
Source port/CPU. </td></tr>
<tr><td class="fieldtype">
<a id="acf725ece499fba06264918080d7090ea"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
dest_addr</td>
<td class="fielddoc">
Destination address. </td></tr>
<tr><td class="fieldtype">
<a id="ad15b45dad3933845e2df897da7f0e5ed"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
srce_addr</td>
<td class="fielddoc">
Source address. </td></tr>
<tr><td class="fieldtype">
<a id="a1e6f2e5f52182f42872e289362d79c4d"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
cmd_rc</td>
<td class="fielddoc">
Command/Return Code. </td></tr>
<tr><td class="fieldtype">
<a id="a15e2e88b5633bc5d02b048492bab0e79"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
seq</td>
<td class="fielddoc">
Sequence number. </td></tr>
<tr><td class="fieldtype">
<a id="aa370b690e3ddd25ae89ae44edb5224eb"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg1</td>
<td class="fielddoc">
Arg 1. </td></tr>
<tr><td class="fieldtype">
<a id="a20b5dffc5d688dcee85508c36d62cdb1"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg2</td>
<td class="fielddoc">
Arg 2. </td></tr>
<tr><td class="fieldtype">
<a id="ae12c010284622e3f39fe38d0a5a1a90d"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg3</td>
<td class="fielddoc">
Arg 3. </td></tr>
<tr><td class="fieldtype">
<a id="a0f5d098edf107dddb95c2b1c560dc11d"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
data[<a class="el" href="sark_8h.html#a0096e6ee6d2a16f2f252af0a8c023546">SDP_BUF_SIZE</a>]</td>
<td class="fielddoc">
User data (256 bytes) </td></tr>
<tr><td class="fieldtype">
<a id="ab7b97b86b86b74910d256b3b5ce4b9b8"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
__PAD1</td>
<td class="fielddoc">
Private padding. </td></tr>
</table>

</div>
</div>
<a name="structsdp__hdr__t" id="structsdp__hdr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdp__hdr__t">&#9670;&nbsp;</a></span>sdp_hdr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdp_hdr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SDP header: legacy. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9612544d051e682bcba77cebe38cdb65"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9f09673508bb332006abe32d23ca7615"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
tag</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad8807238f4ffe0c2ba83996bfc24f8d2"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
dest_port</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af90f630b1b0540b65ebad8e119e1dceb"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
srce_port</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a382d06eeaa1d70cc233bb6875b0d8ac8"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
dest_addr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae33235379df8faaf05d1b725d16afc49"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
srce_addr</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structcmd__hdr__t" id="structcmd__hdr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcmd__hdr__t">&#9670;&nbsp;</a></span>cmd_hdr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cmd_hdr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Command header: legacy. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3cfb192d837c9bc556d6481e6c0cad20"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
cmd_rc</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a5d09008cd87082e171aa7d93e52f38d8"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a097b45a4a75dfd787a30828b19448190"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6d7c12c7438b2b3eb9aa77e2fbcc59d0"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aeb1c33cf649b6f58b0b56718f8c300ae"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg3</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structblock__t" id="structblock__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structblock__t">&#9670;&nbsp;</a></span>block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct block_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Heap data block. </p>
<p>One of these appears at the start of each block in the heap so each allocation of N bytes in the heap requires N+8 </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa01786a0e1aa3e25e651d254dc270044"></a>struct block *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Chains all blocks together (in address order) </td></tr>
<tr><td class="fieldtype">
<a id="a308f32be141903b7bba7bd44d033b516"></a>struct block *</td>
<td class="fieldname">
free</td>
<td class="fielddoc">
Chains free blocks together (in address order) </td></tr>
</table>

</div>
</div>
<a name="structheap__t" id="structheap__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structheap__t">&#9670;&nbsp;</a></span>heap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct heap_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Heap root structure. </p>
<p>One of these appears at the start of the heap area and maintains two lists, one containing all blocks in the heap and one containing only free blocks. The heap always contains a 'last' block, of zero size, which is used to mark the end of the heap. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af069ef1a7dcdf0052e3670d96c66d12a"></a><a class="el" href="sark_8h.html#structblock__t">block_t</a> *</td>
<td class="fieldname">
free</td>
<td class="fielddoc">
Root of free block chain. </td></tr>
<tr><td class="fieldtype">
<a id="af266f3069241fd88f74e9417ee4b1b19"></a><a class="el" href="sark_8h.html#structblock__t">block_t</a> *</td>
<td class="fieldname">
first</td>
<td class="fielddoc">
First block. </td></tr>
<tr><td class="fieldtype">
<a id="a3ac677fcc41d0791ef656b94e9038ba6"></a><a class="el" href="sark_8h.html#structblock__t">block_t</a> *</td>
<td class="fieldname">
last</td>
<td class="fielddoc">
Last block (zero size, never used for storage) </td></tr>
<tr><td class="fieldtype">
<a id="a1d4afb841969eacd1a9e154dd552eda0"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
free_bytes</td>
<td class="fielddoc">
Number of free bytes left. </td></tr>
<tr><td class="fieldtype">
<a id="a20d2f0218feb16fbe0b301dfec56fe49"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
buffer[]</td>
<td class="fielddoc">
Buffer for blocks. </td></tr>
</table>

</div>
</div>
<a name="structevent__vec__t" id="structevent__vec__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structevent__vec__t">&#9670;&nbsp;</a></span>event_vec_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct event_vec_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An event_vec fits into 32 bits and contains a handler address in 16 bits and a priority and slot number, each 8 bits. </p>
<p>The handler is therefore constrained to live in the bottom 64K of the address space (i.e., in ITCM) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af6ead177dbf0faf14466c1e2acb0eaf9"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
proc</td>
<td class="fielddoc">
Handler address (squeezed into 16 bits!) </td></tr>
<tr><td class="fieldtype">
<a id="aa4f402b208217a721ba34cfcd804ef03"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
slot</td>
<td class="fielddoc">
VIC slot. </td></tr>
<tr><td class="fieldtype">
<a id="aac160798dedffac659ca3d9d3d1de3b3"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
priority</td>
<td class="fielddoc">
Priority for queued events. </td></tr>
</table>

</div>
</div>
<a name="structsark__vec__t" id="structsark__vec__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsark__vec__t">&#9670;&nbsp;</a></span>sark_vec_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sark_vec_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A struct of type <a class="el" href="sark_8h.html#structsark__vec__t" title="A struct of type sark_vec_t lives at address 0x20, that is, it is built into the code section.">sark_vec_t</a> lives at address 0x20, that is, it is built into the code section. </p>
<p>It contains exception vectors and start-up configuration data which can be modified at the appropriate point during start-up </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa29203dddfcdd8da8a7e3860425cbd3c"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
reset_vec</td>
<td class="fielddoc">
0x20 Reset vector </td></tr>
<tr><td class="fieldtype">
<a id="a052b32accc8bf379edaf289dc1373450"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
undef_vec</td>
<td class="fielddoc">
0x24 Undefined instruction vector </td></tr>
<tr><td class="fieldtype">
<a id="aa333cdf865e925a8d6aaf0540d4fa1d9"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
svc_vec</td>
<td class="fielddoc">
0x28 SVC vector </td></tr>
<tr><td class="fieldtype">
<a id="a1f6328e27b5412cdecf04edc27d9e1c4"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
pabt_vec</td>
<td class="fielddoc">
0x2c Prefetch abort vector </td></tr>
<tr><td class="fieldtype">
<a id="afa24e262013309aea334b1210c596b2a"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
dabt_vec</td>
<td class="fielddoc">
0x30 Data abort vector </td></tr>
<tr><td class="fieldtype">
<a id="a791f03202c5dd59b6212add0e1f12033"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
aplx_proc</td>
<td class="fielddoc">
0x34 Pointer to "proc_aplx" </td></tr>
<tr><td class="fieldtype">
<a id="aa2fff04c8c1dc25eadd1157a83cc6fa7"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
irq_vec</td>
<td class="fielddoc">
0x38 IRQ vector </td></tr>
<tr><td class="fieldtype">
<a id="aeb6e4a9e1b3fd3a35382789c0f648587"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
fiq_vec</td>
<td class="fielddoc">
0x3c FIQ vector </td></tr>
<tr><td class="fieldtype">
<a id="ad8e30a20c5646de61a4d0c5eed483719"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
svc_stack</td>
<td class="fielddoc">
0x40 SVC stack size (words) </td></tr>
<tr><td class="fieldtype">
<a id="a3a757758e791546935a3339af817c293"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
irq_stack</td>
<td class="fielddoc">
0x42 IRQ stack size (words) </td></tr>
<tr><td class="fieldtype">
<a id="a0a99a45e0101dfc0dc27df1c78822830"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
fiq_stack</td>
<td class="fielddoc">
0x44 FIQ stack size (words) </td></tr>
<tr><td class="fieldtype">
<a id="a87216f26337764261e63b0c7ef2bb849"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
stack_size</td>
<td class="fielddoc">
0x46 Total stack size (bytes) </td></tr>
<tr><td class="fieldtype">
<a id="aa5e1bf101d50c4ffa967bc5ba0a257cf"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
code_top</td>
<td class="fielddoc">
0x48 Points to top of code </td></tr>
<tr><td class="fieldtype">
<a id="a8237a5e3d8ffa3c57a0f0ec3ebee77f5"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
heap_base</td>
<td class="fielddoc">
0x4c Points to base of heap </td></tr>
<tr><td class="fieldtype">
<a id="a765a543aa150e75a592f7004d90e73e4"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
stack_top</td>
<td class="fielddoc">
0x50 Points to top of stacks </td></tr>
<tr><td class="fieldtype">
<a id="ae1fdc9c882af3672f7fb695e72c47a84"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
stack_fill</td>
<td class="fielddoc">
0x54 Stack fill word </td></tr>
<tr><td class="fieldtype">
<a id="ae3316245d34528f2dd64d9e9aac18799"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
num_msgs</td>
<td class="fielddoc">
0x58 Number of SDP msgs buffers </td></tr>
<tr><td class="fieldtype">
<a id="ae15883722c2dfa5b27eacebb0acd372e"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
sark_slot</td>
<td class="fielddoc">
0x59 VIC slot for MP-&gt;AP interrupt </td></tr>
<tr><td class="fieldtype">
<a id="a970e263e3f0167427d4014871c5b5e2d"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
num_events</td>
<td class="fielddoc">
0x5a Number of initial events </td></tr>
<tr><td class="fieldtype">
<a id="ad226c1ee85ad3353a45794811b0c7b7b"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
api</td>
<td class="fielddoc">
0x5b API active </td></tr>
<tr><td class="fieldtype">
<a id="ac6deb11d5262f5e6a7b0ea27cc396f4c"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
app_id</td>
<td class="fielddoc">
0x5c App ID </td></tr>
<tr><td class="fieldtype">
<a id="a362716ea1939a2346bed24485ffad7bd"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
app_flags</td>
<td class="fielddoc">
0x5d App flags </td></tr>
<tr><td class="fieldtype">
<a id="a05ab7d1f8d6cf67e73fae1b2b18f0a02"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
__PAD</td>
<td class="fielddoc">
0x5e Pad </td></tr>
<tr><td class="fieldtype">
<a id="af954334861ba33a64cc575232461ddeb"></a><a class="el" href="sark_8h.html#structevent__vec__t">event_vec_t</a></td>
<td class="fieldname">
event[<a class="el" href="sark_8h.html#a25425ecb642d0c2357851329b8ea1c88">EVENT_COUNT</a>]</td>
<td class="fielddoc">
0x60 Event vectors... </td></tr>
</table>

</div>
</div>
<a name="structvcpu__t" id="structvcpu__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structvcpu__t">&#9670;&nbsp;</a></span>vcpu_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct vcpu_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct containing information about each virtual processor. </p>
<p>An array of NUM_CPU of these is based at SV_VCPU in System RAM and pointed to by <a class="el" href="sark_8h.html#ac08702c96eb539a7fbcebbc114424703" title="&quot;sv_vcpu&quot; points to base of array of &quot;vcpu_t&quot;">sv_vcpu</a> </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2235ccee39f7f922d3cd59a9f9854d8b"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
r[8]</td>
<td class="fielddoc">
0 - r0-r7 </td></tr>
<tr><td class="fieldtype">
<a id="a8bc1fd0db9c11300ccd90681c8a764be"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
psr</td>
<td class="fielddoc">
32 - cpsr </td></tr>
<tr><td class="fieldtype">
<a id="a94ac61de5647fd1e9af28d228dc160d2"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sp</td>
<td class="fielddoc">
36 - sp </td></tr>
<tr><td class="fieldtype">
<a id="a6df1fff824b44cf030634628db1ab2e5"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
lr</td>
<td class="fielddoc">
40 - lr </td></tr>
<tr><td class="fieldtype">
<a id="ae244e9a51fd18b285cd170fdba487e80"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
rt_code</td>
<td class="fielddoc">
44 - RT error code </td></tr>
<tr><td class="fieldtype">
<a id="a93fa96def9eff867463364ae56b944d4"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
phys_cpu</td>
<td class="fielddoc">
45 - Physical CPU </td></tr>
<tr><td class="fieldtype">
<a id="ad80e83f990468eecfb1c7988bdb2e1d4"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
cpu_state</td>
<td class="fielddoc">
46 - CPU state </td></tr>
<tr><td class="fieldtype">
<a id="a4098b4e5f13d8515b2abcaed95872e4c"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
app_id</td>
<td class="fielddoc">
47 - Application ID </td></tr>
<tr><td class="fieldtype">
<a id="a50165c37c992b524f4664b3f50b8f6fe"></a>void *</td>
<td class="fieldname">
mbox_ap_msg</td>
<td class="fielddoc">
48 - mbox msg MP-&gt;AP </td></tr>
<tr><td class="fieldtype">
<a id="a327484e6ef9ba2ee4ef5593af92fa242"></a>void *</td>
<td class="fieldname">
mbox_mp_msg</td>
<td class="fielddoc">
52 - mbox msg AP-&gt;MP </td></tr>
<tr><td class="fieldtype">
<a id="a506bed99e8f266f2ef765613f24c0b64"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
mbox_ap_cmd</td>
<td class="fielddoc">
56 - mbox command MP-&gt;AP </td></tr>
<tr><td class="fieldtype">
<a id="ace78a1ae748ce645c8f6a5a43442b3f7"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
mbox_mp_cmd</td>
<td class="fielddoc">
57 - mbox command AP-&gt;MP </td></tr>
<tr><td class="fieldtype">
<a id="a132f373d58f06868ae8611ff297fdb05"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
sw_count</td>
<td class="fielddoc">
58 - SW error count (saturating) </td></tr>
<tr><td class="fieldtype">
<a id="aee58721caead730e6840c82004ad053d"></a>char *</td>
<td class="fieldname">
sw_file</td>
<td class="fielddoc">
60 - SW source file name </td></tr>
<tr><td class="fieldtype">
<a id="abe2e25110b4a94bbec84401adbd69f9c"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sw_line</td>
<td class="fielddoc">
64 - SW source line (could be short?) </td></tr>
<tr><td class="fieldtype">
<a id="aef7d242d3c56f10b490d341df4f53fea"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
time</td>
<td class="fielddoc">
68 - Time of loading </td></tr>
<tr><td class="fieldtype">
<a id="a884ec691d0e76210ab9f6e56a09912f4"></a>char</td>
<td class="fieldname">
app_name[16]</td>
<td class="fielddoc">
72 - Application name </td></tr>
<tr><td class="fieldtype">
<a id="a2ba9ba8b0f3d7c3bc6b6a3af83b17c49"></a>void *</td>
<td class="fieldname">
iobuf</td>
<td class="fielddoc">
88 - IO buffer in SDRAM (or 0) </td></tr>
<tr><td class="fieldtype">
<a id="aadc1a95817c5ecaf3dee2062edc80d6a"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sw_ver</td>
<td class="fielddoc">
92 - SW version </td></tr>
<tr><td class="fieldtype">
<a id="a02cb592117b02e98d29ba92a45bb04cb"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
__PAD[4]</td>
<td class="fielddoc">
96 - (spare) </td></tr>
<tr><td class="fieldtype">
<a id="a6d10a703182a1f793dc7f2e16167d4e6"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
user0</td>
<td class="fielddoc">
112 - User word 0 </td></tr>
<tr><td class="fieldtype">
<a id="a45cc9e02ba79a2c605f2604017d23a64"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
user1</td>
<td class="fielddoc">
116 - User word 1 </td></tr>
<tr><td class="fieldtype">
<a id="a82d770674ea0379ef44f28797b382647"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
user2</td>
<td class="fielddoc">
120 - User word 2 </td></tr>
<tr><td class="fieldtype">
<a id="aef0d3e9eda9ace25fbf65c8a503189bd"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
user3</td>
<td class="fielddoc">
124 - User word 3 </td></tr>
</table>

</div>
</div>
<a name="structevent__t" id="structevent__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structevent__t">&#9670;&nbsp;</a></span>event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct event_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Event structure used by "event_xxx" and "timer_xxx" routines. </p>
<p>When the event is invoked, the proc is called with the two supplied arguments. Queues of events are maintained either on a timer queue for events which have to occur at a particular time or on a set of priority ordered queues for events which are processed by a scheduler.</p>
<dl class="section note"><dt>Note</dt><dd>make sure to comply with <a class="el" href="sark_8h.html#a05a451a1b870252451ae5661990db041" title="Initialise a memory buffer into a linked list of &quot;count&quot; blocks of &quot;size&quot; bytes.">sark_block_init()</a> requirements:<ol type="1">
<li>size must be a non-zero multiple of 4 bytes.</li>
<li>first field must be a pointer to same struct type. </li>
</ol>
</dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af4a09c5bbca618a1dfc9e900c316180a"></a>struct <a class="el" href="sark__event_8c.html#ae7a7108766201ba6bd821b143da63f09">event</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Next in Q or NULL. </td></tr>
<tr><td class="fieldtype">
<a id="ac50f84621f2c714b2888ea169f0c4296"></a><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a></td>
<td class="fieldname">
proc</td>
<td class="fielddoc">
Proc to be called or NULL. </td></tr>
<tr><td class="fieldtype">
<a id="a8d7f4c9097e5de084c919c9d37ba7448"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg1</td>
<td class="fielddoc">
First arg to proc. </td></tr>
<tr><td class="fieldtype">
<a id="a3ceeb65bd442490205a3a798fd0893c1"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg2</td>
<td class="fielddoc">
Second arg to proc. </td></tr>
<tr><td class="fieldtype">
<a id="adf1c52fc7af54e80c3223332d521b554"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
time</td>
<td class="fielddoc">
<p>Time (CPU ticks) until event due (or 0 if at head of Q) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7b744667c7cbe24c08388e6b26ae2479"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
ID</td>
<td class="fielddoc">
Unique ID for active event (0 if inactive) </td></tr>
<tr><td class="fieldtype">
<a id="ad5dd4e4b68fd55b52aa48aa83d1a4243"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
reuse</td>
<td class="fielddoc">
do not free event after queue processing </td></tr>
<tr><td class="fieldtype">
<a id="a539e414923b376a67d276f9aa7148802"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
__PAD1</td>
<td class="fielddoc">
(spare - included for correct size) </td></tr>
<tr><td class="fieldtype">
<a id="a61e41267d26d4e5f05a7c075da342787"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
__PAD2</td>
<td class="fielddoc">
(spare - included for correct size) </td></tr>
<tr><td class="fieldtype">
<a id="ac517f5ba129b46f5f02423caeda44884"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
__PAD3</td>
<td class="fielddoc">
(spare - included for correct size) </td></tr>
</table>

</div>
</div>
<a name="structproc__queue__t" id="structproc__queue__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structproc__queue__t">&#9670;&nbsp;</a></span>proc_queue_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct proc_queue_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct holding head and tail of a list of "event_t". </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adf4013786159ee98956c2292610ef8be"></a><a class="el" href="sark_8h.html#structevent__t">event_t</a> *</td>
<td class="fieldname">
proc_head</td>
<td class="fielddoc">
List of queued "proc" events. </td></tr>
<tr><td class="fieldtype">
<a id="a2084498fbe88ab5101f6252f07f2b7f3"></a><a class="el" href="sark_8h.html#structevent__t">event_t</a> *</td>
<td class="fieldname">
proc_tail</td>
<td class="fielddoc">
and tail of that list </td></tr>
</table>

</div>
</div>
<a name="structpkt__t" id="structpkt__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpkt__t">&#9670;&nbsp;</a></span>pkt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pkt_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct holding a packet. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1f62fbc67e71f3d270efd4b8767f0651"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
ctrl</td>
<td class="fielddoc">
TCR in 23:16, flags in 1:0. </td></tr>
<tr><td class="fieldtype">
<a id="a31f436da9bc6e4d4c157de93dc3403c6"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
data</td>
<td class="fielddoc">
Data (payload) field. </td></tr>
<tr><td class="fieldtype">
<a id="a93bc9b57b16e975a3de071f41fc25bab"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
key</td>
<td class="fielddoc">
Key (non-payload!) field. </td></tr>
</table>

</div>
</div>
<a name="structevent__data__t" id="structevent__data__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structevent__data__t">&#9670;&nbsp;</a></span>event_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct event_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct holding data for "sark_event" and "sark_timer". </p>
<p>This holds all the variables needed by these two packages. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="acaefa06eddf3810e5e68d9df274aa6e3"></a><a class="el" href="sark_8h.html#structevent__t">event_t</a> *</td>
<td class="fieldname">
free</td>
<td class="fielddoc">
List of free events. </td></tr>
<tr><td class="fieldtype">
<a id="a68fe94a25e75c6e8a6147a8cb97ba738"></a><a class="el" href="sark_8h.html#structevent__t">event_t</a> *</td>
<td class="fieldname">
timer_queue</td>
<td class="fielddoc">
List of active timer events. </td></tr>
<tr><td class="fieldtype">
<a id="af45884d2aa4aa8634d6a573dc6b5e983"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
count</td>
<td class="fielddoc">
Number of events currently in use. </td></tr>
<tr><td class="fieldtype">
<a id="aba5495b9d60e19b06a07400e3f67b2a7"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
max</td>
<td class="fielddoc">
Maximum number ever used. </td></tr>
<tr><td class="fieldtype">
<a id="a8cffc56e013dfa9a95e0c717d270ae85"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
id</td>
<td class="fielddoc">
Holds unique ID for active events. </td></tr>
<tr><td class="fieldtype">
<a id="aafddb289b894dd290f1b413afd30d02d"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
failed</td>
<td class="fielddoc">
Counts failures of event_new. </td></tr>
<tr><td class="fieldtype">
<a id="a100de1cfa85f23be5edc19f35f887b61"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
rc</td>
<td class="fielddoc">
Failure codes. </td></tr>
<tr><td class="fieldtype">
<a id="adceddd93b6f6a280f27bd1b9a17431ca"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
Stop/pauses event loop. </td></tr>
<tr><td class="fieldtype">
<a id="a40d2ad60bfd503af6fd87cbef281d908"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
id_rsvd</td>
<td class="fielddoc">
number of reserved IDs </td></tr>
<tr><td class="fieldtype">
<a id="aef852538c7a85d6608680327b214f5df"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
wait</td>
<td class="fielddoc">
Wait state. </td></tr>
<tr><td class="fieldtype">
<a id="a469168c154fd3642bf156ae8955a7aea"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
user</td>
<td class="fielddoc">
Non-zero if user event pending. </td></tr>
<tr><td class="fieldtype">
<a id="a4f2376bab311256596f1ec66fd9262c0"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
ticks</td>
<td class="fielddoc">
Timer tick counter. </td></tr>
<tr><td class="fieldtype">
<a id="acbe38fa182d30b2af93e8ae3225e2cda"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg1</td>
<td class="fielddoc">
Arg1 for user event. </td></tr>
<tr><td class="fieldtype">
<a id="abfa9c98048f8da6391b765bda4457faf"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
arg2</td>
<td class="fielddoc">
Arg2 for user event. </td></tr>
<tr><td class="fieldtype">
<a id="a5287eb212e8f9ee5787a17b15c54372e"></a><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *</td>
<td class="fieldname">
msg</td>
<td class="fielddoc">
Passes msg from SARK to app. </td></tr>
<tr><td class="fieldtype">
<a id="a538b9df238ac2d479ed2cfbb797386b7"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
signal</td>
<td class="fielddoc">
Passes signal from SARK to app. </td></tr>
<tr><td class="fieldtype">
<a id="a09c7f025285170d9c1f3f7a7a2efcffe"></a><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a></td>
<td class="fieldname">
pause_proc</td>
<td class="fielddoc">
Called on pause. </td></tr>
<tr><td class="fieldtype">
<a id="a7e2b8ef4526f51f2837801327fa1ba78"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
pause_arg2</td>
<td class="fielddoc">
Arg2 to pause_proc (arg1 is pause) </td></tr>
<tr><td class="fieldtype">
<a id="a3377207343698969ab6102377449f170"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
exit_rc</td>
<td class="fielddoc">
Return value from "event_start". </td></tr>
<tr><td class="fieldtype">
<a id="a7608d8e0bfd49df8e267792f73dd0be6"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
pkt_insert</td>
<td class="fielddoc">
Insert point for packet queue. </td></tr>
<tr><td class="fieldtype">
<a id="ab1afcb9be2d325e34bf0725483f89fd2"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
pkt_remove</td>
<td class="fielddoc">
Remove point for packet queue. </td></tr>
<tr><td class="fieldtype">
<a id="ad6b634db4d266417602c1863ef7153ab"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
pkt_count</td>
<td class="fielddoc">
Count of items in packet queue. </td></tr>
<tr><td class="fieldtype">
<a id="a3634a63ddd2631a33b8da22d954ae8f2"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
__PAD2</td>
<td class="fielddoc">
(Spare) </td></tr>
<tr><td class="fieldtype">
<a id="a7e1e9a1080687f6c323de219683de8c2"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
pkt_size</td>
<td class="fielddoc">
Size of packet queue (&lt;= 256) </td></tr>
<tr><td class="fieldtype">
<a id="ab72e123243531ad1566dc248f69b8e6f"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
pkt_max</td>
<td class="fielddoc">
Max occupancy of packet queue. </td></tr>
<tr><td class="fieldtype">
<a id="a479554b22efa5cccf4f84313c4ee5b6a"></a><a class="el" href="sark_8h.html#structpkt__t">pkt_t</a> *</td>
<td class="fieldname">
pkt_queue</td>
<td class="fielddoc">
Pointer to packet queue. </td></tr>
<tr><td class="fieldtype">
<a id="a81b52d488439b3bf1ef259cd62048aa9"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
vic_select</td>
<td class="fielddoc">
Builds VIC IRQ/FIQ select word. </td></tr>
<tr><td class="fieldtype">
<a id="a9d84beb5c306dc41a1a5845be5e0c615"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
vic_enable</td>
<td class="fielddoc">
Builds VIC interrupt enable word. </td></tr>
<tr><td class="fieldtype">
<a id="a47bfca041f64c29b9684b5e69e67cd7a"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
old_select</td>
<td class="fielddoc">
Keeps old state of vic_select. </td></tr>
<tr><td class="fieldtype">
<a id="aaf99a85e04d873c67187c1547409d0e6"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
old_enable</td>
<td class="fielddoc">
Keeps old state of vic_enable. </td></tr>
<tr><td class="fieldtype">
<a id="a7463e3bd05eddab0c721a4d9ee373930"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
fiq_vector</td>
<td class="fielddoc">
New FIQ vector (or 0) </td></tr>
<tr><td class="fieldtype">
<a id="a4667c4207f78c13d7560b98b7a10e000"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
old_vector</td>
<td class="fielddoc">
Old FIQ vector. </td></tr>
<tr><td class="fieldtype">
<a id="aa91e78316adfa3c7ee555625881c87d6"></a><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a></td>
<td class="fieldname">
vic_addr[<a class="el" href="sark_8h.html#a25425ecb642d0c2357851329b8ea1c88">EVENT_COUNT</a>]</td>
<td class="fielddoc">
Record of handler for each event. </td></tr>
<tr><td class="fieldtype">
<a id="a3a4cb9bb2ebd950e218a7d9a3c0eb482"></a><a class="el" href="sark_8h.html#structproc__queue__t">proc_queue_t</a></td>
<td class="fieldname">
proc_queue[PRIO_MAX+1]</td>
<td class="fielddoc">
<p>Queues of events - one for each priority level </p>
</td></tr>
</table>

</div>
</div>
<a name="structsark__data__t" id="structsark__data__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsark__data__t">&#9670;&nbsp;</a></span>sark_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sark_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A struct holding all of the variables maintained by SARK. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad9669bc70e6dc4abe0d244d17c1ba593"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
virt_cpu</td>
<td class="fielddoc">
00 Virtual CPU number </td></tr>
<tr><td class="fieldtype">
<a id="ad830519c7a087cfcb875e21a204773cd"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
phys_cpu</td>
<td class="fielddoc">
04 Physical CPU number </td></tr>
<tr><td class="fieldtype">
<a id="aefcbe56944d42fc97fc6cd936529f008"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
random[2]</td>
<td class="fielddoc">
08 Random number variable </td></tr>
<tr><td class="fieldtype">
<a id="aa3ec1aebb8377dd6b62bb5e6992e3a56"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
stack_base</td>
<td class="fielddoc">
10 Bottom of stack area (&amp; heap limit) </td></tr>
<tr><td class="fieldtype">
<a id="a95a4c691118f1154505491831f70f4af"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
heap_base</td>
<td class="fielddoc">
14 Bottom of heap area </td></tr>
<tr><td class="fieldtype">
<a id="a3e0f6c0c3fa590b3063bc746af4b1c1c"></a><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *</td>
<td class="fieldname">
heap</td>
<td class="fielddoc">
18 Heap in DTCM </td></tr>
<tr><td class="fieldtype">
<a id="a9ee5d733b7573ff72e63c597be6aa0c0"></a><a class="el" href="sark_8h.html#structvcpu__t">vcpu_t</a> *</td>
<td class="fieldname">
vcpu</td>
<td class="fielddoc">
1c Pointer to VCPU block </td></tr>
<tr><td class="fieldtype">
<a id="ab9377d15704f3fb65f0b2e78e16175d3"></a><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a></td>
<td class="fieldname">
msg_root</td>
<td class="fielddoc">
20 Control block for SDP messages </td></tr>
<tr><td class="fieldtype">
<a id="afc90622cf71864dd02b771dfa80792a5"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
msg_rcvd</td>
<td class="fielddoc">
28 Numbers of msgs received </td></tr>
<tr><td class="fieldtype">
<a id="a681c8403fe34cc564a0bf14e85afae64"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
msg_sent</td>
<td class="fielddoc">
2c Numbers of msgs sent </td></tr>
<tr><td class="fieldtype">
<a id="a797d954d1bc266ef48545fc3ad90e6ce"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
cpu_clk</td>
<td class="fielddoc">
30 CPU clock speed (MHz) </td></tr>
<tr><td class="fieldtype">
<a id="a45c50d8189020a034b3b9a3522519921"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
sw_rte</td>
<td class="fielddoc">
32 Set to 1 for SW error calls rt_error </td></tr>
<tr><td class="fieldtype">
<a id="a6f9fc773499aa4aaafa0a819706d6564"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
__PAD1</td>
<td class="fielddoc">
33 </td></tr>
<tr><td class="fieldtype">
<a id="a6ece99033654d60431c2f5ffb2369dc5"></a>void *</td>
<td class="fieldname">
sdram_buf</td>
<td class="fielddoc">
34 Pointer to SDRAM buffer </td></tr>
<tr><td class="fieldtype">
<a id="a92a0282c4e5af16055723918db34f79b"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
pkt_count</td>
<td class="fielddoc">
38 Count of thrown packets </td></tr>
</table>

</div>
</div>
<a name="structsv__t" id="structsv__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsv__t">&#9670;&nbsp;</a></span>sv_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sv_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct holding the System Variables. </p>
<p>Placed at the top of System RAM at 0xe5007f00 (<a class="el" href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026" title="e5007f00">SV_SV</a>) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad52f8bc34a1c4e44b815e557244d197c"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
p2p_addr</td>
<td class="fielddoc">
00 P2P address of this chip </td></tr>
<tr><td class="fieldtype">
<a id="aaab5bd64eeff0bf4082a69c3c5b47f0f"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
p2p_dims</td>
<td class="fielddoc">
02 P2P dimensions </td></tr>
<tr><td class="fieldtype">
<a id="ab040ae47c70e3846f54f044405ea676b"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
dbg_addr</td>
<td class="fielddoc">
04 P2P address for debug messages </td></tr>
<tr><td class="fieldtype">
<a id="a418a02534fc0f0aaa669935c0f481165"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
p2p_up</td>
<td class="fielddoc">
06 Non-zero if P2P networking active </td></tr>
<tr><td class="fieldtype">
<a id="ac1bca12de28d9f8b3d6bc48dc28f208a"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
last_id</td>
<td class="fielddoc">
07 Last ID used in NNBC </td></tr>
<tr><td class="fieldtype">
<a id="a77a393b2853088dcbc9e9d5f4942bfb6"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
eth_addr</td>
<td class="fielddoc">
08 P2P address of nearest Ethernet node </td></tr>
<tr><td class="fieldtype">
<a id="a3042eeaf83cc1f25fa3f1a5ae3a447f6"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
hw_ver</td>
<td class="fielddoc">
0a Hardware version </td></tr>
<tr><td class="fieldtype">
<a id="af6e2c8a4c6e4b6ee7e9ee50f835607fe"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
eth_up</td>
<td class="fielddoc">
0b Non-zero if Ethernet active </td></tr>
<tr><td class="fieldtype">
<a id="aae36b30c746bf27f179e3451807035ed"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
p2pb_repeats</td>
<td class="fielddoc">
0c Number of times to send out P2PB packets </td></tr>
<tr><td class="fieldtype">
<a id="aa22206f9bce9e0bb3e6a3420d97e1551"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
p2p_sql</td>
<td class="fielddoc">
0d P2P sequence length (**) </td></tr>
<tr><td class="fieldtype">
<a id="a39173c033f05324eda3259d7d13c373d"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
clk_div</td>
<td class="fielddoc">
0e Clock divisors for system &amp; router bus </td></tr>
<tr><td class="fieldtype">
<a id="a89368e7a19d3630ab5612848514b54e8"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
tp_scale</td>
<td class="fielddoc">
0f Scale for router phase timer </td></tr>
<tr><td class="fieldtype">
<a id="a277c843c6bda19b6542768a5c0854a91"></a>volatile <a class="el" href="spinnaker_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a></td>
<td class="fieldname">
clock_ms</td>
<td class="fielddoc">
10 Milliseconds since boot </td></tr>
<tr><td class="fieldtype">
<a id="a7607f5a4b36314ad0a737d80d20c6d43"></a>volatile <a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
time_ms</td>
<td class="fielddoc">
18 Milliseconds in second (0..999) </td></tr>
<tr><td class="fieldtype">
<a id="ac1c7fd92c85c509f14a251c939dde3f2"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
ltpc_period</td>
<td class="fielddoc">
1a Local Time Phase Control message interval (*10 ms) </td></tr>
<tr><td class="fieldtype">
<a id="a2f53dfc85f86092b7fa0ca216537f645"></a>volatile <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
unix_time</td>
<td class="fielddoc">
1c Seconds since 1970 </td></tr>
<tr><td class="fieldtype">
<a id="a9dd758ebd57c06946246480acfd6a9fe"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
tp_timer</td>
<td class="fielddoc">
20 Router time phase timer </td></tr>
<tr><td class="fieldtype">
<a id="ad8d149e8f66ba18c5d5f90d88534d0fa"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
cpu_clk</td>
<td class="fielddoc">
24 CPU clock in MHz </td></tr>
<tr><td class="fieldtype">
<a id="a5230445b1bb08c388c857f15b61123ed"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
mem_clk</td>
<td class="fielddoc">
26 SDRAM clock in MHz </td></tr>
<tr><td class="fieldtype">
<a id="a6d6b815cc7bec73e1bbfb4d4305764a7"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
forward</td>
<td class="fielddoc">
28 NNBC forward parameter </td></tr>
<tr><td class="fieldtype">
<a id="aa954cc9eb9a2d3ae457bacc6af4493ba"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
retry</td>
<td class="fielddoc">
29 NNBC retry parameter </td></tr>
<tr><td class="fieldtype">
<a id="abfc1a4e481f8cda2e2d2936ad35c947d"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
peek_time</td>
<td class="fielddoc">
2a Timeout for link read/write (us) </td></tr>
<tr><td class="fieldtype">
<a id="a4db60f17164ed66e42fa9550f09c05a7"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
led_period</td>
<td class="fielddoc">
2b LED flash period (* 10 ms) </td></tr>
<tr><td class="fieldtype">
<a id="ad9269a0b20db33667a9a297ec262d019"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
netinit_bc_wait</td>
<td class="fielddoc">
2c Minimum time after last BC during netinit (*10 ms) </td></tr>
<tr><td class="fieldtype">
<a id="a26a2b7412f8489ce0ae8b4ff9179c0c8"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
netinit_phase</td>
<td class="fielddoc">
2d Phase of boot process </td></tr>
<tr><td class="fieldtype">
<a id="a6fd98c1fa0c29809eaee27ac6d81e0f4"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
p2p_root</td>
<td class="fielddoc">
2e The P2P address from which the system was booted </td></tr>
<tr><td class="fieldtype">
<a id="aaffad241711be917de2d2c188a3a6239"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
led0</td>
<td class="fielddoc">
30 LED definition words (for up </td></tr>
<tr><td class="fieldtype">
<a id="aedf38e2470b4ede659aaf89cd2bca94d"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
led1</td>
<td class="fielddoc">
34 to 15 LEDs) </td></tr>
<tr><td class="fieldtype">
<a id="ab02a9e34d85e0ce32b8ff5e6f1530c7b"></a>int</td>
<td class="fieldname">
clock_drift</td>
<td class="fielddoc">
38 drift of clock from boot chip clock in ticks / us </td></tr>
<tr><td class="fieldtype">
<a id="ab2c7b4f5f622c5a397833ba72fd58b2a"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
random</td>
<td class="fielddoc">
3c Random number seed </td></tr>
<tr><td class="fieldtype">
<a id="a469192663673043167174d3a65746ffb"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
root_chip</td>
<td class="fielddoc">
40 Set if we are the root chip </td></tr>
<tr><td class="fieldtype">
<a id="a0774ad3187f83719f68f070baa0e4c8b"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
num_buf</td>
<td class="fielddoc">
41 Number of SHM buffers </td></tr>
<tr><td class="fieldtype">
<a id="a78be52bbaccf24010a24231802276f42"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
boot_delay</td>
<td class="fielddoc">
42 Delay between boot NN pkts (us) </td></tr>
<tr><td class="fieldtype">
<a id="a1793d230392c1d6f80b655ed835ce584"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
soft_wdog</td>
<td class="fielddoc">
43 Soft watchdog control </td></tr>
<tr><td class="fieldtype">
<a id="a23ea13208270902877e2aece6fb9e46e"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sync_alignment</td>
<td class="fielddoc">
44 delay for sync0/1 alignment (us) </td></tr>
<tr><td class="fieldtype">
<a id="a49cd1a99ea244e2eab0a4b54af48d26b"></a><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *</td>
<td class="fieldname">
sysram_heap</td>
<td class="fielddoc">
48 Heap in SysRAM </td></tr>
<tr><td class="fieldtype">
<a id="a9e8e3588b3fada4f38c82608d855a102"></a><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *</td>
<td class="fieldname">
sdram_heap</td>
<td class="fielddoc">
4c Heap in SDRAM </td></tr>
<tr><td class="fieldtype">
<a id="a173c1022bbba07d28f09bf9f7b021c27"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
iobuf_size</td>
<td class="fielddoc">
50 Size of IO buffers (bytes) </td></tr>
<tr><td class="fieldtype">
<a id="a5c41e58e619e2c786dc211bfc5302c23"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
sdram_bufs</td>
<td class="fielddoc">
54 SDRAM buffers </td></tr>
<tr><td class="fieldtype">
<a id="a27df4540917f08d313df5b2e7d3aed8a"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sysbuf_size</td>
<td class="fielddoc">
58 Size of system buffers (words) </td></tr>
<tr><td class="fieldtype">
<a id="a771f3829db59beef21b3b9bb9d58497b"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
boot_sig</td>
<td class="fielddoc">
5c Boot signature word </td></tr>
<tr><td class="fieldtype">
<a id="a50fe4ed552dfbae4ce47e773893483a6"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
mem_ptr</td>
<td class="fielddoc">
60 Memory pointer for NNBC memory setter </td></tr>
<tr><td class="fieldtype">
<a id="ac90b6cea01c0806d317e326f454c6c37"></a>volatile <a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
lock</td>
<td class="fielddoc">
64 Lock variable </td></tr>
<tr><td class="fieldtype">
<a id="a64d5f15b6016d754a38292388ca8e32e"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
link_en</td>
<td class="fielddoc">
65 Bit map of enabled links </td></tr>
<tr><td class="fieldtype">
<a id="a06d8851217652dba498d6f5d251f4a28"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
last_biff_id</td>
<td class="fielddoc">
66 Last ID used in BIFF </td></tr>
<tr><td class="fieldtype">
<a id="a6f8795390b516e736bc6c0ad35c7bc76"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
bt_flags</td>
<td class="fielddoc">
67 Board Test flags </td></tr>
<tr><td class="fieldtype">
<a id="ac3273ac44caa60eb9d271c8b1eb109be"></a><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a></td>
<td class="fieldname">
shm_root</td>
<td class="fielddoc">
68 Control block for SHM bufs </td></tr>
<tr><td class="fieldtype">
<a id="a673edc1b055b29bacb940317e15d1758"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
utmp0</td>
<td class="fielddoc">
70 Four temps... </td></tr>
<tr><td class="fieldtype">
<a id="a7496880ea84049fe7327ec251f2b8d09"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
utmp1</td>
<td class="fielddoc">
74 </td></tr>
<tr><td class="fieldtype">
<a id="a91def0f7ef7574b9576c054b8e0ad712"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
utmp2</td>
<td class="fielddoc">
78 </td></tr>
<tr><td class="fieldtype">
<a id="aa804decad2ba55941b6400d18f51bf3b"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
utmp3</td>
<td class="fielddoc">
7c </td></tr>
<tr><td class="fieldtype">
<a id="ab1bc130e9e126e2af2db0442b834d9d5"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
status_map[20]</td>
<td class="fielddoc">
80 Set during SC&amp;MP ROM boot </td></tr>
<tr><td class="fieldtype">
<a id="a92bc70874e24b1fcd8a44cc5511fb2c2"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
p2v_map[20]</td>
<td class="fielddoc">
94 Phys to Virt core map </td></tr>
<tr><td class="fieldtype">
<a id="ae0a27a1ee4002f31209f160871cc496c"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
v2p_map[20]</td>
<td class="fielddoc">
a8 Virt to Phys core map </td></tr>
<tr><td class="fieldtype">
<a id="ac791dface22099d8595c5d987617fad0"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
num_cpus</td>
<td class="fielddoc">
bc Number of good cores </td></tr>
<tr><td class="fieldtype">
<a id="a8ab30e407732091aa326b74d5865a12a"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
rom_cpus</td>
<td class="fielddoc">
bd SC&amp;MP ROM good cores </td></tr>
<tr><td class="fieldtype">
<a id="aba3eb2951d3b9b26813db8a59ab185fa"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
board_addr</td>
<td class="fielddoc">
be Position of chip on PCB </td></tr>
<tr><td class="fieldtype">
<a id="adcd5140b0d522e2e3f261ad348445d2f"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
sdram_base</td>
<td class="fielddoc">
c0 Base of user SDRAM </td></tr>
<tr><td class="fieldtype">
<a id="af6843a2eb98fe1699ffd4845a24ff359"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
sysram_base</td>
<td class="fielddoc">
c4 Base of user SysRAM </td></tr>
<tr><td class="fieldtype">
<a id="a3a8c116ab07a508f7249c7b30cbdd75d"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
sdram_sys</td>
<td class="fielddoc">
c8 System SDRAM </td></tr>
<tr><td class="fieldtype">
<a id="a0f2b8b482a280d43393a06dac7664a05"></a><a class="el" href="sark_8h.html#structvcpu__t">vcpu_t</a> *</td>
<td class="fieldname">
vcpu_base</td>
<td class="fielddoc">
cc Start of VCPU blocks </td></tr>
<tr><td class="fieldtype">
<a id="a10a9d196bb5a8c50812ae0f9df27f03b"></a><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *</td>
<td class="fieldname">
sys_heap</td>
<td class="fielddoc">
d0 System heap in SDRAM </td></tr>
<tr><td class="fieldtype">
<a id="a1323a17ad4678f6e7abfc865df8dd0fa"></a><a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a> *</td>
<td class="fieldname">
rtr_copy</td>
<td class="fielddoc">
d4 Copy of router MC tables </td></tr>
<tr><td class="fieldtype">
<a id="ae2563a7f8e019724475754bc5c8b5925"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
hop_table</td>
<td class="fielddoc">
d8 P2P hop table </td></tr>
<tr><td class="fieldtype">
<a id="a49e8b157a84b6a073451ba898e258b9f"></a><a class="el" href="sark_8h.html#structblock__t">block_t</a> **</td>
<td class="fieldname">
alloc_tag</td>
<td class="fielddoc">
dc Start of alloc_tag table </td></tr>
<tr><td class="fieldtype">
<a id="a7143258a0930901112366eab8a3057b8"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
rtr_free</td>
<td class="fielddoc">
e0 Start of free router entry list </td></tr>
<tr><td class="fieldtype">
<a id="a718c2b627447cff3e3edf15da0fa653d"></a><a class="el" href="spinnaker_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a></td>
<td class="fieldname">
p2p_active</td>
<td class="fielddoc">
e2 Count of active P2P addresses </td></tr>
<tr><td class="fieldtype">
<a id="a70a7a698054ac74cd898b0e753308c48"></a><a class="el" href="sark_8h.html#structapp__data__t">app_data_t</a> *</td>
<td class="fieldname">
app_data</td>
<td class="fielddoc">
e4 Array of app_id structs </td></tr>
<tr><td class="fieldtype">
<a id="afe0bd914503c2905d9d0b1c4d343238d"></a><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *</td>
<td class="fieldname">
shm_buf</td>
<td class="fielddoc">
e8 SHM buffers </td></tr>
<tr><td class="fieldtype">
<a id="af18e0c8263a8b3d7ed4ea70c5c5c130c"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
mbox_flags</td>
<td class="fielddoc">
ec AP-&gt;MP communication flags </td></tr>
<tr><td class="fieldtype">
<a id="a3ca9e489e9aeed0cafb4d9a9e5c88d41"></a><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></td>
<td class="fieldname">
ip_addr[4]</td>
<td class="fielddoc">
f0 IP address (or 0) </td></tr>
<tr><td class="fieldtype">
<a id="a8e3eb230e4d0458dee028e85b3242541"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
fr_copy</td>
<td class="fielddoc">
f4 (Virtual) copy of router FR reg </td></tr>
<tr><td class="fieldtype">
<a id="a6d6b9261a79c368611a8e02abe070d76"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *</td>
<td class="fieldname">
board_info</td>
<td class="fielddoc">
f8 Pointer to board_info area !! </td></tr>
<tr><td class="fieldtype">
<a id="a68aa4c327dea2d410decbea9f6ea1487"></a><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
<td class="fieldname">
sw_ver</td>
<td class="fielddoc">
fc Software version number </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a70a68a061183156ed09c67e2e724b0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a68a061183156ed09c67e2e724b0c2">&#9670;&nbsp;</a></span>sw_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sw_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sark__base_8c.html#aa82adc6677b15f452e59063cf4a8f2f0">sw_error_fl</a> (mode, __FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sw_error calls <a class="el" href="sark_8h.html#aa82adc6677b15f452e59063cf4a8f2f0" title="Generates a software error, logging the filename and line number at which the error occurs.">sw_error_fl()</a>, inserting file name and line number automatically </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>determines if <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> is called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="add2659cdf5414e6ab00bc5c7471a07f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2659cdf5414e6ab00bc5c7471a07f8">&#9670;&nbsp;</a></span>int_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* int_handler) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The basic type of an interrupt handler. Takes no arguments. Returns nothing. </p>
<p>Defines and typedefs to rationalise ARM/GNU interrupt handlers </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a707dc476cdca6c9a8cd1695f25fe555a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707dc476cdca6c9a8cd1695f25fe555a">&#9670;&nbsp;</a></span>sark_aplx_command</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a707dc476cdca6c9a8cd1695f25fe555a">sark_aplx_command</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commands used in the APLX loader. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a707dc476cdca6c9a8cd1695f25fe555aa87f9b6a1505b09b1d62a427cb02e68a4"></a>APLX_ACOPY&#160;</td><td class="fielddoc"><p>Absolute copy. </p>
</td></tr>
<tr><td class="fieldname"><a id="a707dc476cdca6c9a8cd1695f25fe555aa14a3db1b3e820917f084acee5b0cbcbf"></a>APLX_RCOPY&#160;</td><td class="fielddoc"><p>Relative copy. </p>
</td></tr>
<tr><td class="fieldname"><a id="a707dc476cdca6c9a8cd1695f25fe555aadde259e49b3d9ddc8173d3627a1b5554"></a>APLX_FILL&#160;</td><td class="fielddoc"><p>Fill memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a707dc476cdca6c9a8cd1695f25fe555aaf36a74033d29f7566f01738b80845e69"></a>APLX_EXEC&#160;</td><td class="fielddoc"><p>Execute. </p>
</td></tr>
<tr><td class="fieldname"><a id="a707dc476cdca6c9a8cd1695f25fe555aa15d4e155cc151a4f70298600b052ed48"></a>APLX_END&#160;</td><td class="fielddoc"><p>End marker (rarely used) </p>
</td></tr>
</table>

</div>
</div>
<a id="a5cee57b7a2c3c335a5155b8fad8958d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee57b7a2c3c335a5155b8fad8958d4">&#9670;&nbsp;</a></span>spin_lock_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a5cee57b7a2c3c335a5155b8fad8958d4">spin_lock_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocations of SysCtl Test &amp; Set registers (locks) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4a2bd89e77b8ad338358834341c7dce43d"></a>LOCK_MSG&#160;</td><td class="fielddoc"><p>Msg buffers in SysRAM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4ac7cd8fa7e071fac1859700e3388bd964"></a>LOCK_MBOX&#160;</td><td class="fielddoc"><p>Mailbox flag variable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4afaa69bad332ec2fd0216ea262ee668ee"></a>LOCK_ETHER&#160;</td><td class="fielddoc"><p>Ethernet Tx (unused...) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4ad4155cd6adef65f957edaca879bc0c6e"></a>LOCK_GPIO&#160;</td><td class="fielddoc"><p>GPIO port (unused...) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4a26842e7a97cc425a110d27d69a65e651"></a>LOCK_API_ROOT&#160;</td><td class="fielddoc"><p>Spin1 API. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4a251c7766d9bb74e4ce9c8aa5dd4e9b7f"></a>LOCK_SEMA&#160;</td><td class="fielddoc"><p>Sema access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4a89d69bef15e6dd767c4d851969568b49"></a>LOCK_HEAP&#160;</td><td class="fielddoc"><p>Heap in System / SDRAM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cee57b7a2c3c335a5155b8fad8958d4a2403509583bec93127bb5a807ee64a90"></a>LOCK_RTR&#160;</td><td class="fielddoc"><p>Router. </p>
</td></tr>
</table>

</div>
</div>
<a id="ada83d5de50faddcc7a1a3a3354b3ec49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada83d5de50faddcc7a1a3a3354b3ec49">&#9670;&nbsp;</a></span>app_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#ada83d5de50faddcc7a1a3a3354b3ec49">app_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags in app_flags field. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada83d5de50faddcc7a1a3a3354b3ec49a4e78619422e7eaaea3803e2bf1e5b55e"></a>APP_FLAG_WAIT&#160;</td><td class="fielddoc"><p>Wait for start signal. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3cf9347d757f8d978aa2d35927e21806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9347d757f8d978aa2d35927e21806">&#9670;&nbsp;</a></span>rte_code_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a3cf9347d757f8d978aa2d35927e21806">rte_code_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run time error codes, passed as first arg to <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806af19712c673bff49b738641905254d963"></a>RTE_NONE&#160;</td><td class="fielddoc"><p>0 No error </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a1dca7761a7d789527304b6bf9a9952aa"></a>RTE_RESET&#160;</td><td class="fielddoc"><p>1 Branch through zero </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806abfe89d504e69c2b906412d62d0ea5ea9"></a>RTE_UNDEF&#160;</td><td class="fielddoc"><p>2 Undefined instruction </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a5f6cbc846580ec613b6856d4c763edfd"></a>RTE_SVC&#160;</td><td class="fielddoc"><p>3 Undefined SVC or no handler </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a74283c5c33207d02e53ef2315c84a20d"></a>RTE_PABT&#160;</td><td class="fielddoc"><p>4 Prefetch abort </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806af3e999535726c0d7294855bf261abcc7"></a>RTE_DABT&#160;</td><td class="fielddoc"><p>5 Data abort </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806ab0e4d003206cf229551f8dd414434114"></a>RTE_IRQ&#160;</td><td class="fielddoc"><p>6 Unhandled IRQ </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806af32ac3e03175989ee4c9ba3a55f5ac52"></a>RTE_FIQ&#160;</td><td class="fielddoc"><p>7 Unhandled FIQ </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a9e8efcaeece564e534416a5f54ad5d5d"></a>RTE_VIC&#160;</td><td class="fielddoc"><p>8 Unconfigured VIC vector </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a228d90e8251d61de8cf4fe5026008998"></a>RTE_ABORT&#160;</td><td class="fielddoc"><p>Generic user abort. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806acd9e88eb8d10980ccdd8c1b2bb3ec035"></a>RTE_MALLOC&#160;</td><td class="fielddoc"><p>"malloc" failure </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a7b6e67cfddc6236ae6c74f2e22f220e1"></a>RTE_DIV0&#160;</td><td class="fielddoc"><p>Divide by zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806ac566062eb6d8f30fb7ffbb6a7963044d"></a>RTE_EVENT&#160;</td><td class="fielddoc"><p>Event startup failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a66bc0d0be1de9f6afc1787e49ffae339"></a>RTE_SWERR&#160;</td><td class="fielddoc"><p>Fatal SW error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a80dda6ab0b06dcd07e8870765c9d2615"></a>RTE_IOBUF&#160;</td><td class="fielddoc"><p>Failed to allocate IO buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a40f3f82c8cdd80ccbd9457be160d5b98"></a>RTE_ENABLE&#160;</td><td class="fielddoc"><p>Bad event enable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806aadaf315a9f0d71ecb74bc0d2aa420996"></a>RTE_NULL&#160;</td><td class="fielddoc"><p>Generic null pointer error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a00a3039990f8f9e2d2236286d0d9e786"></a>RTE_PKT&#160;</td><td class="fielddoc"><p>Pkt startup failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806a1d402645d5abfe4e00a6130ff0c66dfa"></a>RTE_TIMER&#160;</td><td class="fielddoc"><p>Timer startup failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806ad86ab887d63c00784b2efa65fa1cbb87"></a>RTE_API&#160;</td><td class="fielddoc"><p>API startup failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3cf9347d757f8d978aa2d35927e21806ad19840e59921fc9dd40af8f932a282a4"></a>RTE_VER&#160;</td><td class="fielddoc"><p>SW version conflict. </p>
</td></tr>
</table>

</div>
</div>
<a id="aba531b9d7bd6ab156cf29a04a66216fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba531b9d7bd6ab156cf29a04a66216fb">&#9670;&nbsp;</a></span>sark_alib_rte_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#aba531b9d7bd6ab156cf29a04a66216fb">sark_alib_rte_codes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For "sark_alib.s" (maintain sync with enum rte_code_e) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fba3d06b52632231b657557e80993907f6d"></a>A_RTE_RESET&#160;</td><td class="fielddoc"><p>Branch through zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fbaff8fe5f17e0c79da8b730074ec4e1869"></a>A_RTE_UNDEF&#160;</td><td class="fielddoc"><p>Undefined instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fbad0c8329749e6d90e83f091c131138b2a"></a>A_RTE_SVC&#160;</td><td class="fielddoc"><p>Undefined SVC or no handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fbad79d30396f3ed5e46770ed59d70ddbed"></a>A_RTE_PABT&#160;</td><td class="fielddoc"><p>Prefetch abort. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fba58976896638075c1f09e985fc288bc2e"></a>A_RTE_DABT&#160;</td><td class="fielddoc"><p>Data abort. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fba85ba342ddd7755f309884b75ac7b79ec"></a>A_RTE_IRQ&#160;</td><td class="fielddoc"><p>Unhandled IRQ. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fba4e2805a1e9e04a279c566eb9060d46cd"></a>A_RTE_FIQ&#160;</td><td class="fielddoc"><p>Unhandled FIQ. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba531b9d7bd6ab156cf29a04a66216fbacb62844ebe76904b9da8331ee1de8e47"></a>A_RTE_VIC&#160;</td><td class="fielddoc"><p>Unconfigured VIC vector. </p>
</td></tr>
</table>

</div>
</div>
<a id="a37318835424d76f3f5b321058887236d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37318835424d76f3f5b321058887236d">&#9670;&nbsp;</a></span>cpu_state_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a37318835424d76f3f5b321058887236d">cpu_state_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime state of a core (limited to 16) </p>
<p>Held in <a class="el" href="sark_8h.html#ad80e83f990468eecfb1c7988bdb2e1d4" title="46 - CPU state">vcpu_t::cpu_state</a> byte of <a class="el" href="sark_8h.html#structvcpu__t" title="Struct containing information about each virtual processor.">vcpu_t</a> struct. States less than 4 are 'dead' and not expected to respond to anything </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da5fdc95ad5a4ddcf32e79798c8b2c53b2"></a>CPU_STATE_DEAD&#160;</td><td class="fielddoc"><p>Dead core. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236dab6112bf8f882083d1481cdc949b86b54"></a>CPU_STATE_PWRDN&#160;</td><td class="fielddoc"><p>Powered down. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236daea3adbea49fd3cf9d2bffa4698ebe03d"></a>CPU_STATE_RTE&#160;</td><td class="fielddoc"><p>Died with Run Time Error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da081b5c672eb66e504283de013ffaeeb9"></a>CPU_STATE_WDOG&#160;</td><td class="fielddoc"><p>Watchdog expired. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da7bebf57001a32d7dd3203e3ef346f37a"></a>CPU_STATE_INIT&#160;</td><td class="fielddoc"><p>Initialising (transient) </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236dad92a650aabe37b8b491eaff36fe15318"></a>CPU_STATE_WAIT&#160;</td><td class="fielddoc"><p>Ready to execute. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236dab06591102cb34c05e61dc151bb812d59"></a>CPU_STATE_SARK&#160;</td><td class="fielddoc"><p>Entered c_main. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da504ca9cb33bebc4ff8b20b3eb97facbd"></a>CPU_STATE_RUN&#160;</td><td class="fielddoc"><p>Running (API/Event) </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da6fa07205ec7c136824a44685895becf7"></a>CPU_STATE_SYNC0&#160;</td><td class="fielddoc"><p>Waiting for sync 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da55fddfc9f3fe2b6429523deb00c458b9"></a>CPU_STATE_SYNC1&#160;</td><td class="fielddoc"><p>Waiting for sync 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236dadcefe4af17b67dc5de698473127ea564"></a>CPU_STATE_PAUSE&#160;</td><td class="fielddoc"><p>Paused in application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236dae259fb0c2645704951236737a63322ee"></a>CPU_STATE_EXIT&#160;</td><td class="fielddoc"><p>Exited application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da00c5193a3d21fe121673fd5e7b23f0f5"></a>CPU_STATE_12&#160;</td><td class="fielddoc"><p>Spare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da40e94686da942cc278f596f06a68ba39"></a>CPU_STATE_13&#160;</td><td class="fielddoc"><p>Spare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da23871c9467df994d98fd777deec61d99"></a>CPU_STATE_14&#160;</td><td class="fielddoc"><p>Spare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37318835424d76f3f5b321058887236da20cbc4e49e69ce2f28bd2589defaf502"></a>CPU_STATE_IDLE&#160;</td><td class="fielddoc"><p>Idle (SARK stub) </p>
</td></tr>
</table>

</div>
</div>
<a id="ab9a826a649bbc6b8084e7c7d6bc23881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a826a649bbc6b8084e7c7d6bc23881">&#9670;&nbsp;</a></span>event_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#ab9a826a649bbc6b8084e7c7d6bc23881">event_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of event. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881a811c2a26881d48cc1a77300cd79a918e"></a>EVENT_TIMER&#160;</td><td class="fielddoc"><p>Timer elapsed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881aec3d6aec2dfd7c4de1c10ca9a2372795"></a>EVENT_RXPKT&#160;</td><td class="fielddoc"><p>MC packet received. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881abf41b11fa8ff57c33f446088c38712bd"></a>EVENT_SDP&#160;</td><td class="fielddoc"><p>SDP packet received. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881a822ec7de5e51e61b1e86620be23fe0bd"></a>EVENT_USER&#160;</td><td class="fielddoc"><p>User triggered event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881a0faa65d8fd5b5a4659b6473af6f941fb"></a>EVENT_SIG&#160;</td><td class="fielddoc"><p>Signal from hosts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881a21b293748ec91ca885a07f6c9b218ea5"></a>EVENT_DMA&#160;</td><td class="fielddoc"><p>DMA complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9a826a649bbc6b8084e7c7d6bc23881af66ca241c2a2e3ef806d69cb9fd7c339"></a>EVENT_MAX&#160;</td><td class="fielddoc"><p>Maximum event number. </p>
</td></tr>
</table>

</div>
</div>
<a id="acdb52540a2684e30650a8a4ac892f74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb52540a2684e30650a8a4ac892f74a">&#9670;&nbsp;</a></span>event_state_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#acdb52540a2684e30650a8a4ac892f74a">event_state_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of event execution. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acdb52540a2684e30650a8a4ac892f74aa589a97f39a2de0129bf372b1fd4216fd"></a>EVENT_RUN&#160;</td><td class="fielddoc"><p>Running. </p>
</td></tr>
<tr><td class="fieldname"><a id="acdb52540a2684e30650a8a4ac892f74aa4a95b1a327b7f948875054edc5c2f76b"></a>EVENT_PAUSE&#160;</td><td class="fielddoc"><p>Paused. </p>
</td></tr>
<tr><td class="fieldname"><a id="acdb52540a2684e30650a8a4ac892f74aac9bede468864b3ea2574a7b355cf6590"></a>EVENT_STOP&#160;</td><td class="fielddoc"><p>Stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="a680660a112faeb990fc97a25eef9d643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680660a112faeb990fc97a25eef9d643">&#9670;&nbsp;</a></span>vic_slot_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a680660a112faeb990fc97a25eef9d643">vic_slot_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slots in the VIC interrupt controller. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a680660a112faeb990fc97a25eef9d643a2cf274b6e5590191aacba5d191d5162c"></a>SLOT_FIQ&#160;</td><td class="fielddoc"><p>Special slot for FIQ. </p>
</td></tr>
<tr><td class="fieldname"><a id="a680660a112faeb990fc97a25eef9d643aa1cadb71ce46d1447d36d3c7ec5cb53c"></a>SLOT_MAX&#160;</td><td class="fielddoc"><p>Index of largest ordinary slot. </p>
</td></tr>
</table>

</div>
</div>
<a id="a29002882868350d94a53ef964eddcdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29002882868350d94a53ef964eddcdbe">&#9670;&nbsp;</a></span>sw_err_mode_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a29002882868350d94a53ef964eddcdbe">sw_err_mode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode for <a class="el" href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2" title="sw_error calls sw_error_fl(), inserting file name and line number automatically">sw_error()</a> calls to decide if <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> is to be called. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a29002882868350d94a53ef964eddcdbea708f4708e456e4554f57a99e34e5d22f"></a>SW_OPT&#160;</td><td class="fielddoc"><p>Optional, controlled by sark.sw_rte. </p>
</td></tr>
<tr><td class="fieldname"><a id="a29002882868350d94a53ef964eddcdbea370be05a6e6dc866854719387984ab6f"></a>SW_NEVER&#160;</td><td class="fielddoc"><p>Never call rt_error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a29002882868350d94a53ef964eddcdbeaeb6866cff0b528dbc9f449804f20cdc6"></a>SW_RTE&#160;</td><td class="fielddoc"><p>Always call rt_error. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7f5f3be8c06b875eff1b6e7501ca8446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5f3be8c06b875eff1b6e7501ca8446">&#9670;&nbsp;</a></span>sync_bool_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a7f5f3be8c06b875eff1b6e7501ca8446">sync_bool_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Startup synchronisation bool. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7f5f3be8c06b875eff1b6e7501ca8446a22d97c7711134391b3bc55ddf432e25b"></a>SYNC_NOWAIT&#160;</td><td class="fielddoc"><p>Don't wait. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5f3be8c06b875eff1b6e7501ca8446a18a6fa8889d7501469a972a54da8943c"></a>SYNC_WAIT&#160;</td><td class="fielddoc"><p>Wait for synchronisation. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab6c27ffba6e45118ef6605f899911cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c27ffba6e45118ef6605f899911cf2">&#9670;&nbsp;</a></span>shm_cmd_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#ab6c27ffba6e45118ef6605f899911cf2">shm_cmd_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mailbox commands passed to APs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab6c27ffba6e45118ef6605f899911cf2a365e33483054f2d08201b35faf6ced36"></a>SHM_IDLE&#160;</td><td class="fielddoc"><p>Idle state of mailbox. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c27ffba6e45118ef6605f899911cf2ac6e915c4e758a768bba1d80c69ec1d75"></a>SHM_MSG&#160;</td><td class="fielddoc"><p>Passing SDP message. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c27ffba6e45118ef6605f899911cf2aecb3639fc13f200ea2bd988a07cd754a"></a>SHM_NOP&#160;</td><td class="fielddoc"><p>Does nothing... </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c27ffba6e45118ef6605f899911cf2a1dbdb8b836e3800024971f46dc61205b"></a>SHM_SIGNAL&#160;</td><td class="fielddoc"><p>Signal application. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c27ffba6e45118ef6605f899911cf2aedc5209f9eafcb96717369f76a07f81f"></a>SHM_CMD&#160;</td><td class="fielddoc"><p>Command to MP. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2e4e9fc0acec47f32a5cc3737c894015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4e9fc0acec47f32a5cc3737c894015">&#9670;&nbsp;</a></span>signal_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a2e4e9fc0acec47f32a5cc3737c894015">signal_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals passed to applications. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015ae06d9cbab66716ec34598717c5d973a4"></a>SIG_INIT&#160;</td><td class="fielddoc"><p>Initialise cores. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a59d8d559f6300c81ed69a371bd131766"></a>SIG_PWRDN&#160;</td><td class="fielddoc"><p>Powerdown cores. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a5fb8c6a63805565f9e699c631ac15dfe"></a>SIG_STOP&#160;</td><td class="fielddoc"><p>Stop application and clean up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015aa4538103ce6a6d0e3c5f51b0b9333d51"></a>SIG_START&#160;</td><td class="fielddoc"><p>Start application if waiting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a4ea0ddcd6167372159567acc48950b9a"></a>SIG_SYNC0&#160;</td><td class="fielddoc"><p>Synchronisation barrier 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a2a90faf7dd00f16614bc2c3bd1d957db"></a>SIG_SYNC1&#160;</td><td class="fielddoc"><p>Synchronisation barrier 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a4033030dfc14b878cc7767ad7a53a7f0"></a>SIG_PAUSE&#160;</td><td class="fielddoc"><p>Pause application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a29026413e1d3f85a38f640074e5a0db7"></a>SIG_CONT&#160;</td><td class="fielddoc"><p>Continue application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015ae4eb5890f0cf58b082dd48469a74bd6e"></a>SIG_EXIT&#160;</td><td class="fielddoc"><p>Terminate application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015af24bd1d3addc94ce1c7ec81f8da905c9"></a>SIG_TIMER&#160;</td><td class="fielddoc"><p>Trigger timer for application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a53cc3858df9643ebc82c0b04cc0538ea"></a>SIG_USR0&#160;</td><td class="fielddoc"><p>Send user signal 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a71f5cfd2f4c4b67e88e559b6eb1004d3"></a>SIG_USR1&#160;</td><td class="fielddoc"><p>Send user signal 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a49a650cf8f35bf794982ca44e1af030e"></a>SIG_USR2&#160;</td><td class="fielddoc"><p>Send user signal 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4e9fc0acec47f32a5cc3737c894015a6730124eaaa60ae2ff8858b1036ccf9e"></a>SIG_USR3&#160;</td><td class="fielddoc"><p>Send user signal 3. </p>
</td></tr>
</table>

</div>
</div>
<a id="add51abc04ff5e1d219053f53ce83fa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add51abc04ff5e1d219053f53ce83fa05">&#9670;&nbsp;</a></span>sark_scp_command_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#add51abc04ff5e1d219053f53ce83fa05">sark_scp_command_codes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP command codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a576fb2eb53263319ee51fd4152ff8fcc"></a>CMD_VER&#160;</td><td class="fielddoc"><p>Return version/core info. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a51c06d6ddc76ff994a5aa1d25b71e57f"></a>CMD_RUN&#160;</td><td class="fielddoc"><p>Run at PC (Deprecated) </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a43d7f3a35093d4198124c87b43afdefb"></a>CMD_READ&#160;</td><td class="fielddoc"><p>Read memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a612986a7ae236cab656844222f00ba82"></a>CMD_WRITE&#160;</td><td class="fielddoc"><p>Write memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a3de37de83aeb28145a73805b4f4f5422"></a>CMD_APLX&#160;</td><td class="fielddoc"><p>Run via APLX (Deprecated) </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ac04c56b963737bed98a9765d300e60aa"></a>CMD_FILL&#160;</td><td class="fielddoc"><p>Fill memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a1f6052e4d5cda4eeba5759bec798cd3e"></a>CMD_REMAP&#160;</td><td class="fielddoc"><p>Remap application core. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ac7dc40ac7d7b36b33599a9647741ec3a"></a>CMD_LINK_READ&#160;</td><td class="fielddoc"><p>Read neighbour memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ae1b0881e5b6d1168e83be5ca76b40249"></a>CMD_LINK_WRITE&#160;</td><td class="fielddoc"><p>Write neighbour memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ac200c7f643146c6174a04d70dd7c6765"></a>CMD_AR&#160;</td><td class="fielddoc"><p>Application core reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a9768ff77bcde46195196e6466bc0ab5e"></a>CMD_NNP&#160;</td><td class="fielddoc"><p>Send broadcast NN packet. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a027c8932fc4f1f58d96be1c9d3573348"></a>CMD_SIG&#160;</td><td class="fielddoc"><p>Send signal to apps. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ad11c5b33509ea0f84a1b50666bc0a4ca"></a>CMD_FFD&#160;</td><td class="fielddoc"><p>Send flood-fill data. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05aab54e60c11c527ae91bb806c0806a7f6"></a>CMD_AS&#160;</td><td class="fielddoc"><p>Application core APLX start. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a41754a0808533384d7667e0c7c70bb28"></a>CMD_LED&#160;</td><td class="fielddoc"><p>Control LEDs. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05ae15692462fd93686a1e4c99d2eaea246"></a>CMD_IPTAG&#160;</td><td class="fielddoc"><p>Configure IPTags. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a2cbdb534568d4ce50ae876dd98165dfb"></a>CMD_SROM&#160;</td><td class="fielddoc"><p>Read/write/erase serial ROM. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05aa1aeafde66020145ebd8c2cb24b522b8"></a>CMD_ALLOC&#160;</td><td class="fielddoc"><p>Memory allocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05adee488b16055c349f995c986587bbe26"></a>CMD_RTR&#160;</td><td class="fielddoc"><p>Router control. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05a6b1ac29fd084fc49f7c5c5e80130614b"></a>CMD_INFO&#160;</td><td class="fielddoc"><p>Get chip/core info. </p>
</td></tr>
<tr><td class="fieldname"><a id="add51abc04ff5e1d219053f53ce83fa05afa121c234cf98fbef4bcf6da8a690c78"></a>CMD_TUBE&#160;</td><td class="fielddoc"><p>Tube output. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5dd23bc996e5f56e5f45964dc4e3fff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd23bc996e5f56e5f45964dc4e3fff0">&#9670;&nbsp;</a></span>sark_scp_return_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a5dd23bc996e5f56e5f45964dc4e3fff0">sark_scp_return_codes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP return codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ab834a5bb2ce6d97c2831fe3d71103c14"></a>RC_OK&#160;</td><td class="fielddoc"><p>Command completed OK. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ad6508f5b7837bba3ce27c3543b33a704"></a>RC_LEN&#160;</td><td class="fielddoc"><p>Bad packet length. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a83a9fda8ab6c52397676f85531a86348"></a>RC_SUM&#160;</td><td class="fielddoc"><p>Bad checksum. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a0f674dd3b0ad65f7afedd83a5b9c7416"></a>RC_CMD&#160;</td><td class="fielddoc"><p>Bad/invalid command. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a71a503467fc752c1a4e5e85917c840df"></a>RC_ARG&#160;</td><td class="fielddoc"><p>Invalid arguments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ace382a22765636da1bf2fc60fc541da5"></a>RC_PORT&#160;</td><td class="fielddoc"><p>Bad port number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a6aa8355501388bd7a58471d19e70cfb6"></a>RC_TIMEOUT&#160;</td><td class="fielddoc"><p>Timeout. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a7d7f9289cf848b83eec0d37b7d0fbeb5"></a>RC_ROUTE&#160;</td><td class="fielddoc"><p>No P2P route. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ab135f1136713a6f55b3dd46f44b992bc"></a>RC_CPU&#160;</td><td class="fielddoc"><p>Bad CPU number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a7f57ddeaf846172d6ec6d1399e5417e7"></a>RC_DEAD&#160;</td><td class="fielddoc"><p>SHM dest dead. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a8ca11e666cfc90593029e15c0b2e1748"></a>RC_BUF&#160;</td><td class="fielddoc"><p>No free SHM buffers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a0ddc10648826626c3262a569627d0596"></a>RC_P2P_NOREPLY&#160;</td><td class="fielddoc"><p>No reply to open. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ace376f8bd2c08995e08dccabbe83c883"></a>RC_P2P_REJECT&#160;</td><td class="fielddoc"><p>Open rejected. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0ab97e74175c024de2876bcd9ac41d4c0a"></a>RC_P2P_BUSY&#160;</td><td class="fielddoc"><p>Dest busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0aa7dc80dad0b678969118ec0410c475d9"></a>RC_P2P_TIMEOUT&#160;</td><td class="fielddoc"><p>Dest died? </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dd23bc996e5f56e5f45964dc4e3fff0a93c187db9e33ca37865ba1e5cfbaff3a"></a>RC_PKT_TX&#160;</td><td class="fielddoc"><p>Pkt Tx failed. </p>
</td></tr>
</table>

</div>
</div>
<a id="a61d3deefebff466d46ecda52171bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d3deefebff466d46ecda52171bd47d">&#9670;&nbsp;</a></span>sark_scp_memory_size_types</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sark_8h.html#a61d3deefebff466d46ecda52171bd47d">sark_scp_memory_size_types</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory size types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a61d3deefebff466d46ecda52171bd47da66aba953e1da3345bc207065c05c28d8"></a>TYPE_BYTE&#160;</td><td class="fielddoc"><p>Specifies byte access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a61d3deefebff466d46ecda52171bd47da793a9db18e0c2fd7a6b519c6453026d4"></a>TYPE_HALF&#160;</td><td class="fielddoc"><p>Specifies short (16-bit) access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a61d3deefebff466d46ecda52171bd47dadcd42ea06b0d39bc3f09e2a6abf0b5f1"></a>TYPE_WORD&#160;</td><td class="fielddoc"><p>Specifies word (32-bit) access. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a082cf1e7488833e20c56430f4dc6667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082cf1e7488833e20c56430f4dc6667c">&#9670;&nbsp;</a></span>cpu_irq_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_irq_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the IRQ interrupt in the core by clearing the appropriate bit in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored.</p>
<p>(Unlikely to be needed by application code) </p><dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="ab088513d34540c8ad53a67deb34e6f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab088513d34540c8ad53a67deb34e6f7a">&#9670;&nbsp;</a></span>cpu_irq_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_irq_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the IRQ interrupt in the core by setting the appropriate bit in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored. </p><dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="ad65dc08d0addbd5e56abc418252de701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65dc08d0addbd5e56abc418252de701">&#9670;&nbsp;</a></span>cpu_fiq_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_fiq_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the FIQ interrupt in the core by clearing the appropriate bit in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored.</p>
<p>(Unlikely to be needed by application code). </p><dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="a7d3c1edeca108523719403b2f9b0772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3c1edeca108523719403b2f9b0772e">&#9670;&nbsp;</a></span>cpu_fiq_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_fiq_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the FIQ interrupt in the core by setting the appropriate bit in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored. </p><dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="a066ce48b9e8823e9535c533ce68a5147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066ce48b9e8823e9535c533ce68a5147">&#9670;&nbsp;</a></span>cpu_int_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_int_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the FIQ and IRQ interrupts in the core by clearing the appropriate bits in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored.</p>
<p>(Unlikely to be needed by application code).</p>
<dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="a14ef80db94e3bc22ed0c13951c5b777f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ef80db94e3bc22ed0c13951c5b777f">&#9670;&nbsp;</a></span>cpu_int_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_int_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the FIQ and IRQ interrupts in the core by setting the appropriate bits in the CPSR. </p>
<p>Returns the previous CPSR so that the state prior to the call can be restored.</p>
<dl class="section return"><dt>Returns</dt><dd>previous state of CPSR </dd></dl>

</div>
</div>
<a id="a475a13902c8055eb6aea178f8be3c6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475a13902c8055eb6aea178f8be3c6bb">&#9670;&nbsp;</a></span>cpu_int_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_int_restore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>cpsr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the CPSR to the state provided in the argument. </p>
<p>Generally used after a call to <a class="el" href="sark_8h.html#a7d3c1edeca108523719403b2f9b0772e" title="Disable the FIQ interrupt in the core by setting the appropriate bit in the CPSR.">cpu_fiq_disable()</a>, <a class="el" href="sark_8h.html#ab088513d34540c8ad53a67deb34e6f7a" title="Disable the IRQ interrupt in the core by setting the appropriate bit in the CPSR.">cpu_irq_disable()</a>, or <a class="el" href="sark_8h.html#a14ef80db94e3bc22ed0c13951c5b777f" title="Disable the FIQ and IRQ interrupts in the core by setting the appropriate bits in the CPSR.">cpu_int_disable()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpsr</td><td>value to be restored to CPSR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22e95f32619aef5e01d518e529b70ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e95f32619aef5e01d518e529b70ce9">&#9670;&nbsp;</a></span>cpu_get_sp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* cpu_get_sp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the core's stack pointer. </p>
<p>(Unlikely to be needed by application code).</p>
<dl class="section return"><dt>Returns</dt><dd>current SP value </dd></dl>

</div>
</div>
<a id="a2dd4568f06db076d687fa3f4435becc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd4568f06db076d687fa3f4435becc4">&#9670;&nbsp;</a></span>cpu_get_cpsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_get_cpsr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the core's CPSR. </p>
<p>(Unlikely to be needed by application code).</p>
<dl class="section return"><dt>Returns</dt><dd>current CPSR value </dd></dl>

</div>
</div>
<a id="a856899694c28cdf55a40931ef6bbdb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856899694c28cdf55a40931ef6bbdb12">&#9670;&nbsp;</a></span>cpu_set_cpsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_set_cpsr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>cpsr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the core's CPSR to the supplied value. </p>
<p>This routine always returns to the caller even if the mode changes as a result of the new CPSR value.</p>
<p>(Unlikely to be needed by application code) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpsr</td><td>new value of the CPSR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74c64301dd0a88a9c2c6fd2c28234be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c64301dd0a88a9c2c6fd2c28234be2">&#9670;&nbsp;</a></span>cpu_get_cp15_cr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cpu_get_cp15_cr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the core's CP15 Control register. </p>
<p>(Unlikely to be needed by application code) </p><dl class="section return"><dt>Returns</dt><dd>current CP15 control register value </dd></dl>

</div>
</div>
<a id="aed1c1643cd51f2e97e26d582e53cc159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1c1643cd51f2e97e26d582e53cc159">&#9670;&nbsp;</a></span>cpu_set_cp15_cr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_set_cp15_cr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the core's CP15 Control Register to the supplied value. </p>
<p>(Unlikely to be needed by application code) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>new value of the CP15 control register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96973cac0a4eb45f83b30785b8fc77ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96973cac0a4eb45f83b30785b8fc77ca">&#9670;&nbsp;</a></span>cpu_wfi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_wfi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the core into sleep mode until an interrupt occurs at which point the function will return. </p>
<p>Works regardless of whether interrupts are masked in the core or not but relies on the VIC passing the interrupt to the core so won't work if all interrupts are masked by the VIC. </p>

</div>
</div>
<a id="a0756562c562df4adb431af181f867711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0756562c562df4adb431af181f867711">&#9670;&nbsp;</a></span>cpu_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the core into sleep mode until an interrupt occurs at which point the interrupt will be serviced and the core will go back to sleep. </p>
<p>This means that the core will respond to interrupts but the function never returns. </p>

</div>
</div>
<a id="a4e5a88149045cde1e775328022b35d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5a88149045cde1e775328022b35d9d">&#9670;&nbsp;</a></span>cpu_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the core into sleep mode and disable all interrupts in the VIC. </p>
<p>This means that the core sleeps and cannot be woken up. Usually used when a fatal error has occurred. Application code will probably want to call <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> on a fatal error. </p>

</div>
</div>
<a id="abe2018e60bb35fb629cdbb057368a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2018e60bb35fb629cdbb057368a2f4">&#9670;&nbsp;</a></span>rt_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called to signal a fatal error. </p>
<p>The error code argument is placed in a known place in the VCPU block for this core as is a dump of r0-r7, lr, sp and cpsr. Optional arguments will end up in the register dump as r1, r2, etc. Calls <a class="el" href="sark_8h.html#a4e5a88149045cde1e775328022b35d9d" title="Puts the core into sleep mode and disable all interrupts in the VIC.">cpu_shutdown()</a> when all relevant state has been dumped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>an error code (usually from enum rte_code_e) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">...</td><td>further (integer) arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cbb47391ebe5563f3d43a343cb03f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbb47391ebe5563f3d43a343cb03f51">&#9670;&nbsp;</a></span>sark_mem_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_mem_cpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy <code>n</code> bytes of memory from <code>src</code> to <code>dest</code>. </p>
<p>The memory is copied byte by byte and so will be inefficient for large values of <code>n</code>. Not intended for use where source and destination blocks overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad58e22edc7b04c1a8ed25d7ada9f46f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58e22edc7b04c1a8ed25d7ada9f46f5">&#9670;&nbsp;</a></span>sark_str_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_str_cpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a NULL terminated string from <code>src</code> to <code>dest</code>. </p>
<p>The string is copied byte by byte and so will be inefficient for long strings. Not intended for use where source and destination strings overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>destination string address; must be enough space available </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source string address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef96491568c6a6468cb4d35d1d18d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef96491568c6a6468cb4d35d1d18d07">&#9670;&nbsp;</a></span>sark_str_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_str_len </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters in a zero terminated string. </p>
<p>The terminator is not included in the count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>zero terminated string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters </dd></dl>

</div>
</div>
<a id="a8c3cb686bab55b58b206f7f13b7ecafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3cb686bab55b58b206f7f13b7ecafa">&#9670;&nbsp;</a></span>sark_cpu_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_cpu_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a6cda0afbb13c1566fcf78c2bbd746a98">cpu_state</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CPU state field in the VCPU block for this core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac420f512079b7df88c0da0aae266cd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420f512079b7df88c0da0aae266cd5b">&#9670;&nbsp;</a></span>sark_msg_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_msg_cpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies an SDP message from one buffer to another. </p>
<p>Quite efficient for long messages as it uses <a class="el" href="sark_8h.html#a9510d06461b092e5e2d4538147ed010e" title="A fast copy for memory buffers.">sark_word_cpy()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>pointer to destination buffer </td></tr>
    <tr><td class="paramname">from</td><td>pointer to source buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9510d06461b092e5e2d4538147ed010e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9510d06461b092e5e2d4538147ed010e">&#9670;&nbsp;</a></span>sark_word_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_word_cpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fast copy for memory buffers. </p>
<p>The byte count "n" will be rounded up to be a multiple of word size before the copy takes place and a whole number of words will be transferred. The inner loop copies 8 words at a time for efficiency. The "src" and "dest" pointers must be word aligned. Not intended for use where source and destination blocks overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes to copy (routine rounds up to multiple of 4) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3f9c1bfb731a51ab1f969e3a45a8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f9c1bfb731a51ab1f969e3a45a8b9">&#9670;&nbsp;</a></span>sark_word_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_word_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fast memory setter for a block of memory. </p>
<p>The byte count "n" must be a multiple of the word size and the destination pointer must be word aligned. The inner loop fills 4 words at a time for efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>word to be used for filling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes to fill (must be multiple of 4) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e7203fdd0bd3f58c51b7f63eb0ebfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7203fdd0bd3f58c51b7f63eb0ebfb9">&#9670;&nbsp;</a></span>sark_lock_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_lock_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a21bcbf0f89b96b8f40e0953419f0d3c8">spin_lock</a>&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires one of the 32 built-in hardware locks provided by the chip. </p>
<p>Disables all interrupts and busy-waits for the lock to become free so must be used carefully. Returns the value of the CPSR at entry so that the interrupt state can be restored by the matching "sark_lock_free" routine. Locks already defined for use by SARK are listed in the enum "sark_lock_e";</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>hardware lock number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPSR at time of call </dd></dl>

</div>
</div>
<a id="a10119efa59b363c6a6a9ac6703220096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10119efa59b363c6a6a9ac6703220096">&#9670;&nbsp;</a></span>sark_lock_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_lock_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>cpsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a21bcbf0f89b96b8f40e0953419f0d3c8">spin_lock</a>&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a previously acquired hardware lock. </p>
<p>The supplied "cpsr" is used to restore the interrupt state that was in place when the lock was acquired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpsr</td><td>CPSR to be reinstated after unlocking </td></tr>
    <tr><td class="paramname">lock</td><td>hardware lock number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7535e9fe6473c492496134dcb378a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7535e9fe6473c492496134dcb378a7">&#9670;&nbsp;</a></span>sark_sema_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_sema_raise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise (increment) an 8-bit semaphore variable which is accessed via a pointer. </p>
<p>A hardware lock is used to gain exclusive access to the variable. Returns the post-increment value. No check is made for overflow from 255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sema</td><td>pointer to semaphore byte (usually in shared memory) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>post-increment value of semaphore </dd></dl>

</div>
</div>
<a id="a34fbeff6ae25da166f9895891da4d585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fbeff6ae25da166f9895891da4d585">&#9670;&nbsp;</a></span>sark_sema_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_sema_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower (decrement) an 8-bit semaphore variable which is accessed via a pointer. </p>
<p>The decrement will only take place on a non-zero variable. A hardware lock is used to gain exclusive access to the variable. Returns the pre-decrement value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sema</td><td>pointer to semaphore byte (usually in shared memory) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pre-decrement value of semaphore </dd></dl>

</div>
</div>
<a id="ad8d3315f83d10fc3071fc74ddc239248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d3315f83d10fc3071fc74ddc239248">&#9670;&nbsp;</a></span>sark_app_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_raise </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise a semaphore associated with the AppID running on this core. </p>
<p>The semaphore is initialised to zero before the application starts. Returns the new value of the semaphore and can be used to determine when all cores running a given application have reached a given point. Also allows a single core to be differentiated from other cores by testing for value 1 returned from this function. Uses sark_sema_raise.</p>
<dl class="section return"><dt>Returns</dt><dd>value of semaphore after raising </dd></dl>

</div>
</div>
<a id="ad0488210f65d863dd3a609c71ae34a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0488210f65d863dd3a609c71ae34a1b">&#9670;&nbsp;</a></span>sark_app_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_lower </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers a semaphore associated with the AppID running on this core. </p>
<p>If all cores running an application raise the semaphore when they start and lower it when they complete this can be used to determine when all cores have started (semaphore equals number of cores) and when all cores have finished (semaphore equals zero). Uses sark_sema_lower.</p>
<dl class="section return"><dt>Returns</dt><dd>value of semaphore before lowering. </dd></dl>

</div>
</div>
<a id="ae711485b0ed4f29a98a08f4476e6c1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae711485b0ed4f29a98a08f4476e6c1ed">&#9670;&nbsp;</a></span>sark_app_sema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_sema </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to get the value of the semaphore associated with the AppID running on this core. </p>
<dl class="section return"><dt>Returns</dt><dd>current value of semaphore. </dd></dl>

</div>
</div>
<a id="a7b765a16adc6f4a88ac9017b9202ba83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b765a16adc6f4a88ac9017b9202ba83">&#9670;&nbsp;</a></span>sark_app_cores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_cores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to get the number of cores on this chip which are running the current application. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cores with same AppID </dd></dl>

</div>
</div>
<a id="affdba350f69ec3d46d9d559571feb0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdba350f69ec3d46d9d559571feb0f6">&#9670;&nbsp;</a></span>sark_app_lead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_lead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the core ID of the lowest numbered core on this chip which is running the current application. </p>
<p>Can be used to identify a single core to do shared initialisation.</p>
<dl class="section return"><dt>Returns</dt><dd>lowest numbered core running this app. </dd></dl>

</div>
</div>
<a id="a1e4b606aff6663055d67d9bae754180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4b606aff6663055d67d9bae754180d">&#9670;&nbsp;</a></span>sark_srand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_srand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seed the random number generator with the supplied value. </p>
<p>The 33rd bit of the random value is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>32-bit value to seed generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d2f834ac2db53f8e42a422916ced870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2f834ac2db53f8e42a422916ced870">&#9670;&nbsp;</a></span>sark_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next 32-bit pseudo-random number in the sequence. </p>
<p>A 33 bit number is maintained internally and the bottom 32 bits returned by this function.</p>
<dl class="section return"><dt>Returns</dt><dd>next random number in sequence </dd></dl>

</div>
</div>
<a id="a527ad9bc03c755cf19b0bd1177d704d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ad9bc03c755cf19b0bd1177d704d3">&#9670;&nbsp;</a></span>sark_div10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structdivmod__t">divmod_t</a> sark_div10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the argument by 10 and return dividend and modulus in a struct of type <a class="el" href="sark_8h.html#structdivmod__t" title="Returned (div, mod) from divmod()">divmod_t</a> which has fields "div" and "mod". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number to divide by 10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="sark_8h.html#structdivmod__t" title="Returned (div, mod) from divmod()">divmod_t</a> containing dividend and modulus </dd></dl>

</div>
</div>
<a id="a2899892c855c4e5260c0b59086ad3866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2899892c855c4e5260c0b59086ad3866">&#9670;&nbsp;</a></span>sark_count_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_count_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of bits set in a word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>whose bits are to be counted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bits set </dd></dl>

</div>
</div>
<a id="a33e93143297356f647563cd10400a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e93143297356f647563cd10400a2a0">&#9670;&nbsp;</a></span>sark_bx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_bx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an ARM BX instruction to the address in <code>addr</code>. </p>
<p>Can be used to branch to arbitrary pieces of code.</p>
<p>Dangerous** and unlikely to be useful to most applications!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address to branch to (bottom bit to be set for Thumb) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeae6d5b8f962fb2c1dfb1ac1c39f0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeae6d5b8f962fb2c1dfb1ac1c39f0c1">&#9670;&nbsp;</a></span>sark_aplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_aplx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to unpack an APLX table whose address is provided. </p>
<p>Where this results in the loading and execution of a new application, the second argument is the AppID.</p>
<p>(Unlikely to be needed by application code)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>pointer to an APLX table </td></tr>
    <tr><td class="paramname">app_id</td><td>AppID to be passed to new application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01d9f9030e4539662cad6650b6694fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d9f9030e4539662cad6650b6694fb7">&#9670;&nbsp;</a></span>cpu_init_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* cpu_init_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up stack for a given CPU mode. </p>
<p>Changes to the given mode, sets stack pointer then returns to original mode. Also computes base of stack which will probably be the top of an adjacent stack.</p>
<p>(Unlikely to be needed by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>top of stack for given mode </td></tr>
    <tr><td class="paramname">mode</td><td>mode for which stack applies </td></tr>
    <tr><td class="paramname">size</td><td>size of stack in words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base of stack (ie stack - size) </dd></dl>

</div>
</div>
<a id="a13db093995345a88674c13e7906d4ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13db093995345a88674c13e7906d4ca3">&#9670;&nbsp;</a></span>chksum_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> chksum_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute 4-bit ones-complement checksum of a 64-bit quantity. (Unlikely to be needed by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>low 32 bits of value to be summed </td></tr>
    <tr><td class="paramname">b</td><td>high 32 bits of value to be summed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4-bit checksum in bits 31:28 - other bits zero </dd></dl>

</div>
</div>
<a id="ae6249db4a87d742ba896db808317dea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6249db4a87d742ba896db808317dea2">&#9670;&nbsp;</a></span>chksum_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> chksum_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 4-bit ones-complement checksum of a 32-bit quantity. </p>
<p>(Unlikely to be needed by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value to be summed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4-bit checksum in bits 31:28 - other bits zero </dd></dl>

</div>
</div>
<a id="aa10c5c53ee9f467e3aad6e1a054cc466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10c5c53ee9f467e3aad6e1a054cc466">&#9670;&nbsp;</a></span>sark_chip_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_chip_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of this chip as a 16-bit number. </p>
<p>The upper 8 bits are the X coordinate of the chip and the lower 8 bits are the Y coordinate. Just a wrapper to return sv-&gt;p2p_addr. </p><dl class="section return"><dt>Returns</dt><dd>chip ID ((X &lt;&lt; 8) + Y) </dd></dl>

</div>
</div>
<a id="a57fab81f030fe93ea4f247f2d27f1e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fab81f030fe93ea4f247f2d27f1e53">&#9670;&nbsp;</a></span>sark_core_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_core_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the virtual core number of this core. </p>
<p>This is in the range 0 to 17 (though 0 will only be returned on the core which hosts the monitor processor). Just a wrapper to return sark.virt_cpu. </p><dl class="section return"><dt>Returns</dt><dd>core number in the range 0..17 </dd></dl>

</div>
</div>
<a id="a5a95df8505e42ee47d56f3bb752a8ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a95df8505e42ee47d56f3bb752a8ddc">&#9670;&nbsp;</a></span>sark_app_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of the application running on this core. </p>
<p>Just a wrapper to return sark_vec-&gt;app_id.</p>
<dl class="section return"><dt>Returns</dt><dd>application ID in the range 0..255 </dd></dl>

</div>
</div>
<a id="a4bef6fbe3bbf6c0b489a2435768d6703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bef6fbe3bbf6c0b489a2435768d6703">&#9670;&nbsp;</a></span>sark_app_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* sark_app_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the name of the application running on this core. </p>
<p>Implemented as an inline.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to application name </dd></dl>

</div>
</div>
<a id="ab3ab790eb60f2c24aa9b20fff884e64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ab790eb60f2c24aa9b20fff884e64b">&#9670;&nbsp;</a></span>sark_msg_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a>* sark_msg_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an SDP message buffer from the pool maintained by SARK. </p>
<p>Applications typically have 4 buffers in the pool though this can be changed by setting sark_vec-&gt;num_msgs in sark_config. If there are no free buffers available, NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to SDP buffer (or NULL) </dd></dl>

</div>
</div>
<a id="a8b6bbbfa956f793ea41c8702879cffbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6bbbfa956f793ea41c8702879cffbd">&#9670;&nbsp;</a></span>sark_msg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_msg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an SDP message buffer which was acquired by <a class="el" href="sark_8h.html#ab3ab790eb60f2c24aa9b20fff884e64b" title="Get an SDP message buffer from the pool maintained by SARK.">sark_msg_get()</a> to the free buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to SDP message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e20f66a6e7058940cdbfdd077fbcdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e20f66a6e7058940cdbfdd077fbcdc4">&#9670;&nbsp;</a></span>sark_msg_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_msg_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an SDP message. </p>
<p>The message is sent to the monitor processor using a shared memory buffer and then sent to the appropriate place from there. A timeout in milliseconds must be supplied which applies to the transfer of the message to the monitor processor. Normally this will take less than 1ms if the monitor processor is functioning normally. A timeout of 10ms is probably appropriate in most circumstances. The call can fail either because of a timeout or if there are no shared memory SDP buffers available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to an SDP message buffer </td></tr>
    <tr><td class="paramname">timeout</td><td>time in ms before sending is abandoned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 for failure </dd></dl>

</div>
</div>
<a id="a163a54c093dfe7ad72239509b663fdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163a54c093dfe7ad72239509b663fdcb">&#9670;&nbsp;</a></span>sark_delay_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_delay_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a busy-wait for the given number of microseconds. </p>
<p>The core will continue to service interrupts while the delay takes place but this is otherwise a wasteful way to delay for long periods of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>number of microseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82adc6677b15f452e59063cf4a8f2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82adc6677b15f452e59063cf4a8f2f0">&#9670;&nbsp;</a></span>sw_error_fl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw_error_fl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a2e9a700a97ff6b66bbc29d74a8ca5898">sw_err_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a software error, logging the filename and line number at which the error occurs. </p>
<p>Usually used via the <a class="el" href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2" title="sw_error calls sw_error_fl(), inserting file name and line number automatically">sw_error</a> macro which inserts the filename and line number automatically. The mode parameter determines whether or not rt_error should be called to shut down the core. mode can be SW_RTE to always call <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a>, SW_NEVER to always return or SW_OPT which consults sark.sw_rte to choose what to do.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>determines if <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> is called </td></tr>
    <tr><td class="paramname">file</td><td>file name </td></tr>
    <tr><td class="paramname">line</td><td>line number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a6d37b96c4cd0339de66851e9852e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6d37b96c4cd0339de66851e9852e1">&#9670;&nbsp;</a></span>sark_cmd_ver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_ver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Version command. </p>
<p>Copies various pieces of information into the supplied SDP message buffer. The information copied is the chip address (16 bits), virtual and physical core numbers (8 bits each), the version number of SARK (16 bits), the size of SDP message data buffers (16 bits) and the Unix time at which the application was built (32 bits). A text string is also returned which gives the base kernel name (eg SARK) and the system on which it is running (eg SpiNNaker).</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>SDP message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message </dd></dl>

</div>
</div>
<a id="a05105db095cf54052c1e00cb2d03424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05105db095cf54052c1e00cb2d03424b">&#9670;&nbsp;</a></span>sark_cmd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Read command which reads memory and returns the data read to the host. </p>
<p>Various argument errors are trapped but if successful, data is transferred from memory into the SDP message starting at msg-&gt;arg1. If half or word alignment is specified, the address and count must be 2 or 4 byte aligned.</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message: <code>msg-&gt;arg1</code>: first address to be read (suitably aligned) <code>msg-&gt;arg2</code>: number of bytes to read (suitably aligned) <code>msg-&gt;arg3</code>: mode of reading (TYPE_BYTE, TYPE_HALF or TYPE_WORD)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message </dd></dl>

</div>
</div>
<a id="a214cec2f71f5dc818d88c0abc398fe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214cec2f71f5dc818d88c0abc398fe29">&#9670;&nbsp;</a></span>sark_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Write command which writes memory with data supplied by the host. </p>
<p>Various argument errors are trapped but if successful, data is transferred to memory from the SDP message starting at msg-&gt;data. If half or word alignment is specified, the address and count must be 2 or 4 byte aligned.</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message: <code>msg-&gt;arg1</code>: first address to be written (suitably aligned) <code>msg-&gt;arg2</code>: number of bytes to write (suitably aligned) <code>msg-&gt;arg3</code>: mode of writing (TYPE_BYTE, TYPE_HALF or TYPE_WORD) <code>msg-&gt;data</code>: data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message (usually 0) </dd></dl>

</div>
</div>
<a id="af67d477747aa6b62a2448590a7f4ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d477747aa6b62a2448590a7f4ed2d">&#9670;&nbsp;</a></span>sark_cmd_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Fill command which fills memory with a data word. </p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message <code>msg-&gt;arg1</code>: first address to be written (must be word aligned) <code>msg-&gt;arg2</code>: data word <code>msg-&gt;arg3</code>: byte count (must be non-zero and a multiple of 4)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message (usually 0) </dd></dl>

</div>
</div>
<a id="a05a451a1b870252451ae5661990db041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a451a1b870252451ae5661990db041">&#9670;&nbsp;</a></span>sark_block_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sark_block_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a memory buffer into a linked list of "count" blocks of "size" bytes. </p>
<p><code>size</code> needs to be at least 4 and a multiple of 4 and the memory buffer needs to be at least <code>size * count" bytes</code>. The first word of each block is a pointer to the next block. Returns a pointer to the last block. The buffer can be used to initialise a "root" struct of type <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>base address of memory buffer (word aligned) </td></tr>
    <tr><td class="paramname">size</td><td>of each block (at least 4 and a multiple of 4) </td></tr>
    <tr><td class="paramname">count</td><td>number of blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to last block </dd></dl>

</div>
</div>
<a id="a93d1de5c5e2f2a1607c05eb6f024a183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d1de5c5e2f2a1607c05eb6f024a183">&#9670;&nbsp;</a></span>sark_block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sark_block_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic call to get a buffer from a pool whose "root" is supplied. </p>
<p>Returns pointer to buffer on success, NULL on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>pointer to a block pool held in a <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a free block if available or NULL if not </dd></dl>

</div>
</div>
<a id="a3d40f5611a6a76a083d0751d2ffcebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d40f5611a6a76a083d0751d2ffcebc3">&#9670;&nbsp;</a></span>sark_block_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic call to free a buffer into a pool whose "root" is supplied. </p>
<p>The block should have been allocated from the same pool previously!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>pointer to a block pool held in a <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a> </td></tr>
    <tr><td class="paramname">blk</td><td>pointer to the block to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bdfaf0e7bfe553bcafc6d04bf321bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdfaf0e7bfe553bcafc6d04bf321bf1">&#9670;&nbsp;</a></span>sark_shmsg_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a>* sark_shmsg_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a free SDP message from the shared SysRAM pool. </p>
<p>Returns pointer to message on success, NULL on failure. Because several cores may attempt to access a shared memory message concurrently, a hardware lock is used to ensure exclusive access. Interrupts are turned off while this occurs but this should be for a relatively short time (1-5us ??)</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a shared memory SDP message or NULL if none available </dd></dl>

</div>
</div>
<a id="a69f3c808f1b7045354a386c2bd2872df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f3c808f1b7045354a386c2bd2872df">&#9670;&nbsp;</a></span>sark_shmsg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_shmsg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a shared memory SDP message to the shared SysRAM pool. </p>
<p>Because several cores may attempt to access a shared memory message concurrently, a hardware lock is used to ensure exclusive access. Interrupts are turned off while this occurs but this should be for a relatively short time (1-5us ??)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2885d11fa603c565e9084ffffc3fe557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2885d11fa603c565e9084ffffc3fe557">&#9670;&nbsp;</a></span>sark_call_cpp_constructors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_call_cpp_constructors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the constructors for any C++ objects created at global scope. </p>
<p>Should generally be called from any user-supplied <a class="el" href="sark__base_8c.html#a34ed2549430ecaaa7a6972ad7fb79434" title="Basic setup before calling c_main().">sark_pre_main()</a> function </p>

</div>
</div>
<a id="a24e7b80208352d98dec4cbed92522afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e7b80208352d98dec4cbed92522afe">&#9670;&nbsp;</a></span>io_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void io_printf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple "printf" routine. </p>
<p>The first argument is a 'stream' which is either a constant (<a class="el" href="sark_8h.html#a9ef82c62bd8ba080a719f3daeff6dcfa" title="SDRAM buffer (normal for running apps)">IO_BUF</a>, <a class="el" href="sark_8h.html#abf839f1e83698e15b6eec7ff83b6e35e" title="Direct I/O via SDP.">IO_STD</a>, <a class="el" href="sark_8h.html#ae07ae92a99e4f6d39dfd0d1cabce34da" title="Low-level debug I/O.">IO_DBG</a>, <a class="el" href="sark_8h.html#aae50cb72f8e2d59f8da0a102900ce015" title="Output &gt; /dev/null">IO_NULL</a>) or a pointer to a character array which will be filled in as in "sprintf". No checks for buffer overflow are made for this latter case! The range of formats is very limited to minimise code size. The maximum width for integer fields is 16.The maximum width for the 16.16 fixed point format is 25. Don't exceed these maxima!</p>
<p>The four constants provide 4 possible output streams for the output string. IO_STD will send the string as an SDP packet back to the host. IO_BUF will place the string in a buffer in SDRAM while IO_NULL will ignore the string. IO_DBG is not currently implemented.</p>
<p>Formats are:</p><ul>
<li><code>%c</code> - character</li>
<li><code>%s</code> - string - can be eg <code>%8s</code> for right justification</li>
<li><code>%d</code> - signed integer (also <code>%8d</code>, <code>%06d</code>, etc)</li>
<li><code>%u</code> - signed integer (also <code>%4u</code>, <code>%06u</code>, etc)</li>
<li><code>%x</code> - integer in hex (also <code>%4x</code>, <code>%08x</code>, etc)</li>
<li><code>%z</code> - integer in hex, exactly <em>N</em> digits</li>
<li><code>%n.mf</code> - 16.16 fixed point with width <em>n</em>, precision <em>m</em></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>constant (<a class="el" href="sark_8h.html#a9ef82c62bd8ba080a719f3daeff6dcfa" title="SDRAM buffer (normal for running apps)">IO_BUF</a>, <a class="el" href="sark_8h.html#abf839f1e83698e15b6eec7ff83b6e35e" title="Direct I/O via SDP.">IO_STD</a>, <a class="el" href="sark_8h.html#ae07ae92a99e4f6d39dfd0d1cabce34da" title="Low-level debug I/O.">IO_DBG</a>, <a class="el" href="sark_8h.html#aae50cb72f8e2d59f8da0a102900ce015" title="Output &gt; /dev/null">IO_NULL</a>) or pointer to char array </td></tr>
    <tr><td class="paramname">format</td><td>a format string </td></tr>
    <tr><td class="paramname">...</td><td>arguments to be formatted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3d6e0b4f6796acf8fb2dc494453598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d6e0b4f6796acf8fb2dc494453598f">&#9670;&nbsp;</a></span>io_put_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void io_put_char </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to put a character to an output stream. </p>
<p>Has different behaviour for four possible streams:</p>
<ul>
<li><a class="el" href="sark_8h.html#abf839f1e83698e15b6eec7ff83b6e35e" title="Direct I/O via SDP.">IO_STD</a>: Streamed out to a <code>tubotron</code> instance via SDP.</li>
<li><a class="el" href="sark_8h.html#a9ef82c62bd8ba080a719f3daeff6dcfa" title="SDRAM buffer (normal for running apps)">IO_BUF</a>: Stored in a buffer in memory for later retrieval by host</li>
<li><a class="el" href="sark_8h.html#aae50cb72f8e2d59f8da0a102900ce015" title="Output &gt; /dev/null">IO_NULL</a>: Ignores the write</li>
<li>"sprintf" strings: writes into the provided buffer.</li>
</ul>
<p>For <a class="el" href="sark_8h.html#abf839f1e83698e15b6eec7ff83b6e35e" title="Direct I/O via SDP.">IO_STD</a> and <a class="el" href="sark_8h.html#a9ef82c62bd8ba080a719f3daeff6dcfa" title="SDRAM buffer (normal for running apps)">IO_BUF</a> the character is placed in a holding buffer which is flushed on buffer-full or newline or NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>constant (IO_BUF, IO_STD, IO_NULL) or pointer to char array </td></tr>
    <tr><td class="paramname">c</td><td>a character </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe00ab22d6ec00b7fc698270e7be8c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe00ab22d6ec00b7fc698270e7be8c28">&#9670;&nbsp;</a></span>sark_io_buf_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_io_buf_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to reset the IOBUF for the core. </p>
<p>Frees additional allocated IOBUF blocks in the system heap. </p>

</div>
</div>
<a id="a30d1e6e1b258fa76d6412827a1aa4f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d1e6e1b258fa76d6412827a1aa4f15">&#9670;&nbsp;</a></span>sark_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sark_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory of <code>count</code> &times; <code>size</code> bytes from the DTCM heap. Returns either a pointer to the block on success, or NULL on failure. </p>
<p>The total amount of memory available for allocation is around 62KB less all of the static variables used by the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of sub-blocks to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of each sub-block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block or NULL </dd></dl>

</div>
</div>
<a id="a40ce895f48f22b29d2aefc923b38b280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce895f48f22b29d2aefc923b38b280">&#9670;&nbsp;</a></span>sark_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a block of memory which was previously allocated by <a class="el" href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a> (i.e., from the DTCM heap). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to memory block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1f83786e86e8943b1e1a2d8fa68b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1f83786e86e8943b1e1a2d8fa68b85">&#9670;&nbsp;</a></span>sark_xalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sark_xalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from the specified heap. </p>
<p>The block will be tagged with the supplied "tag" which must be &lt;= 255. Returns NULL on failure (not enough memory, bad tag or tag in use).</p>
<p>The flag parameter contains two flags in the bottom two bits. If bit 0 is set (<a class="el" href="sark_8h.html#a170c14469b29096618dd05f78a9414c4" title="Lock this operation.">ALLOC_LOCK</a>), the heap manipulation is done behind a lock with interrupts disabled. If bit 1 is set (<a class="el" href="sark_8h.html#a6ff0a91d1c257f90c16d72e4a48f619a" title="Use supplied AppID.">ALLOC_ID</a>), the block is tagged with the AppID provided in bits 15:8 of the flag, otherwise the AppID of the current application is used.</p>
<p>The 8-bit <code>tag</code> is combined with the AppID and stored in the "free" field while the block is allocated. If the <code>tag</code> is non-zero, the block is only allocated if the tag is not in use. The tag (and AppID) is stored in the "alloc_tag" table while the block is allocated.</p>
<p>If this command is used to allocate for an app-id which isn't the caller's, the user should set <code>sv-&gt;app_data[app_id].clean</code> to 0 for the application concerned. This ensures that the memory will be cleaned up by a stop signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap from which the block should be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of the block in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>8-bit tag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>flags to control locking and AppID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated block or NULL on failure </dd></dl>

</div>
</div>
<a id="ae4289de17bb19977ccbc8b1f680b4a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4289de17bb19977ccbc8b1f680b4a6a">&#9670;&nbsp;</a></span>sark_xfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_xfree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory block in the specified heap. </p>
<p>If the lock bit in the <code>flag</code> parameter is set, the manipulation of the heap is done behind a lock. This will turn interrupts off for some time while the heap is searched. If a NULL pointer (<code>ptr</code>) is passed in, a runtime error will occur. If there is an "alloc_tag" entry associated with the block it is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap to which the free block should be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>a pointer to the memory block to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>bit 0 set if the heap should be locked during free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5197d7e0234aae820a2ddc722aeecbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5197d7e0234aae820a2ddc722aeecbd4">&#9670;&nbsp;</a></span>sark_xfree_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_xfree_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all allocated blocks in the specified heap which are tagged with the given "app_id". </p>
<p>The <code>flag</code> parameter specifies if locking is needed in the <a class="el" href="sark_8h.html#ae4289de17bb19977ccbc8b1f680b4a6a" title="Free a memory block in the specified heap.">sark_xfree()</a> call. Returns the number of blocks freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap from which blocks should be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>the AppID whose block should be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>controls locking of heap transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks freed </dd></dl>

</div>
</div>
<a id="a8e89c52519c74f83f002becac03d9ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89c52519c74f83f002becac03d9ff3">&#9670;&nbsp;</a></span>sark_heap_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_heap_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the supplied heap and return the size of the largest free block (in bytes). </p>
<p>The <code>flag</code> parameter allows the heap to be locked while the search takes place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>controls locking of heap transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of largest block </dd></dl>

</div>
</div>
<a id="ab76688949797930a80f58584467243c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76688949797930a80f58584467243c2">&#9670;&nbsp;</a></span>sark_heap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structheap__t">heap_t</a>* sark_heap_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an area of memory as a heap. </p>
<p>Arguments are (uint) pointers to base and top of the area. Returns a pointer to the heap (same address as the base). Assumes the area is large enough to hold a minimal heap (a zero size heap needs 28 bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>pointer to bottom of heap memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>pointer to top of heap memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to heap </dd></dl>

</div>
</div>
<a id="abb9d9cc3e46a707969eb592b258744e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d9cc3e46a707969eb592b258744e5">&#9670;&nbsp;</a></span>rtr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of entries in the router multicast table (and associate the caller's app_id with this block). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of entries to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of first entry in block on success, zero on failure. </dd></dl>

</div>
</div>
<a id="a2d7bb03f41c2c68ad7fdb944bb23af64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7bb03f41c2c68ad7fdb944bb23af64">&#9670;&nbsp;</a></span>rtr_alloc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of entries in the router multicast table (and associate the supplied app_id with this block). </p>
<p>If this command is used to allocate for an app-id which isn't the caller's, the user should set sv-&gt;app_data[app_id].clean to 0 for the application concerned. This ensures that the memory will be cleaned up by a stop signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of entries to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID associated with block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of first entry in block on success, zero on failure. </dd></dl>

</div>
</div>
<a id="a5cb6e9bbf8425f6fe224833f6239c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb6e9bbf8425f6fe224833f6239c4ba">&#9670;&nbsp;</a></span>rtr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block of MC table entries which starts with the supplied entry. The relevant router registers can be optionally re-initialised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>first entry in the block (as returned by rtr_alloc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear</td><td>non-zero to cause router registers to be re-initialised </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e038cf666dba5f8be35bb8cb8eead45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e038cf666dba5f8be35bb8cb8eead45">&#9670;&nbsp;</a></span>rtr_free_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_free_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all allocated blocks in the router which are tagged with the given "app_id". </p>
<p>The relevant router registers can be optionally re-initialised. Returns number of blocks freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID whose entries are to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear</td><td>non-zero to cause router registers to be re-initialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks freed </dd></dl>

</div>
</div>
<a id="af89de816e4c181b8f24ba21873b24a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89de816e4c181b8f24ba21873b24a27">&#9670;&nbsp;</a></span>rtr_alloc_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc_max </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the largest free block in the router multicast table (or zero if table is full). </p>
<dl class="section return"><dt>Returns</dt><dd>number of entries in largest block </dd></dl>

</div>
</div>
<a id="a226f6ac4ac38c44dce34a617ed1f1aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f6ac4ac38c44dce34a617ed1f1aa6">&#9670;&nbsp;</a></span>sark_tag_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sark_tag_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to a tagged allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the allocation to get a pointer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID whose tagged allocation to read (or 0 to use the current core's app ID) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first allocation found with the given tag, or NULL if no such allocation exists. </dd></dl>

</div>
</div>
<a id="aed572d885f25c88acdc5a11c26e51b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed572d885f25c88acdc5a11c26e51b2c">&#9670;&nbsp;</a></span>sark_vic_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_vic_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a full software initialisation of the VIC. </p>
<p>All interrupts are disabled and all vector entries are initialised to a disabled state. The default handler address is set to point to a return from interrupt instruction. </p>

</div>
</div>
<a id="a8e5523f51f1df77463689f9567c87884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5523f51f1df77463689f9567c87884">&#9670;&nbsp;</a></span>sark_vic_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_vic_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#add2659cdf5414e6ab00bc5c7471a07f8">int_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises one of the VIC slots to set up an interrupt handler. </p>
<p>No check is made that the slot is not already in use. The slot can be SLOT_FIQ in which case the FIQ interrupt is set up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>the slot to be used </td></tr>
    <tr><td class="paramname">interrupt</td><td>the interrupt number (0..31) </td></tr>
    <tr><td class="paramname">enable</td><td>non-zero if the interrupt should be enabled </td></tr>
    <tr><td class="paramname">handler</td><td>pointer to the handler code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7338a87d005d821ee1ef167eda592ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7338a87d005d821ee1ef167eda592ecb">&#9670;&nbsp;</a></span>sark_led_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_led_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the hardware (GPIO port) which drives the LEDs attached to the SpiNNaker chip. </p>
<p>(Unlikely to be used by application code) </p>

</div>
</div>
<a id="a74a3a76206602b65fc8f482d0c9cce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3a76206602b65fc8f482d0c9cce5d">&#9670;&nbsp;</a></span>sark_led_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_led_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>leds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls one or more of the LEDs attached to the SpiNNaker chip. </p>
<p>The argument should be a sum of calls to macros LED_ON, LED_OFF, LED_INV which turn on, turn off or flip a LED. The argument to each macro is the LED number, an integer starting at zero. All SpiNNaker boards to date have at least one LED so <a class="el" href="sark_8h.html#aaa8988d6632fc64b0ec4a8528cebb7fd" title="Turn LED on.">LED_ON(0)</a> will always work!</p>
<p>To turn on LED 1 and turn off LED 2 the call looks like this... </p><div class="fragment"><div class="line"><a class="code" href="sark_8h.html#a74a3a76206602b65fc8f482d0c9cce5d">sark_led_set</a> (<a class="code" href="sark_8h.html#aaa8988d6632fc64b0ec4a8528cebb7fd">LED_ON</a>(1) + <a class="code" href="sark_8h.html#a552169688fe8834a280b877a8cf5020e">LED_OFF</a>(2));</div>
<div class="ttc" id="asark_8h_html_a552169688fe8834a280b877a8cf5020e"><div class="ttname"><a href="sark_8h.html#a552169688fe8834a280b877a8cf5020e">LED_OFF</a></div><div class="ttdeci">#define LED_OFF(n)</div><div class="ttdoc">Turn LED off.</div><div class="ttdef"><b>Definition:</b> sark.h:364</div></div>
<div class="ttc" id="asark_8h_html_a74a3a76206602b65fc8f482d0c9cce5d"><div class="ttname"><a href="sark_8h.html#a74a3a76206602b65fc8f482d0c9cce5d">sark_led_set</a></div><div class="ttdeci">void sark_led_set(uint leds)</div><div class="ttdoc">Controls one or more of the LEDs attached to the SpiNNaker chip.</div><div class="ttdef"><b>Definition:</b> sark_hw.c:147</div></div>
<div class="ttc" id="asark_8h_html_aaa8988d6632fc64b0ec4a8528cebb7fd"><div class="ttname"><a href="sark_8h.html#aaa8988d6632fc64b0ec4a8528cebb7fd">LED_ON</a></div><div class="ttdeci">#define LED_ON(n)</div><div class="ttdoc">Turn LED on.</div><div class="ttdef"><b>Definition:</b> sark.h:363</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leds</td><td>encoded value specifying LEDs and operations thereon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc00e275bcd21290b0ade7caffb3f690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc00e275bcd21290b0ade7caffb3f690">&#9670;&nbsp;</a></span>rtr_mc_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_mc_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a set of the router's multicast (MC) table registers so that routing is disabled. </p>
<p>Because some of the MC hardware registers are not readable, copies of these registers are kept in memory to allow them to be read back. These copies are also initialised here. The entries in the router are disabled by setting route and mask to zero and the key to all ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>first entry to be cleared </td></tr>
    <tr><td class="paramname">count</td><td>number of entries to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if OK, 0 on failure (last entry out of range) </dd></dl>

</div>
</div>
<a id="a151645129faec74d427f2961d4ab9449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151645129faec74d427f2961d4ab9449">&#9670;&nbsp;</a></span>rtr_mc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_mc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the router's multicast (MC) tables and sets up the data structures for allocating router entries. </p>
<p>Because some of the MC hardware registers are not readable, copies of these registers are kept in memory to allow them to be read back. These copies are also initialised here. All entries in the router are disabled (route and mask set to zero and key set to all ones). The start parameter allows some low entries to be left unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>first entry to clear - usually 0 or 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ba7cd3d8b44e6225eec84c46d20a441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba7cd3d8b44e6225eec84c46d20a441">&#9670;&nbsp;</a></span>rtr_mc_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_mc_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load router MC table from a table in memory. </p>
<p>Within the table, which is an array of "rtr_entry_t". the "next" field holds the entry number to be loaded. If the count parameter is zero, the count is taken from the "free" field of the first entry entry in the table. The offset parameter is added to the entry number to address each router table entry. The "app_id" parameter sets the app_id in the router table copy if non-zero. Otherwise it will be taken from SARK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to first entry in table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>size of table (or 0 to use count from table) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>added to entry numbers from table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>sets app_id in table if non-zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 on failure (count or entry out of range) </dd></dl>

</div>
</div>
<a id="a81ca61e30076d1724a68027b63f6e970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ca61e30076d1724a68027b63f6e970">&#9670;&nbsp;</a></span>rtr_mc_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_mc_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a given entry in the router MC table. </p>
<p>The supplied route is based on virtual core numbers and this is mapped into physical core numbers before being written to the router. Copies of all three router registers are also maintained in memory so that they can be read back even though the router hardware doesn't support reading of key and mask registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the router entry number (should be in range 0..1023) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>the mask field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (entry out of range) </dd></dl>

</div>
</div>
<a id="acfe404b27b699071843bb9fbe10a5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe404b27b699071843bb9fbe10a5325">&#9670;&nbsp;</a></span>rtr_mc_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_mc_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structrtr__entry__t">rtr_entry_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a given entry in the router MC table. </p>
<p>The parameter <code>r</code> is a pointer to a <a class="el" href="sark_8h.html#structrtr__entry__t" title="Copy of router entry (16 bytes)">rtr_entry_t</a> structure. The router register fields in the struct are filled in from the RAM copy of the router registers which is maintained by the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>number of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>pointer to <a class="el" href="sark_8h.html#structrtr__entry__t" title="Copy of router entry (16 bytes)">rtr_entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (entry out of range) </dd></dl>

</div>
</div>
<a id="a71b1b5e0a5526750b671ebe436da92f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b1b5e0a5526750b671ebe436da92f3">&#9670;&nbsp;</a></span>rtr_fr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_fr_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fixed-route register in the router. </p>
<p>Only the lower 24 bits are used as the register has bits with another function in its top 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td>fixed-route mask (bottom 24 bits) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab87c4fc234cb78333321bc0acf3b7b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87c4fc234cb78333321bc0acf3b7b75">&#9670;&nbsp;</a></span>rtr_fr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_fr_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fixed-route register from the router and masks off the top 8 bits. </p>
<dl class="section return"><dt>Returns</dt><dd>Value of router FR register (bottom 24 bits only) </dd></dl>

</div>
</div>
<a id="a74ab37d7c02d8246d2b0fdc7670ce5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ab37d7c02d8246d2b0fdc7670ce5fa">&#9670;&nbsp;</a></span>rtr_p2p_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_p2p_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the router point-to-point (P2P) table. </p>
<p>All 64K entries are set to 6. (Unlikely to be used by application code). </p>

</div>
</div>
<a id="a42ab52595bb1286fe7428cad3f2670d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ab52595bb1286fe7428cad3f2670d9">&#9670;&nbsp;</a></span>rtr_p2p_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_p2p_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a P2P table entry. </p>
<p>The value should be in the range 0 to 7. Values from 0 to 5 cause the packet to be routed to one of the external links while 7 causes the packet to be sent to the monitor processor. The value 6 causes the packet to be dropped. (Unlikely to be used by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry number in the range 0..65535 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be written in the range 0..7 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae43c60a896bbc207a45724881f051e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43c60a896bbc207a45724881f051e6a">&#9670;&nbsp;</a></span>rtr_p2p_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_p2p_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a P2P table entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the entry number in the range 0..65535 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table entry (range 0 to 7) </dd></dl>

</div>
</div>
<a id="a4a25c25939b98a0966b1248a52f06f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a25c25939b98a0966b1248a52f06f27">&#9670;&nbsp;</a></span>rtr_diag_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_diag_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the 16 diagnostic registers in the router using the supplied table (which should have 16 entries). </p>
<p>The count registers are first disabled and cleared, the new register values set and and then the counters are enabled. (Unlikely to be used by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>pointer to table of 16 initialisation words </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2550bb97884d308a9cccd5f4791e6de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2550bb97884d308a9cccd5f4791e6de8">&#9670;&nbsp;</a></span>rtr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a full initialisation of the router. </p>
<p>Calls <a class="el" href="sark_8h.html#a151645129faec74d427f2961d4ab9449" title="Initialises the router&#39;s multicast (MC) tables and sets up the data structures for allocating router ...">rtr_mc_init()</a>, <a class="el" href="sark_8h.html#a74ab37d7c02d8246d2b0fdc7670ce5fa" title="Initialise the router point-to-point (P2P) table.">rtr_p2p_init()</a> and <a class="el" href="sark_8h.html#a4a25c25939b98a0966b1248a52f06f27" title="Initialises the 16 diagnostic registers in the router using the supplied table (which should have 16 ...">rtr_diag_init()</a> and also sets the router control register. The control register Wait1 field is set to 0x40 and the Wait2 field is set to 0x00. The initialisation of the diagnostic registers places 'useful' values in 12 of the registers and leaves 4 (numbers 12 to 15) free for applications. (Unlikely to be used by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>physical core ID of monitor processor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28c92abd55df0daf0b4b05284277c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c92abd55df0daf0b4b05284277c8b8">&#9670;&nbsp;</a></span>v2p_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> v2p_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>virt_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bit mask of virtual core IDs, returns a mask of the corresponding physical core IDs. </p>
<p>(Unlikely to be used by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt_mask</td><td>virtual core bit mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical core bit mask </dd></dl>

</div>
</div>
<a id="a5bfda3e690ab2344e88f6e8934e2edd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfda3e690ab2344e88f6e8934e2edd4">&#9670;&nbsp;</a></span>pl340_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pl340_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mem_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the PL340 memory controller. </p>
<p>(<em>Extremely</em> unlikely to be used by application code.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_clk</td><td>memory clock speed in MHz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, 1 on success </dd></dl>

</div>
</div>
<a id="a06ace566279f8f98e6bf001dee74eeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ace566279f8f98e6bf001dee74eeab">&#9670;&nbsp;</a></span>event_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> event_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create additional free events by calling <a class="el" href="sark_8h.html#a30d1e6e1b258fa76d6412827a1aa4f15" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a>. </p>
<p>Caller specifies number of events to allocate and they will be added to the existing free queue. Returns 1 on success, 0 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>number of new events to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, 1 otherwise </dd></dl>

</div>
</div>
<a id="a05a1933cd3173bcfe01e10150532b933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a1933cd3173bcfe01e10150532b933">&#9670;&nbsp;</a></span>event_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a previously allocated event. </p>
<p>The event <em>must not</em> have been scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the event to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3dc841f217092d14cd043929c4ef5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc841f217092d14cd043929c4ef5a0">&#9670;&nbsp;</a></span>event_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structevent__t">event_t</a>* event_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new event from the free queue and intialise "proc", "arg1" and "arg2" fields. </p>
<p>The "ID", "next" and "time" fields are also set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proc</td><td>pointer to an event_proc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg1</td><td>argument 1 to the event_proc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg2</td><td>argument 2 to the event_proc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to event if successful, NULL otherwise </dd></dl>

</div>
</div>
<a id="a28d6272010636e23c96102c17baa13b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d6272010636e23c96102c17baa13b6">&#9670;&nbsp;</a></span>event_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a (reusable) event that has already been allocated. </p>
<p>Configure fields "proc", "arg1" and "arg2" from the parameters. Fields "next" and "time" are set to default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>pointer to an event (to be configured) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proc</td><td>pointer to an event_proc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg1</td><td>argument 1 to the event_proc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg2</td><td>argument 2 to the event_proc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5950f6444f3c7afd3e6cdefec311a19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5950f6444f3c7afd3e6cdefec311a19d">&#9670;&nbsp;</a></span>pkt_tx_k()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pkt_tx_k </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a packet which contains only a key. </p>
<p>The packet is placed on a transmit queue and sent when it reaches the head of the queue. The transmit control register (TCR) which controls the type of packet which is sent is not modified by this routine so the previous value will be used. The routine pkt_register must be called (once) before any of the pkt_tx_XXX routines are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key field to be placed in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the transmit queue is full, 1 otherwise </dd></dl>

</div>
</div>
<a id="a5c544176d5d81edfa1485b5ae2e0d20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c544176d5d81edfa1485b5ae2e0d20f">&#9670;&nbsp;</a></span>pkt_tx_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pkt_tx_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a packet which contains key and data fields. </p>
<p>The packet is placed on a transmit queue and sent when it reaches the head of the queue. The transmit control register (TCR) which controls the type of packet which is sent is not modified by this routine so the previous value will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key;</td><td>the key field to be placed in the packet </td></tr>
    <tr><td class="paramname">data</td><td>the data field to be placed in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the transmit queue is full, 1 otherwise </dd></dl>

</div>
</div>
<a id="a0bace2238c993312c518553cdb237743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bace2238c993312c518553cdb237743">&#9670;&nbsp;</a></span>pkt_tx_kc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pkt_tx_kc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a packet which contains key and control byte (cb) fields. </p>
<p>The packet is placed on a transmit queue and sent when it reaches the head of the queue. The "ctrl" field is in the bottom 8 bits of the argument and is shifted left by 16 bits when it is placed in the hardware TCR in the chip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key field to be placed in the packet </td></tr>
    <tr><td class="paramname">ctrl</td><td>the control byte to be placed in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the transmit queue is full, 1 otherwise </dd></dl>

</div>
</div>
<a id="aa5737fbb29e2f0f47e0375e4cba4162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5737fbb29e2f0f47e0375e4cba4162d">&#9670;&nbsp;</a></span>pkt_tx_kdc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pkt_tx_kdc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a packet which contains key, data and control byte (cb) fields. </p>
<p>The packet is placed on a transmit queue and sent when it reaches the head of the queue. The "ctrl" field is in the bottom 8 bits of the argument and is shifted left by 16 bits when it is placed in the hardware TCR in the chip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key field to be placed in the packet </td></tr>
    <tr><td class="paramname">data</td><td>the key field to be placed in the packet </td></tr>
    <tr><td class="paramname">ctrl</td><td>the control byte to be placed in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the transmit queue is full, 1 otherwise </dd></dl>

</div>
</div>
<a id="afa72805def2820951b0e8f1967d518fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa72805def2820951b0e8f1967d518fd">&#9670;&nbsp;</a></span>event_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> event_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a324329d30936f98474493194a7e07847">sync_bool</a>&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start event processing. </p>
<p>An event scheduler runs which takes events from event queues and executes them according to priority ordering. In addition, interrupts will be serviced and any events associated with them will also be executed. This routine will exit if the application calls event_stop or if a kill signal is received from the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>timer period in microseconds (timer disabled if zero) </td></tr>
    <tr><td class="paramname">events</td><td>number of new events to be created before processing begins </td></tr>
    <tr><td class="paramname">wait</td><td>if non-zero causes application to wait from signal from host before processing events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return code from event_stop routine or 255 if killed </dd></dl>

</div>
</div>
<a id="a65e02c560e39a7afafbb5da4255906f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e02c560e39a7afafbb5da4255906f4">&#9670;&nbsp;</a></span>event_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>pause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to stop (pause) event processing or resume it again. </p>
<p>If a pause handler has been registered then this will be called with "pause" as first argument and the second argument that was supplied at the time of registration. (Unlikely to be called from application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pause</td><td>non-zero to pause, zero to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05b364e4b7263b9e979f4f5d02369fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b364e4b7263b9e979f4f5d02369fa3">&#9670;&nbsp;</a></span>event_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>rc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to stop event processing. </p>
<p>This will cause the routine event_start to terminate and the user's code after this will then execute. event_start will return the value provided in the "rc" parameter. This is an internal routine of the event processing system and unlikely to be called from an application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>return code to return from event_start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d885d4db63c2de6f5982e74e86cb84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d885d4db63c2de6f5982e74e86cb84f">&#9670;&nbsp;</a></span>event_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a signal from the monitor processor (i.e., host) before proceeding. Can be used to implement barrier waits. </p>
<p>There are two wait states which are used alternately. The first wait after event_start begins is for the signal WAIT0 and subsequent waits wait for signals WAIT1, WAIT0, WAIT1, etc. </p>

</div>
</div>
<a id="a607f8bbe9eb8a7d99a4a335be0673b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607f8bbe9eb8a7d99a4a335be0673b09">&#9670;&nbsp;</a></span>event_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> event_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an event on an event queue for execution at a later time. </p>
<p>There are (currently) 4 event queues numbered PRIO_0 (highest priority) to PRIO_3 (lowest). Events are taken from queue 0 until it is empty, then they are taken from queue 1 until it is empty, etc, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>pointer to the event to add </td></tr>
    <tr><td class="paramname">priority</td><td>priority of queue to add to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure (invalid priority), 1 otherwise </dd></dl>

</div>
</div>
<a id="a99da351948b0933e1a8f46db6d9b5f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99da351948b0933e1a8f46db6d9b5f7d">&#9670;&nbsp;</a></span>event_queue_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> event_queue_proc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new event and places it on an event queue for execution at a later time. </p>
<p>Calls <a class="el" href="sark_8h.html#ac3dc841f217092d14cd043929c4ef5a0" title="Allocate a new event from the free queue and intialise &quot;proc&quot;, &quot;arg1&quot; and &quot;arg2&quot; fields.">event_new()</a> to create and initialise a new event and then, if that is successful, calls <a class="el" href="sark_8h.html#a607f8bbe9eb8a7d99a4a335be0673b09" title="Places an event on an event queue for execution at a later time.">event_queue()</a> to place it on an event queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>pointer to an event_proc </td></tr>
    <tr><td class="paramname">arg1</td><td>argument 1 to the event_proc </td></tr>
    <tr><td class="paramname">arg2</td><td>argument 2 to the event_proc </td></tr>
    <tr><td class="paramname">priority</td><td>priority of queue to add to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on failure (invalid priority or failed to allocate a new event), 1 otherwise </dd></dl>

</div>
</div>
<a id="a6c997d47394c965abda9a03d8db70ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c997d47394c965abda9a03d8db70ae6">&#9670;&nbsp;</a></span>event_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>restart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the event queue until it is empty. </p>
<p>Events are taken from the event queues in priority order and executed. The "restart" parameter controls whether all queues are rescanned for events when processing of a queue at a particular priority is complete. In general, this will be necessary if executing an event can cause new events to be queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restart</td><td>non-zero to cause queues to be rescanned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59a64a46470fbaa6bf1a129eae284a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a64a46470fbaa6bf1a129eae284a25">&#9670;&nbsp;</a></span>event_register_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_register_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event_proc to be called when a particular event occurs and associate that with an IRQ or FIQ interrupt. </p>
<p>A slot in the VIC to be used for the event must be provided. The pseudo-slot SLOT_FIQ is used to indicate that the FIQ interrupt should be used to ensure the fastest possible processing. Only one event can be associated with each slot and a runtime error will occur if a slot is used more than once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>the event_proc to call </td></tr>
    <tr><td class="paramname">event</td><td>the event to associate with the event_proc </td></tr>
    <tr><td class="paramname">slot</td><td>the VIC slot to use (or SLOT_FIQ for FIQs) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcdc191f66af37a6b0972dca4b80159f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdc191f66af37a6b0972dca4b80159f">&#9670;&nbsp;</a></span>event_register_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_register_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a5554e4b7d32295045a3f7bbcbe1780ce">event_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event_proc to be placed on an event queue when a particular event occurs and associate that with an IRQ interrupt. </p>
<p>A slot in the VIC to be used for the event must be provided. Only one event can be associated with each slot and a runtime error will occur if a slot is used more than once or if an invalid queue priority is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>the event_proc to call </td></tr>
    <tr><td class="paramname">event</td><td>the event to associate with the event_proc </td></tr>
    <tr><td class="paramname">slot</td><td>the VIC slot to use </td></tr>
    <tr><td class="paramname">priority</td><td>the priority of the event queue to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c35de6a8f9072dc49db8984bd7ce135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35de6a8f9072dc49db8984bd7ce135">&#9670;&nbsp;</a></span>event_register_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_register_pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event_proc to be called when event processing is paused. </p>
<p>The event_proc will receive the pause state (0 = resume, 1 = pause) as its first argument and the value of "arg2" as its second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>the event_proc to call </td></tr>
    <tr><td class="paramname">arg2</td><td>the second argument to be supplied to the event_proc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc420e5045a73751d480bf2edfb15e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc420e5045a73751d480bf2edfb15e72">&#9670;&nbsp;</a></span>event_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a0cede94eab5ba2dbda7021d9846fdcdd">event_type</a>&#160;</td>
          <td class="paramname"><em>event_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable an event. </p>
<p>Enabling restores its interrupt handler to one which calls the handler which was originally registered with the event. Disabling changes its interrupt handler to one which receives and acknowledges the interrupt but which doesn't call the handler which was originally registered with the event. It is expected that disable will be called before enable in all cases</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_num</td><td>the event to enable </td></tr>
    <tr><td class="paramname">enable</td><td>non-zero to enable, zero to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24995141a580df346fce85a38cbec1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24995141a580df346fce85a38cbec1b8">&#9670;&nbsp;</a></span>event_register_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_register_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the use of the second timer on the core so that it can be used to provide delayed events via <a class="el" href="sark_8h.html#a472cfc21a621f8e5153f1191342c5bc1" title="Schedule an event to occur at some time in the future.">timer_schedule()</a>. </p>
<p>A runtime error will occur if the VIC slot is already in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>the VIC slot to use for the timer interrupt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4175f7e6597dd3d01fff5b4afa13ea58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4175f7e6597dd3d01fff5b4afa13ea58">&#9670;&nbsp;</a></span>event_register_pkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_register_pkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a64cbeb17d515d4a60718a93633648bd4">vic_slot</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the use of "pkt" routines. </p>
<p>An interrupt handler needs to be installed and assigned to a VIC slot. In addition, the size of the transmit packet queue must be specified. It should be a power of two no larger than 256 and refers to the number of packets in the queue. A run time error will occur if the queue size is invalid, the VIC slot is in use or memory for the packet queue could not be allocated. This routine also initialises the Transmit Control Register to send multicast packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_size</td><td>number of packets in the transmit queue </td></tr>
    <tr><td class="paramname">slot</td><td>the VIC slot to use for the packet transmit interrupt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0354578d007f0031b66bb376939aee54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0354578d007f0031b66bb376939aee54">&#9670;&nbsp;</a></span>event_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> event_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to trigger a user event if one has been registered. </p>
<p>The two arguments will be provided to the <a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a" title="Generic (void) function taking two &quot;uint&quot; args.">event_proc()</a> when it is called. Only one user event can be outstanding at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>first argument to event_proc </td></tr>
    <tr><td class="paramname">arg2</td><td>second argument to event_proc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if a user event is already pending, 1 otherwise </dd></dl>

</div>
</div>
<a id="a472cfc21a621f8e5153f1191342c5bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472cfc21a621f8e5153f1191342c5bc1">&#9670;&nbsp;</a></span>timer_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule an event to occur at some time in the future. </p>
<p>Requires that (hardware) TIMER2 has been set up by a call to timer_register()</p>
<dl class="section note"><dt>Note</dt><dd>this procedure assumes the following event conditions on entry: <pre>
e-&gt;next == NULL
e-&gt;time == 0
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>event to execute </td></tr>
    <tr><td class="paramname">time</td><td>delay in microseconds (non-zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4e6e587060d426aa55638664f1e3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4e6e587060d426aa55638664f1e3b6">&#9670;&nbsp;</a></span>timer_schedule_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> timer_schedule_proc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a14fe7f6e37874a6a9bd576fc6afd6b3a">event_proc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an event, initialises it with the supplied parameters and schedules it to occur at some time in the future. </p>
<p>Requires that the second timer has been set up by a call to timer_register()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>pointer to an event_proc </td></tr>
    <tr><td class="paramname">arg1</td><td>argument 1 to the event_proc </td></tr>
    <tr><td class="paramname">arg2</td><td>argument 2 to the event_proc </td></tr>
    <tr><td class="paramname">time</td><td>delay in microseconds (non-zero) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero: if allocation of new event failed, one otherwise </dd></dl>

</div>
</div>
<a id="aacd1585a3489d9ee70bf5805214fe7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd1585a3489d9ee70bf5805214fe7f2">&#9670;&nbsp;</a></span>timer_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structevent__t">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a timer event that was previously scheduled. </p>
<p>The ID that was allocated when the timer was created must be given in case the timer has already executed and the event has possibly been recycled. This means that a timer event which may be cancelled must be allocated by <a class="el" href="sark_8h.html#ac3dc841f217092d14cd043929c4ef5a0" title="Allocate a new event from the free queue and intialise &quot;proc&quot;, &quot;arg1&quot; and &quot;arg2&quot; fields.">event_new()</a>, the ID noted and the event then scheduled with <a class="el" href="sark_8h.html#a472cfc21a621f8e5153f1191342c5bc1" title="Schedule an event to occur at some time in the future.">timer_schedule()</a>.</p>
<p>It is potentially quite difficult to cancel a timer at the head of the timer queue so in that case the timer is replaced with a placeholder with "proc" set to NULL and the placeholder is left to terminate on the timer interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>event to cancel </td></tr>
    <tr><td class="paramname">ID</td><td>ID of event to cancel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a494d1ae311642ab308b728ecfe310342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494d1ae311642ab308b728ecfe310342">&#9670;&nbsp;</a></span>timer_cancel_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_cancel_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a statically allocated event to be used in place of an event that is cancelled at the head of the timer queue. </p>
<p>It is potentially quite difficult to cancel a timer at the head of the timer queue so in that case the timer is replaced with a placeholder with "proc" set to NULL and the placeholder is left to terminate on the timer interrupt. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a74ab0d3b2aa00fa87c323a46349fe3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ab0d3b2aa00fa87c323a46349fe3b9">&#9670;&nbsp;</a></span>sv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structsv__t">sv_t</a>* const sv = (<a class="el" href="sark_8h.html#structsv__t">sv_t</a> *) <a class="el" href="sark_8h.html#ae64acf62910ab7afdbbe57fbd92e3026">SV_SV</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"sv" points to SV struct at top of sys RAM </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 16 2021 07:58:45 for spinnaker_tools by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
