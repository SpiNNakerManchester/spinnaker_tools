<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spinnaker_tools: sark/sark_base.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">spinnaker_tools<span id="projectnumber">&#160;development</span>
   </div>
   <div id="projectbrief">SpiNNaker API, sark, sc&amp;mp, bmp firmware and build tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ea19b752d6c82237b8b4fef6f5784c70.html">sark</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sark_base.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>SARK - Spinnaker Application Runtime Kernel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sark_8h_source.html">sark.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab5c0a12c6dfa3b12cc5cc5e9381538b0" id="r_ab5c0a12c6dfa3b12cc5cc5e9381538b0"><td class="memItemLeft" align="right" valign="top"><a id="ab5c0a12c6dfa3b12cc5cc5e9381538b0" name="ab5c0a12c6dfa3b12cc5cc5e9381538b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SARK_ID_STR</b>&#160;&#160;&#160;&quot;SARK/SpiNNaker&quot;</td></tr>
<tr class="memdesc:ab5c0a12c6dfa3b12cc5cc5e9381538b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our "application" identifier string. <br /></td></tr>
<tr class="separator:ab5c0a12c6dfa3b12cc5cc5e9381538b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d542339b492b2ad62a803b09b001365" id="r_a6d542339b492b2ad62a803b09b001365"><td class="memItemLeft" align="right" valign="top"><a id="a6d542339b492b2ad62a803b09b001365" name="a6d542339b492b2ad62a803b09b001365"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sark_int_han</b> (void)</td></tr>
<tr class="memdesc:a6d542339b492b2ad62a803b09b001365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for messages from SCAMP. <br /></td></tr>
<tr class="separator:a6d542339b492b2ad62a803b09b001365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04f90a416df87565db777e5a3191910" id="r_af04f90a416df87565db777e5a3191910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#af04f90a416df87565db777e5a3191910">sark_fiq_han</a> (void)</td></tr>
<tr class="memdesc:af04f90a416df87565db777e5a3191910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for messages from SCAMP. (FIQ)  <br /></td></tr>
<tr class="separator:af04f90a416df87565db777e5a3191910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949dafe255d21ee751e45be934f3f05f" id="r_a949dafe255d21ee751e45be934f3f05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a949dafe255d21ee751e45be934f3f05f">rte_handler</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> code)</td></tr>
<tr class="memdesc:a949dafe255d21ee751e45be934f3f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple RTE handler.  <br /></td></tr>
<tr class="separator:a949dafe255d21ee751e45be934f3f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10c5c53ee9f467e3aad6e1a054cc466" id="r_aa10c5c53ee9f467e3aad6e1a054cc466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#aa10c5c53ee9f467e3aad6e1a054cc466">sark_chip_id</a> (void)</td></tr>
<tr class="memdesc:aa10c5c53ee9f467e3aad6e1a054cc466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this chip as a 16-bit number.  <br /></td></tr>
<tr class="separator:aa10c5c53ee9f467e3aad6e1a054cc466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fab81f030fe93ea4f247f2d27f1e53" id="r_a57fab81f030fe93ea4f247f2d27f1e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a57fab81f030fe93ea4f247f2d27f1e53">sark_core_id</a> (void)</td></tr>
<tr class="memdesc:a57fab81f030fe93ea4f247f2d27f1e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the virtual core number of this core.  <br /></td></tr>
<tr class="separator:a57fab81f030fe93ea4f247f2d27f1e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a95df8505e42ee47d56f3bb752a8ddc" id="r_a5a95df8505e42ee47d56f3bb752a8ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a5a95df8505e42ee47d56f3bb752a8ddc">sark_app_id</a> (void)</td></tr>
<tr class="memdesc:a5a95df8505e42ee47d56f3bb752a8ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of the application running on this core.  <br /></td></tr>
<tr class="separator:a5a95df8505e42ee47d56f3bb752a8ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899892c855c4e5260c0b59086ad3866" id="r_a2899892c855c4e5260c0b59086ad3866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a2899892c855c4e5260c0b59086ad3866">sark_count_bits</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> word)</td></tr>
<tr class="memdesc:a2899892c855c4e5260c0b59086ad3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of bits set in a word.  <br /></td></tr>
<tr class="separator:a2899892c855c4e5260c0b59086ad3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef96491568c6a6468cb4d35d1d18d07" id="r_aeef96491568c6a6468cb4d35d1d18d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#aeef96491568c6a6468cb4d35d1d18d07">sark_str_len</a> (char *string)</td></tr>
<tr class="memdesc:aeef96491568c6a6468cb4d35d1d18d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters in a zero terminated string.  <br /></td></tr>
<tr class="separator:aeef96491568c6a6468cb4d35d1d18d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3cb686bab55b58b206f7f13b7ecafa" id="r_a8c3cb686bab55b58b206f7f13b7ecafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a8c3cb686bab55b58b206f7f13b7ecafa">sark_cpu_state</a> (<a class="el" href="sark_8h.html#a6cda0afbb13c1566fcf78c2bbd746a98">cpu_state</a> state)</td></tr>
<tr class="memdesc:a8c3cb686bab55b58b206f7f13b7ecafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CPU state field in the VCPU block for this core.  <br /></td></tr>
<tr class="separator:a8c3cb686bab55b58b206f7f13b7ecafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d3315f83d10fc3071fc74ddc239248" id="r_ad8d3315f83d10fc3071fc74ddc239248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ad8d3315f83d10fc3071fc74ddc239248">sark_app_raise</a> (void)</td></tr>
<tr class="memdesc:ad8d3315f83d10fc3071fc74ddc239248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a semaphore associated with the AppID running on this core.  <br /></td></tr>
<tr class="separator:ad8d3315f83d10fc3071fc74ddc239248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0488210f65d863dd3a609c71ae34a1b" id="r_ad0488210f65d863dd3a609c71ae34a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ad0488210f65d863dd3a609c71ae34a1b">sark_app_lower</a> (void)</td></tr>
<tr class="memdesc:ad0488210f65d863dd3a609c71ae34a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers a semaphore associated with the AppID running on this core.  <br /></td></tr>
<tr class="separator:ad0488210f65d863dd3a609c71ae34a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae711485b0ed4f29a98a08f4476e6c1ed" id="r_ae711485b0ed4f29a98a08f4476e6c1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ae711485b0ed4f29a98a08f4476e6c1ed">sark_app_sema</a> (void)</td></tr>
<tr class="memdesc:ae711485b0ed4f29a98a08f4476e6c1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to get the value of the semaphore associated with the AppID running on this core.  <br /></td></tr>
<tr class="separator:ae711485b0ed4f29a98a08f4476e6c1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b765a16adc6f4a88ac9017b9202ba83" id="r_a7b765a16adc6f4a88ac9017b9202ba83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a7b765a16adc6f4a88ac9017b9202ba83">sark_app_cores</a> (void)</td></tr>
<tr class="memdesc:a7b765a16adc6f4a88ac9017b9202ba83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to get the number of cores on this chip which are running the current application.  <br /></td></tr>
<tr class="separator:a7b765a16adc6f4a88ac9017b9202ba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdba350f69ec3d46d9d559571feb0f6" id="r_affdba350f69ec3d46d9d559571feb0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#affdba350f69ec3d46d9d559571feb0f6">sark_app_lead</a> (void)</td></tr>
<tr class="memdesc:affdba350f69ec3d46d9d559571feb0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the core ID of the lowest numbered core on this chip which is running the current application.  <br /></td></tr>
<tr class="separator:affdba350f69ec3d46d9d559571feb0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82adc6677b15f452e59063cf4a8f2f0" id="r_aa82adc6677b15f452e59063cf4a8f2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#aa82adc6677b15f452e59063cf4a8f2f0">sw_error_fl</a> (<a class="el" href="sark_8h.html#a2e9a700a97ff6b66bbc29d74a8ca5898">sw_err_mode</a> mode, char *file, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> line)</td></tr>
<tr class="memdesc:aa82adc6677b15f452e59063cf4a8f2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a software error, logging the filename and line number at which the error occurs.  <br /></td></tr>
<tr class="separator:aa82adc6677b15f452e59063cf4a8f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ae7a1a5b1868cd2b0a19583c6009a" id="r_ae51ae7a1a5b1868cd2b0a19583c6009a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ae51ae7a1a5b1868cd2b0a19583c6009a">sark_block_init</a> (void *buf, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:ae51ae7a1a5b1868cd2b0a19583c6009a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a memory buffer into a linked list of "count" blocks of "size" bytes.  <br /></td></tr>
<tr class="separator:ae51ae7a1a5b1868cd2b0a19583c6009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ecc6d933675306cc68cd17ce5adbdb" id="r_ab4ecc6d933675306cc68cd17ce5adbdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ab4ecc6d933675306cc68cd17ce5adbdb">sark_msg_get</a> (void)</td></tr>
<tr class="memdesc:ab4ecc6d933675306cc68cd17ce5adbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an SDP message buffer from the pool maintained by SARK.  <br /></td></tr>
<tr class="separator:ab4ecc6d933675306cc68cd17ce5adbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6bbbfa956f793ea41c8702879cffbd" id="r_a8b6bbbfa956f793ea41c8702879cffbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a8b6bbbfa956f793ea41c8702879cffbd">sark_msg_free</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a8b6bbbfa956f793ea41c8702879cffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an SDP message buffer which was acquired by <a class="el" href="sark_8h.html#ab4ecc6d933675306cc68cd17ce5adbdb" title="Get an SDP message buffer from the pool maintained by SARK.">sark_msg_get()</a> to the free buffer pool.  <br /></td></tr>
<tr class="separator:a8b6bbbfa956f793ea41c8702879cffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59970070c28bb7f4fa9280853fb9dec9" id="r_a59970070c28bb7f4fa9280853fb9dec9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a59970070c28bb7f4fa9280853fb9dec9">sark_block_get</a> (<a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *root)</td></tr>
<tr class="memdesc:a59970070c28bb7f4fa9280853fb9dec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic call to get a buffer from a pool whose "root" is supplied.  <br /></td></tr>
<tr class="separator:a59970070c28bb7f4fa9280853fb9dec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d40f5611a6a76a083d0751d2ffcebc3" id="r_a3d40f5611a6a76a083d0751d2ffcebc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a3d40f5611a6a76a083d0751d2ffcebc3">sark_block_free</a> (<a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *root, void *blk)</td></tr>
<tr class="memdesc:a3d40f5611a6a76a083d0751d2ffcebc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic call to free a buffer into a pool whose "root" is supplied.  <br /></td></tr>
<tr class="separator:a3d40f5611a6a76a083d0751d2ffcebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c16f538120c88408968d6a6f0b93d71" id="r_a2c16f538120c88408968d6a6f0b93d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a2c16f538120c88408968d6a6f0b93d71">sark_shmsg_get</a> (void)</td></tr>
<tr class="memdesc:a2c16f538120c88408968d6a6f0b93d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a free SDP message from the shared SysRAM pool.  <br /></td></tr>
<tr class="separator:a2c16f538120c88408968d6a6f0b93d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3c808f1b7045354a386c2bd2872df" id="r_a69f3c808f1b7045354a386c2bd2872df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a69f3c808f1b7045354a386c2bd2872df">sark_shmsg_free</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a69f3c808f1b7045354a386c2bd2872df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a shared memory SDP message to the shared SysRAM pool.  <br /></td></tr>
<tr class="separator:a69f3c808f1b7045354a386c2bd2872df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2885d11fa603c565e9084ffffc3fe557" id="r_a2885d11fa603c565e9084ffffc3fe557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a2885d11fa603c565e9084ffffc3fe557">sark_call_cpp_constructors</a> (void)</td></tr>
<tr class="memdesc:a2885d11fa603c565e9084ffffc3fe557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the constructors for any C++ objects created at global scope.  <br /></td></tr>
<tr class="separator:a2885d11fa603c565e9084ffffc3fe557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496b0c84b642ec5c8cb65a2bd60cab1" id="r_ab496b0c84b642ec5c8cb65a2bd60cab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#ab496b0c84b642ec5c8cb65a2bd60cab1">sark_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *stack)</td></tr>
<tr class="memdesc:ab496b0c84b642ec5c8cb65a2bd60cab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets up SARK stacks and some internal data structures.  <br /></td></tr>
<tr class="separator:ab496b0c84b642ec5c8cb65a2bd60cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ed2549430ecaaa7a6972ad7fb79434" id="r_a34ed2549430ecaaa7a6972ad7fb79434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a34ed2549430ecaaa7a6972ad7fb79434">sark_pre_main</a> (void)</td></tr>
<tr class="memdesc:a34ed2549430ecaaa7a6972ad7fb79434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic setup before calling <a class="el" href="sark_8c.html#aa14f4f1d4c84183b7bf7108bf930a23c" title="Main entry point.">c_main()</a>.  <br /></td></tr>
<tr class="separator:a34ed2549430ecaaa7a6972ad7fb79434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752454711da73d1c9d31ccb8d1feafd2" id="r_a752454711da73d1c9d31ccb8d1feafd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a752454711da73d1c9d31ccb8d1feafd2">sark_post_main</a> (void)</td></tr>
<tr class="memdesc:a752454711da73d1c9d31ccb8d1feafd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic teardown after calling <a class="el" href="sark_8c.html#aa14f4f1d4c84183b7bf7108bf930a23c" title="Main entry point.">c_main()</a>.  <br /></td></tr>
<tr class="separator:a752454711da73d1c9d31ccb8d1feafd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e20f66a6e7058940cdbfdd077fbcdc4" id="r_a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a4e20f66a6e7058940cdbfdd077fbcdc4">sark_msg_send</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> timeout)</td></tr>
<tr class="memdesc:a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an SDP message.  <br /></td></tr>
<tr class="separator:a4e20f66a6e7058940cdbfdd077fbcdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6d37b96c4cd0339de66851e9852e1" id="r_a10a6d37b96c4cd0339de66851e9852e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a10a6d37b96c4cd0339de66851e9852e1">sark_cmd_ver</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a10a6d37b96c4cd0339de66851e9852e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Version command.  <br /></td></tr>
<tr class="separator:a10a6d37b96c4cd0339de66851e9852e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05105db095cf54052c1e00cb2d03424b" id="r_a05105db095cf54052c1e00cb2d03424b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a05105db095cf54052c1e00cb2d03424b">sark_cmd_read</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a05105db095cf54052c1e00cb2d03424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Read command which reads memory and returns the data read to the host.  <br /></td></tr>
<tr class="separator:a05105db095cf54052c1e00cb2d03424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214cec2f71f5dc818d88c0abc398fe29" id="r_a214cec2f71f5dc818d88c0abc398fe29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a214cec2f71f5dc818d88c0abc398fe29">sark_cmd_write</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a214cec2f71f5dc818d88c0abc398fe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Write command which writes memory with data supplied by the host.  <br /></td></tr>
<tr class="separator:a214cec2f71f5dc818d88c0abc398fe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d477747aa6b62a2448590a7f4ed2d" id="r_af67d477747aa6b62a2448590a7f4ed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#af67d477747aa6b62a2448590a7f4ed2d">sark_cmd_fill</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:af67d477747aa6b62a2448590a7f4ed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCP handler for the Fill command which fills memory with a data word.  <br /></td></tr>
<tr class="separator:af67d477747aa6b62a2448590a7f4ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf88c2e52da133466773a2d58698625" id="r_a6bf88c2e52da133466773a2d58698625"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a6bf88c2e52da133466773a2d58698625">sark_debug</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a6bf88c2e52da133466773a2d58698625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic SCP message handler.  <br /></td></tr>
<tr class="separator:a6bf88c2e52da133466773a2d58698625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997d5a71dff5a1773459396fc09a5207" id="r_a997d5a71dff5a1773459396fc09a5207"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a997d5a71dff5a1773459396fc09a5207">swap_hdr</a> (<a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a997d5a71dff5a1773459396fc09a5207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap SDP headers around so that a reply goes back to the sender of the request that it is a reply for.  <br /></td></tr>
<tr class="separator:a997d5a71dff5a1773459396fc09a5207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cb3c4dcaa6cfbd7a2a8923443647ac" id="r_a11cb3c4dcaa6cfbd7a2a8923443647ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__base_8c.html#a11cb3c4dcaa6cfbd7a2a8923443647ac">sark_int</a> (void *pc)</td></tr>
<tr class="memdesc:a11cb3c4dcaa6cfbd7a2a8923443647ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles messages from SCAMP.  <br /></td></tr>
<tr class="separator:a11cb3c4dcaa6cfbd7a2a8923443647ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a89aedee21d244fb4bf7613609168c7b4" id="r_a89aedee21d244fb4bf7613609168c7b4"><td class="memItemLeft" align="right" valign="top"><a id="a89aedee21d244fb4bf7613609168c7b4" name="a89aedee21d244fb4bf7613609168c7b4"></a>
<a class="el" href="sark_8h.html#structsark__data__t">sark_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sark</b></td></tr>
<tr class="memdesc:a89aedee21d244fb4bf7613609168c7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main SARK variables. <br /></td></tr>
<tr class="separator:a89aedee21d244fb4bf7613609168c7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SARK - Spinnaker Application Runtime Kernel. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>&copy; The University of Manchester - 2010-2013</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Steve Temple, APT Group, School of Computer Science </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af04f90a416df87565db777e5a3191910" name="af04f90a416df87565db777e5a3191910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04f90a416df87565db777e5a3191910">&#9670;&#160;</a></span>sark_fiq_han()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_fiq_han </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for messages from SCAMP. (FIQ) </p>
<p>Just throws the packet away. </p>

</div>
</div>
<a id="a949dafe255d21ee751e45be934f3f05f" name="a949dafe255d21ee751e45be934f3f05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949dafe255d21ee751e45be934f3f05f">&#9670;&#160;</a></span>rte_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple RTE handler. </p>
<p>Regs and state have been saved before we get here and if we return we do "cpu_shutdown". Can be replaced by user-provided alternative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10c5c53ee9f467e3aad6e1a054cc466" name="aa10c5c53ee9f467e3aad6e1a054cc466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10c5c53ee9f467e3aad6e1a054cc466">&#9670;&#160;</a></span>sark_chip_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_chip_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of this chip as a 16-bit number. </p>
<p>The upper 8 bits are the X coordinate of the chip and the lower 8 bits are the Y coordinate. Just a wrapper to return sv-&gt;p2p_addr. </p><dl class="section return"><dt>Returns</dt><dd>chip ID ((X &lt;&lt; 8) + Y) </dd></dl>

</div>
</div>
<a id="a57fab81f030fe93ea4f247f2d27f1e53" name="a57fab81f030fe93ea4f247f2d27f1e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fab81f030fe93ea4f247f2d27f1e53">&#9670;&#160;</a></span>sark_core_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_core_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the virtual core number of this core. </p>
<p>This is in the range 0 to 17 (though 0 will only be returned on the core which hosts the monitor processor). Just a wrapper to return sark.virt_cpu. </p><dl class="section return"><dt>Returns</dt><dd>core number in the range 0..17 </dd></dl>

</div>
</div>
<a id="a5a95df8505e42ee47d56f3bb752a8ddc" name="a5a95df8505e42ee47d56f3bb752a8ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a95df8505e42ee47d56f3bb752a8ddc">&#9670;&#160;</a></span>sark_app_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of the application running on this core. </p>
<p>Just a wrapper to return sark_vec-&gt;app_id.</p>
<dl class="section return"><dt>Returns</dt><dd>application ID in the range 0..255 </dd></dl>

</div>
</div>
<a id="a2899892c855c4e5260c0b59086ad3866" name="a2899892c855c4e5260c0b59086ad3866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2899892c855c4e5260c0b59086ad3866">&#9670;&#160;</a></span>sark_count_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_count_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of bits set in a word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>whose bits are to be counted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bits set </dd></dl>

</div>
</div>
<a id="aeef96491568c6a6468cb4d35d1d18d07" name="aeef96491568c6a6468cb4d35d1d18d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef96491568c6a6468cb4d35d1d18d07">&#9670;&#160;</a></span>sark_str_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_str_len </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters in a zero terminated string. </p>
<p>The terminator is not included in the count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>zero terminated string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters </dd></dl>

</div>
</div>
<a id="a8c3cb686bab55b58b206f7f13b7ecafa" name="a8c3cb686bab55b58b206f7f13b7ecafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3cb686bab55b58b206f7f13b7ecafa">&#9670;&#160;</a></span>sark_cpu_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_cpu_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a6cda0afbb13c1566fcf78c2bbd746a98">cpu_state</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CPU state field in the VCPU block for this core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8d3315f83d10fc3071fc74ddc239248" name="ad8d3315f83d10fc3071fc74ddc239248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d3315f83d10fc3071fc74ddc239248">&#9670;&#160;</a></span>sark_app_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_raise </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise a semaphore associated with the AppID running on this core. </p>
<p>The semaphore is initialised to zero before the application starts. Returns the new value of the semaphore and can be used to determine when all cores running a given application have reached a given point. Also allows a single core to be differentiated from other cores by testing for value 1 returned from this function. Uses sark_sema_raise.</p>
<dl class="section return"><dt>Returns</dt><dd>value of semaphore after raising </dd></dl>

</div>
</div>
<a id="ad0488210f65d863dd3a609c71ae34a1b" name="ad0488210f65d863dd3a609c71ae34a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0488210f65d863dd3a609c71ae34a1b">&#9670;&#160;</a></span>sark_app_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_lower </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers a semaphore associated with the AppID running on this core. </p>
<p>If all cores running an application raise the semaphore when they start and lower it when they complete this can be used to determine when all cores have started (semaphore equals number of cores) and when all cores have finished (semaphore equals zero). Uses sark_sema_lower.</p>
<dl class="section return"><dt>Returns</dt><dd>value of semaphore before lowering. </dd></dl>

</div>
</div>
<a id="ae711485b0ed4f29a98a08f4476e6c1ed" name="ae711485b0ed4f29a98a08f4476e6c1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae711485b0ed4f29a98a08f4476e6c1ed">&#9670;&#160;</a></span>sark_app_sema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_sema </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to get the value of the semaphore associated with the AppID running on this core. </p>
<dl class="section return"><dt>Returns</dt><dd>current value of semaphore. </dd></dl>

</div>
</div>
<a id="a7b765a16adc6f4a88ac9017b9202ba83" name="a7b765a16adc6f4a88ac9017b9202ba83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b765a16adc6f4a88ac9017b9202ba83">&#9670;&#160;</a></span>sark_app_cores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_cores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to get the number of cores on this chip which are running the current application. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cores with same AppID </dd></dl>

</div>
</div>
<a id="affdba350f69ec3d46d9d559571feb0f6" name="affdba350f69ec3d46d9d559571feb0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdba350f69ec3d46d9d559571feb0f6">&#9670;&#160;</a></span>sark_app_lead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_app_lead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the core ID of the lowest numbered core on this chip which is running the current application. </p>
<p>Can be used to identify a single core to do shared initialisation.</p>
<dl class="section return"><dt>Returns</dt><dd>lowest numbered core running this app. </dd></dl>

</div>
</div>
<a id="aa82adc6677b15f452e59063cf4a8f2f0" name="aa82adc6677b15f452e59063cf4a8f2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82adc6677b15f452e59063cf4a8f2f0">&#9670;&#160;</a></span>sw_error_fl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw_error_fl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#a2e9a700a97ff6b66bbc29d74a8ca5898">sw_err_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a software error, logging the filename and line number at which the error occurs. </p>
<p>Usually used via the <a class="el" href="sark_8h.html#a70a68a061183156ed09c67e2e724b0c2" title="sw_error calls sw_error_fl(), inserting file name and line number automatically">sw_error</a> macro which inserts the filename and line number automatically. The mode parameter determines whether or not rt_error should be called to shut down the core. mode can be SW_RTE to always call <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a>, SW_NEVER to always return or SW_OPT which consults sark.sw_rte to choose what to do.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>determines if <a class="el" href="sark_8h.html#abe2018e60bb35fb629cdbb057368a2f4" title="Called to signal a fatal error.">rt_error()</a> is called </td></tr>
    <tr><td class="paramname">file</td><td>file name </td></tr>
    <tr><td class="paramname">line</td><td>line number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae51ae7a1a5b1868cd2b0a19583c6009a" name="ae51ae7a1a5b1868cd2b0a19583c6009a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ae7a1a5b1868cd2b0a19583c6009a">&#9670;&#160;</a></span>sark_block_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sark_block_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a memory buffer into a linked list of "count" blocks of "size" bytes. </p>
<p><code>size</code> needs to be at least 4 and a multiple of 4 and the memory buffer needs to be at least <code>size * count" bytes&lt;/tt&gt;. The first
word of each block is a pointer to the next block. Returns a pointer
to the last block. The buffer can be used to initialise a "root" struct of type <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a>.</code></p>
<p><code></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>base address of memory buffer (word aligned) </td></tr>
    <tr><td class="paramname">size</td><td>of each block (at least 4 and a multiple of 4) </td></tr>
    <tr><td class="paramname">count</td><td>number of blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to last block </dd></dl>
<p></code></p>

</div>
</div>
<a id="ab4ecc6d933675306cc68cd17ce5adbdb" name="ab4ecc6d933675306cc68cd17ce5adbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ecc6d933675306cc68cd17ce5adbdb">&#9670;&#160;</a></span>sark_msg_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> * sark_msg_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an SDP message buffer from the pool maintained by SARK. </p>
<p>Applications typically have 4 buffers in the pool though this can be changed by setting sark_vec-&gt;num_msgs in sark_config. If there are no free buffers available, NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to SDP buffer (or NULL) </dd></dl>

</div>
</div>
<a id="a8b6bbbfa956f793ea41c8702879cffbd" name="a8b6bbbfa956f793ea41c8702879cffbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6bbbfa956f793ea41c8702879cffbd">&#9670;&#160;</a></span>sark_msg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_msg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an SDP message buffer which was acquired by <a class="el" href="sark_8h.html#ab4ecc6d933675306cc68cd17ce5adbdb" title="Get an SDP message buffer from the pool maintained by SARK.">sark_msg_get()</a> to the free buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to SDP message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59970070c28bb7f4fa9280853fb9dec9" name="a59970070c28bb7f4fa9280853fb9dec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59970070c28bb7f4fa9280853fb9dec9">&#9670;&#160;</a></span>sark_block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sark_block_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic call to get a buffer from a pool whose "root" is supplied. </p>
<p>Returns pointer to buffer on success, NULL on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>pointer to a block pool held in a <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a free block if available or NULL if not </dd></dl>

</div>
</div>
<a id="a3d40f5611a6a76a083d0751d2ffcebc3" name="a3d40f5611a6a76a083d0751d2ffcebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d40f5611a6a76a083d0751d2ffcebc3">&#9670;&#160;</a></span>sark_block_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structmem__block__t">mem_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic call to free a buffer into a pool whose "root" is supplied. </p>
<p>The block should have been allocated from the same pool previously!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>pointer to a block pool held in a <a class="el" href="sark_8h.html#structmem__block__t" title="Used in the block memory allocator (8 bytes)">mem_block_t</a> </td></tr>
    <tr><td class="paramname">blk</td><td>pointer to the block to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c16f538120c88408968d6a6f0b93d71" name="a2c16f538120c88408968d6a6f0b93d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c16f538120c88408968d6a6f0b93d71">&#9670;&#160;</a></span>sark_shmsg_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> * sark_shmsg_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a free SDP message from the shared SysRAM pool. </p>
<p>Returns pointer to message on success, NULL on failure. Because several cores may attempt to access a shared memory message concurrently, a hardware lock is used to ensure exclusive access. Interrupts are turned off while this occurs but this should be for a relatively short time (1-5us ??)</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a shared memory SDP message or NULL if none available </dd></dl>

</div>
</div>
<a id="a69f3c808f1b7045354a386c2bd2872df" name="a69f3c808f1b7045354a386c2bd2872df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f3c808f1b7045354a386c2bd2872df">&#9670;&#160;</a></span>sark_shmsg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_shmsg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a shared memory SDP message to the shared SysRAM pool. </p>
<p>Because several cores may attempt to access a shared memory message concurrently, a hardware lock is used to ensure exclusive access. Interrupts are turned off while this occurs but this should be for a relatively short time (1-5us ??)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2885d11fa603c565e9084ffffc3fe557" name="a2885d11fa603c565e9084ffffc3fe557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2885d11fa603c565e9084ffffc3fe557">&#9670;&#160;</a></span>sark_call_cpp_constructors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_call_cpp_constructors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the constructors for any C++ objects created at global scope. </p>
<p>Should generally be called from any user-supplied <a class="el" href="sark__base_8c.html#a34ed2549430ecaaa7a6972ad7fb79434" title="Basic setup before calling c_main().">sark_pre_main()</a> function </p>

</div>
</div>
<a id="ab496b0c84b642ec5c8cb65a2bd60cab1" name="ab496b0c84b642ec5c8cb65a2bd60cab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab496b0c84b642ec5c8cb65a2bd60cab1">&#9670;&#160;</a></span>sark_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets up SARK stacks and some internal data structures. </p>
<p>This is a weak declaration so that it may be replaced with another routine though not many systems will want to do this.</p>
<p>"sark_config" (also weak &mdash; see sark_alib.s) can be used to preconfigure some parameters which are used here.</p>
<dl class="section note"><dt>Note</dt><dd>arrive in SVC mode &mdash; must leave in same mode!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>the top of the SVC stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mode (CPSR) which will be entered on return </dd></dl>

</div>
</div>
<a id="a34ed2549430ecaaa7a6972ad7fb79434" name="a34ed2549430ecaaa7a6972ad7fb79434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ed2549430ecaaa7a6972ad7fb79434">&#9670;&#160;</a></span>sark_pre_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_pre_main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic setup before calling <a class="el" href="sark_8c.html#aa14f4f1d4c84183b7bf7108bf930a23c" title="Main entry point.">c_main()</a>. </p>
<p>Can be replaced by user code by name override. </p>

</div>
</div>
<a id="a752454711da73d1c9d31ccb8d1feafd2" name="a752454711da73d1c9d31ccb8d1feafd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752454711da73d1c9d31ccb8d1feafd2">&#9670;&#160;</a></span>sark_post_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_post_main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic teardown after calling <a class="el" href="sark_8c.html#aa14f4f1d4c84183b7bf7108bf930a23c" title="Main entry point.">c_main()</a>. </p>
<p>Can be replaced by user code by name override. </p>

</div>
</div>
<a id="a4e20f66a6e7058940cdbfdd077fbcdc4" name="a4e20f66a6e7058940cdbfdd077fbcdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e20f66a6e7058940cdbfdd077fbcdc4">&#9670;&#160;</a></span>sark_msg_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_msg_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an SDP message. </p>
<p>The message is sent to the monitor processor using a shared memory buffer and then sent to the appropriate place from there. A timeout in milliseconds must be supplied which applies to the transfer of the message to the monitor processor. Normally this will take less than 1ms if the monitor processor is functioning normally. A timeout of 10ms is probably appropriate in most circumstances. The call can fail either because of a timeout or if there are no shared memory SDP buffers available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pointer to an SDP message buffer </td></tr>
    <tr><td class="paramname">timeout</td><td>time in ms before sending is abandoned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 for failure </dd></dl>

</div>
</div>
<a id="a10a6d37b96c4cd0339de66851e9852e1" name="a10a6d37b96c4cd0339de66851e9852e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6d37b96c4cd0339de66851e9852e1">&#9670;&#160;</a></span>sark_cmd_ver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_ver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Version command. </p>
<p>Copies various pieces of information into the supplied SDP message buffer. The information copied is the chip address (16 bits), virtual and physical core numbers (8 bits each), the version number of SARK (16 bits), the size of SDP message data buffers (16 bits) and the Unix time at which the application was built (32 bits). A text string is also returned which gives the base kernel name (eg SARK) and the system on which it is running (eg SpiNNaker).</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>SDP message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message </dd></dl>

</div>
</div>
<a id="a05105db095cf54052c1e00cb2d03424b" name="a05105db095cf54052c1e00cb2d03424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05105db095cf54052c1e00cb2d03424b">&#9670;&#160;</a></span>sark_cmd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Read command which reads memory and returns the data read to the host. </p>
<p>Various argument errors are trapped but if successful, data is transferred from memory into the SDP message starting at msg-&gt;arg1. If half or word alignment is specified, the address and count must be 2 or 4 byte aligned.</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message: <code>msg-&gt;arg1</code>: first address to be read (suitably aligned) <code>msg-&gt;arg2</code>: number of bytes to read (suitably aligned) <code>msg-&gt;arg3</code>: mode of reading (TYPE_BYTE, TYPE_HALF or TYPE_WORD)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message </dd></dl>

</div>
</div>
<a id="a214cec2f71f5dc818d88c0abc398fe29" name="a214cec2f71f5dc818d88c0abc398fe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214cec2f71f5dc818d88c0abc398fe29">&#9670;&#160;</a></span>sark_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Write command which writes memory with data supplied by the host. </p>
<p>Various argument errors are trapped but if successful, data is transferred to memory from the SDP message starting at msg-&gt;data. If half or word alignment is specified, the address and count must be 2 or 4 byte aligned.</p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message: <code>msg-&gt;arg1</code>: first address to be written (suitably aligned) <code>msg-&gt;arg2</code>: number of bytes to write (suitably aligned) <code>msg-&gt;arg3</code>: mode of writing (TYPE_BYTE, TYPE_HALF or TYPE_WORD) <code>msg-&gt;data</code>: data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message (usually 0) </dd></dl>

</div>
</div>
<a id="af67d477747aa6b62a2448590a7f4ed2d" name="af67d477747aa6b62a2448590a7f4ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d477747aa6b62a2448590a7f4ed2d">&#9670;&#160;</a></span>sark_cmd_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_cmd_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SCP handler for the Fill command which fills memory with a data word. </p>
<p>(Unlikely to be called by application code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message <code>msg-&gt;arg1</code>: first address to be written (must be word aligned) <code>msg-&gt;arg2</code>: data word <code>msg-&gt;arg3</code>: byte count (must be non-zero and a multiple of 4)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of returned message (usually 0) </dd></dl>

</div>
</div>
<a id="a6bf88c2e52da133466773a2d58698625" name="a6bf88c2e52da133466773a2d58698625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf88c2e52da133466773a2d58698625">&#9670;&#160;</a></span>sark_debug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic SCP message handler. </p>
<p>SARK only supports a subset of messages. Will delegate to:</p><ul>
<li><a class="el" href="sark__base_8c.html#a10a6d37b96c4cd0339de66851e9852e1" title="SCP handler for the Version command.">sark_cmd_ver()</a></li>
<li><a class="el" href="sark__base_8c.html#a05105db095cf54052c1e00cb2d03424b" title="SCP handler for the Read command which reads memory and returns the data read to the host.">sark_cmd_read()</a></li>
<li><a class="el" href="sark__base_8c.html#a214cec2f71f5dc818d88c0abc398fe29" title="SCP handler for the Write command which writes memory with data supplied by the host.">sark_cmd_write()</a></li>
<li><a class="el" href="sark__base_8c.html#af67d477747aa6b62a2448590a7f4ed2d" title="SCP handler for the Fill command which fills memory with a data word.">sark_cmd_fill()</a> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>The SCP message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the result message payload, in bytes </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a997d5a71dff5a1773459396fc09a5207" name="a997d5a71dff5a1773459396fc09a5207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997d5a71dff5a1773459396fc09a5207">&#9670;&#160;</a></span>swap_hdr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void swap_hdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structsdp__msg__t">sdp_msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap SDP headers around so that a reply goes back to the sender of the request that it is a reply for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>The SDP message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11cb3c4dcaa6cfbd7a2a8923443647ac" name="a11cb3c4dcaa6cfbd7a2a8923443647ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cb3c4dcaa6cfbd7a2a8923443647ac">&#9670;&#160;</a></span>sark_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_int </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles messages from SCAMP. </p>
<p>Interrupt handler for CPU interrupt from monitor processor. Entry and exit are via wrapper code <a class="el" href="sark__base_8c.html#a6d542339b492b2ad62a803b09b001365" title="Interrupt handler for messages from SCAMP.">sark_int_han()</a> in "sark_alib.s" This handler executes in System mode with interrupts enabled.</p>
<p>Handles watchdog timer responses, signals, SDP message reception. Delegates to:</p><ul>
<li><a class="el" href="sark_8h.html#a65e02c560e39a7afafbb5da4255906f4" title="Used to stop (pause) event processing or resume it again.">event_pause()</a></li>
<li><a class="el" href="sark_8h.html#a05b364e4b7263b9e979f4f5d02369fa3" title="Used to stop event processing.">event_stop()</a></li>
<li><a class="el" href="sark__base_8c.html#a6bf88c2e52da133466773a2d58698625" title="Basic SCP message handler.">sark_debug()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>Where the CPU was executing when the interrupt happened. Used for watchdog reporting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 28 2025 06:40:57 for spinnaker_tools by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
