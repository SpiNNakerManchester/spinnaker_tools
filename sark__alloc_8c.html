<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spinnaker_tools: sark/sark_alloc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">spinnaker_tools<span id="projectnumber">&#160;development</span>
   </div>
   <div id="projectbrief">SpiNNaker API, sark, sc&amp;mp, bmp firmware and build tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ea19b752d6c82237b8b4fef6f5784c70.html">sark</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sark_alloc.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Memory management routines for SARK.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sark_8h_source.html">sark.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97bc89d16faea696822ecaedc7ea0094" id="r_a97bc89d16faea696822ecaedc7ea0094"><td class="memItemLeft" align="right" valign="top"><a id="a97bc89d16faea696822ecaedc7ea0094" name="a97bc89d16faea696822ecaedc7ea0094"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FREE_MASK</b>&#160;&#160;&#160;0xe0ff</td></tr>
<tr class="memdesc:a97bc89d16faea696822ecaedc7ea0094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask used to pick out whether a block is allocated and allocated to a particular application instance. <br /></td></tr>
<tr class="separator:a97bc89d16faea696822ecaedc7ea0094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a245d0436adeffc9d66feb2715abdc000" id="r_a245d0436adeffc9d66feb2715abdc000"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a245d0436adeffc9d66feb2715abdc000">sark_xalloc</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tag, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:a245d0436adeffc9d66feb2715abdc000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from the specified heap.  <br /></td></tr>
<tr class="separator:a245d0436adeffc9d66feb2715abdc000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e2f666d19111987b8056468f3b9c80" id="r_a21e2f666d19111987b8056468f3b9c80"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a21e2f666d19111987b8056468f3b9c80">sark_alloc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> count, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:a21e2f666d19111987b8056468f3b9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory of <code>count</code> &times; <code>size</code> bytes from the DTCM heap. Returns either a pointer to the block on success, or NULL on failure.  <br /></td></tr>
<tr class="separator:a21e2f666d19111987b8056468f3b9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4289de17bb19977ccbc8b1f680b4a6a" id="r_ae4289de17bb19977ccbc8b1f680b4a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#ae4289de17bb19977ccbc8b1f680b4a6a">sark_xfree</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, void *ptr, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:ae4289de17bb19977ccbc8b1f680b4a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory block in the specified heap.  <br /></td></tr>
<tr class="separator:ae4289de17bb19977ccbc8b1f680b4a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce895f48f22b29d2aefc923b38b280" id="r_a40ce895f48f22b29d2aefc923b38b280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a40ce895f48f22b29d2aefc923b38b280">sark_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a40ce895f48f22b29d2aefc923b38b280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a block of memory which was previously allocated by <a class="el" href="sark_8h.html#a21e2f666d19111987b8056468f3b9c80" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a> (i.e., from the DTCM heap).  <br /></td></tr>
<tr class="separator:a40ce895f48f22b29d2aefc923b38b280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1e347ad21b21b298040b27f36a2bba" id="r_a0d1e347ad21b21b298040b27f36a2bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a0d1e347ad21b21b298040b27f36a2bba">sark_xfree_id</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> lock)</td></tr>
<tr class="memdesc:a0d1e347ad21b21b298040b27f36a2bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all allocated blocks in the specified heap which are tagged with the given "app_id".  <br /></td></tr>
<tr class="separator:a0d1e347ad21b21b298040b27f36a2bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89c52519c74f83f002becac03d9ff3" id="r_a8e89c52519c74f83f002becac03d9ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a8e89c52519c74f83f002becac03d9ff3">sark_heap_max</a> (<a class="el" href="sark_8h.html#structheap__t">heap_t</a> *heap, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> flag)</td></tr>
<tr class="memdesc:a8e89c52519c74f83f002becac03d9ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the supplied heap and return the size of the largest free block (in bytes).  <br /></td></tr>
<tr class="separator:a8e89c52519c74f83f002becac03d9ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ecfbb84d87eb35e32ef30e5604c056" id="r_af7ecfbb84d87eb35e32ef30e5604c056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#af7ecfbb84d87eb35e32ef30e5604c056">sark_heap_init</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *base, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *top)</td></tr>
<tr class="memdesc:af7ecfbb84d87eb35e32ef30e5604c056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an area of memory as a heap.  <br /></td></tr>
<tr class="separator:af7ecfbb84d87eb35e32ef30e5604c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7bb03f41c2c68ad7fdb944bb23af64" id="r_a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a2d7bb03f41c2c68ad7fdb944bb23af64">rtr_alloc_id</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of entries in the router multicast table (and associate the supplied app_id with this block).  <br /></td></tr>
<tr class="separator:a2d7bb03f41c2c68ad7fdb944bb23af64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d9cc3e46a707969eb592b258744e5" id="r_abb9d9cc3e46a707969eb592b258744e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#abb9d9cc3e46a707969eb592b258744e5">rtr_alloc</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr class="memdesc:abb9d9cc3e46a707969eb592b258744e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of entries in the router multicast table (and associate the caller's app_id with this block).  <br /></td></tr>
<tr class="separator:abb9d9cc3e46a707969eb592b258744e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb6e9bbf8425f6fe224833f6239c4ba" id="r_a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a5cb6e9bbf8425f6fe224833f6239c4ba">rtr_free</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> entry, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> clear)</td></tr>
<tr class="memdesc:a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block of MC table entries which starts with the supplied entry. The relevant router registers can be optionally re-initialised.  <br /></td></tr>
<tr class="separator:a5cb6e9bbf8425f6fe224833f6239c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e038cf666dba5f8be35bb8cb8eead45" id="r_a7e038cf666dba5f8be35bb8cb8eead45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a7e038cf666dba5f8be35bb8cb8eead45">rtr_free_id</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> clear)</td></tr>
<tr class="memdesc:a7e038cf666dba5f8be35bb8cb8eead45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all allocated blocks in the router which are tagged with the given "app_id".  <br /></td></tr>
<tr class="separator:a7e038cf666dba5f8be35bb8cb8eead45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89de816e4c181b8f24ba21873b24a27" id="r_af89de816e4c181b8f24ba21873b24a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#af89de816e4c181b8f24ba21873b24a27">rtr_alloc_max</a> (void)</td></tr>
<tr class="memdesc:af89de816e4c181b8f24ba21873b24a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the largest free block in the router multicast table (or zero if table is full).  <br /></td></tr>
<tr class="separator:af89de816e4c181b8f24ba21873b24a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab071722b9278c0e03e0b1d1b186557" id="r_a9ab071722b9278c0e03e0b1d1b186557"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sark__alloc_8c.html#a9ab071722b9278c0e03e0b1d1b186557">sark_tag_ptr</a> (<a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tag, <a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> app_id)</td></tr>
<tr class="memdesc:a9ab071722b9278c0e03e0b1d1b186557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a tagged allocation.  <br /></td></tr>
<tr class="separator:a9ab071722b9278c0e03e0b1d1b186557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory management routines for SARK. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>&copy; The University of Manchester - 2009-2013</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Steve Temple, APT Group, School of Computer Science </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a245d0436adeffc9d66feb2715abdc000" name="a245d0436adeffc9d66feb2715abdc000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245d0436adeffc9d66feb2715abdc000">&#9670;&#160;</a></span>sark_xalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sark_xalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from the specified heap. </p>
<p>The block will be tagged with the supplied "tag" which must be &lt;= 255. Returns NULL on failure (not enough memory, bad tag or tag in use).</p>
<p>The flag parameter contains two flags in the bottom two bits. If bit 0 is set (<a class="el" href="sark_8h.html#a170c14469b29096618dd05f78a9414c4" title="Lock this operation.">ALLOC_LOCK</a>), the heap manipulation is done behind a lock with interrupts disabled. If bit 1 is set (<a class="el" href="sark_8h.html#a6ff0a91d1c257f90c16d72e4a48f619a" title="Use supplied AppID.">ALLOC_ID</a>), the block is tagged with the AppID provided in bits 15:8 of the flag, otherwise the AppID of the current application is used.</p>
<p>The 8-bit <code>tag</code> is combined with the AppID and stored in the "free" field while the block is allocated. If the <code>tag</code> is non-zero, the block is only allocated if the tag is not in use. The tag (and AppID) is stored in the "alloc_tag" table while the block is allocated.</p>
<p>If this command is used to allocate for an app-id which isn't the caller's, the user should set <code>sv-&gt;app_data[app_id].clean</code> to 0 for the application concerned. This ensures that the memory will be cleaned up by a stop signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap from which the block should be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of the block in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>8-bit tag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>flags to control locking and AppID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated block or NULL on failure </dd></dl>

</div>
</div>
<a id="a21e2f666d19111987b8056468f3b9c80" name="a21e2f666d19111987b8056468f3b9c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e2f666d19111987b8056468f3b9c80">&#9670;&#160;</a></span>sark_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sark_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory of <code>count</code> &times; <code>size</code> bytes from the DTCM heap. Returns either a pointer to the block on success, or NULL on failure. </p>
<p>The total amount of memory available for allocation is around 62KB less all of the static variables used by the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of sub-blocks to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of each sub-block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block or NULL </dd></dl>

</div>
</div>
<a id="ae4289de17bb19977ccbc8b1f680b4a6a" name="ae4289de17bb19977ccbc8b1f680b4a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4289de17bb19977ccbc8b1f680b4a6a">&#9670;&#160;</a></span>sark_xfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_xfree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory block in the specified heap. </p>
<p>If the lock bit in the <code>flag</code> parameter is set, the manipulation of the heap is done behind a lock. This will turn interrupts off for some time while the heap is searched. If a NULL pointer (<code>ptr</code>) is passed in, a runtime error will occur. If there is an "alloc_tag" entry associated with the block it is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap to which the free block should be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>a pointer to the memory block to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>bit 0 set if the heap should be locked during free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40ce895f48f22b29d2aefc923b38b280" name="a40ce895f48f22b29d2aefc923b38b280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce895f48f22b29d2aefc923b38b280">&#9670;&#160;</a></span>sark_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sark_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a block of memory which was previously allocated by <a class="el" href="sark_8h.html#a21e2f666d19111987b8056468f3b9c80" title="Allocate a block of memory of count × size bytes from the DTCM heap. Returns either a pointer to the ...">sark_alloc()</a> (i.e., from the DTCM heap). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to memory block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d1e347ad21b21b298040b27f36a2bba" name="a0d1e347ad21b21b298040b27f36a2bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1e347ad21b21b298040b27f36a2bba">&#9670;&#160;</a></span>sark_xfree_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_xfree_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all allocated blocks in the specified heap which are tagged with the given "app_id". </p>
<p>The <code>flag</code> parameter specifies if locking is needed in the <a class="el" href="sark_8h.html#ae4289de17bb19977ccbc8b1f680b4a6a" title="Free a memory block in the specified heap.">sark_xfree()</a> call. Returns the number of blocks freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap from which blocks should be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>the AppID whose block should be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>controls locking of heap transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks freed </dd></dl>

</div>
</div>
<a id="a8e89c52519c74f83f002becac03d9ff3" name="a8e89c52519c74f83f002becac03d9ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89c52519c74f83f002becac03d9ff3">&#9670;&#160;</a></span>sark_heap_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sark_heap_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the supplied heap and return the size of the largest free block (in bytes). </p>
<p>The <code>flag</code> parameter allows the heap to be locked while the search takes place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>controls locking of heap transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of largest block </dd></dl>

</div>
</div>
<a id="af7ecfbb84d87eb35e32ef30e5604c056" name="af7ecfbb84d87eb35e32ef30e5604c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ecfbb84d87eb35e32ef30e5604c056">&#9670;&#160;</a></span>sark_heap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sark_8h.html#structheap__t">heap_t</a> * sark_heap_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an area of memory as a heap. </p>
<p>Arguments are (uint) pointers to base and top of the area. Returns a pointer to the heap (same address as the base). Assumes the area is large enough to hold a minimal heap (a zero size heap needs 28 bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>pointer to bottom of heap memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>pointer to top of heap memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to heap </dd></dl>

</div>
</div>
<a id="a2d7bb03f41c2c68ad7fdb944bb23af64" name="a2d7bb03f41c2c68ad7fdb944bb23af64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7bb03f41c2c68ad7fdb944bb23af64">&#9670;&#160;</a></span>rtr_alloc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of entries in the router multicast table (and associate the supplied app_id with this block). </p>
<p>If this command is used to allocate for an app-id which isn't the caller's, the user should set sv-&gt;app_data[app_id].clean to 0 for the application concerned. This ensures that the memory will be cleaned up by a stop signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of entries to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID associated with block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of first entry in block on success, zero on failure. </dd></dl>

</div>
</div>
<a id="abb9d9cc3e46a707969eb592b258744e5" name="abb9d9cc3e46a707969eb592b258744e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d9cc3e46a707969eb592b258744e5">&#9670;&#160;</a></span>rtr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of entries in the router multicast table (and associate the caller's app_id with this block). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of entries to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of first entry in block on success, zero on failure. </dd></dl>

</div>
</div>
<a id="a5cb6e9bbf8425f6fe224833f6239c4ba" name="a5cb6e9bbf8425f6fe224833f6239c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb6e9bbf8425f6fe224833f6239c4ba">&#9670;&#160;</a></span>rtr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block of MC table entries which starts with the supplied entry. The relevant router registers can be optionally re-initialised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>first entry in the block (as returned by rtr_alloc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear</td><td>non-zero to cause router registers to be re-initialised </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e038cf666dba5f8be35bb8cb8eead45" name="a7e038cf666dba5f8be35bb8cb8eead45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e038cf666dba5f8be35bb8cb8eead45">&#9670;&#160;</a></span>rtr_free_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_free_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all allocated blocks in the router which are tagged with the given "app_id". </p>
<p>The relevant router registers can be optionally re-initialised. Returns number of blocks freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID whose entries are to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear</td><td>non-zero to cause router registers to be re-initialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks freed </dd></dl>

</div>
</div>
<a id="af89de816e4c181b8f24ba21873b24a27" name="af89de816e4c181b8f24ba21873b24a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89de816e4c181b8f24ba21873b24a27">&#9670;&#160;</a></span>rtr_alloc_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> rtr_alloc_max </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the largest free block in the router multicast table (or zero if table is full). </p>
<dl class="section return"><dt>Returns</dt><dd>number of entries in largest block </dd></dl>

</div>
</div>
<a id="a9ab071722b9278c0e03e0b1d1b186557" name="a9ab071722b9278c0e03e0b1d1b186557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab071722b9278c0e03e0b1d1b186557">&#9670;&#160;</a></span>sark_tag_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sark_tag_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spinnaker_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>app_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to a tagged allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the allocation to get a pointer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_id</td><td>AppID whose tagged allocation to read (or 0 to use the current core's app ID) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first allocation found with the given tag, or NULL if no such allocation exists. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 4 2025 10:05:00 for spinnaker_tools by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
